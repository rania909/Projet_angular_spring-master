import { InjectionToken, Directive, ElementRef, NgZone, Optional, Inject, Input, HostBinding, NgModule } from '@angular/core';
import { updateSvg, updateCanvas } from 'jdenticon';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
const JDENTICON_CONFIG = new InjectionToken('JdenticonConfig');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/svg-jdenticon.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Use same attributes as for VanillaJS Jdenticon.
// tslint:disable:directive-selector no-input-rename
class SvgJdenticonDirective {
    /**
     * @param {?} el
     * @param {?} zone
     * @param {?} config
     */
    constructor(el, zone, config) {
        this.el = el;
        this.zone = zone;
        this.config = config;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        // setTimeout is used to ensure that Angular has updated the host attributes.
        // runOutsideAngular is used to prevent an additional Angular change detection.
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            setTimeout((/**
             * @return {?}
             */
            () => {
                updateSvg(this.el.nativeElement, undefined, this.config);
            }));
        }));
    }
}
SvgJdenticonDirective.ɵfac = function SvgJdenticonDirective_Factory(t) { return new (t || SvgJdenticonDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(JDENTICON_CONFIG, 8)); };
SvgJdenticonDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: SvgJdenticonDirective, selectors: [["svg", "data-jdenticon-hash", ""], ["svg", "data-jdenticon-value", ""]], hostVars: 4, hostBindings: function SvgJdenticonDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-jdenticon-hash", ctx.hash)("data-jdenticon-value", ctx.value)("width", ctx.width)("height", ctx.height);
    } }, inputs: { hash: ["data-jdenticon-hash", "hash"], value: ["data-jdenticon-value", "value"], width: "width", height: "height" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
SvgJdenticonDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [JDENTICON_CONFIG,] }] }
];
SvgJdenticonDirective.propDecorators = {
    hash: [{ type: Input, args: ['data-jdenticon-hash',] }, { type: HostBinding, args: ['attr.data-jdenticon-hash',] }],
    value: [{ type: Input, args: ['data-jdenticon-value',] }, { type: HostBinding, args: ['attr.data-jdenticon-value',] }],
    width: [{ type: Input }, { type: HostBinding, args: ['attr.width',] }],
    height: [{ type: Input }, { type: HostBinding, args: ['attr.height',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SvgJdenticonDirective, [{
        type: Directive,
        args: [{
                selector: 'svg[data-jdenticon-hash],svg[data-jdenticon-value]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [JDENTICON_CONFIG]
            }] }]; }, { hash: [{
            type: Input,
            args: ['data-jdenticon-hash']
        }, {
            type: HostBinding,
            args: ['attr.data-jdenticon-hash']
        }], value: [{
            type: Input,
            args: ['data-jdenticon-value']
        }, {
            type: HostBinding,
            args: ['attr.data-jdenticon-value']
        }], width: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.width']
        }], height: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.height']
        }] }); })();
if (false) {
    /** @type {?} */
    SvgJdenticonDirective.prototype.hash;
    /** @type {?} */
    SvgJdenticonDirective.prototype.value;
    /** @type {?} */
    SvgJdenticonDirective.prototype.width;
    /** @type {?} */
    SvgJdenticonDirective.prototype.height;
    /**
     * @type {?}
     * @private
     */
    SvgJdenticonDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    SvgJdenticonDirective.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    SvgJdenticonDirective.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/canvas-jdenticon.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Use same attributes as for VanillaJS Jdenticon.
// tslint:disable:directive-selector no-input-rename
class CanvasJdenticonDirective {
    /**
     * @param {?} el
     * @param {?} zone
     * @param {?} config
     */
    constructor(el, zone, config) {
        this.el = el;
        this.zone = zone;
        this.config = config;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        // setTimeout is used to ensure that Angular has updated the host attributes.
        // runOutsideAngular is used to prevent an additional Angular change detection.
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            setTimeout((/**
             * @return {?}
             */
            () => {
                updateCanvas(this.el.nativeElement, undefined, this.config);
            }));
        }));
    }
}
CanvasJdenticonDirective.ɵfac = function CanvasJdenticonDirective_Factory(t) { return new (t || CanvasJdenticonDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(JDENTICON_CONFIG, 8)); };
CanvasJdenticonDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CanvasJdenticonDirective, selectors: [["canvas", "data-jdenticon-hash", ""], ["canvas", "data-jdenticon-value", ""]], hostVars: 4, hostBindings: function CanvasJdenticonDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-jdenticon-hash", ctx.hash)("data-jdenticon-value", ctx.value)("width", ctx.width)("height", ctx.height);
    } }, inputs: { hash: ["data-jdenticon-hash", "hash"], value: ["data-jdenticon-value", "value"], width: "width", height: "height" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
CanvasJdenticonDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [JDENTICON_CONFIG,] }] }
];
CanvasJdenticonDirective.propDecorators = {
    hash: [{ type: Input, args: ['data-jdenticon-hash',] }, { type: HostBinding, args: ['attr.data-jdenticon-hash',] }],
    value: [{ type: Input, args: ['data-jdenticon-value',] }, { type: HostBinding, args: ['attr.data-jdenticon-value',] }],
    width: [{ type: Input }, { type: HostBinding, args: ['attr.width',] }],
    height: [{ type: Input }, { type: HostBinding, args: ['attr.height',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CanvasJdenticonDirective, [{
        type: Directive,
        args: [{
                selector: 'canvas[data-jdenticon-hash],canvas[data-jdenticon-value]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [JDENTICON_CONFIG]
            }] }]; }, { hash: [{
            type: Input,
            args: ['data-jdenticon-hash']
        }, {
            type: HostBinding,
            args: ['attr.data-jdenticon-hash']
        }], value: [{
            type: Input,
            args: ['data-jdenticon-value']
        }, {
            type: HostBinding,
            args: ['attr.data-jdenticon-value']
        }], width: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.width']
        }], height: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.height']
        }] }); })();
if (false) {
    /** @type {?} */
    CanvasJdenticonDirective.prototype.hash;
    /** @type {?} */
    CanvasJdenticonDirective.prototype.value;
    /** @type {?} */
    CanvasJdenticonDirective.prototype.width;
    /** @type {?} */
    CanvasJdenticonDirective.prototype.height;
    /**
     * @type {?}
     * @private
     */
    CanvasJdenticonDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    CanvasJdenticonDirective.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    CanvasJdenticonDirective.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ngx-jdenticon.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxJdenticonModule {
}
NgxJdenticonModule.ɵfac = function NgxJdenticonModule_Factory(t) { return new (t || NgxJdenticonModule)(); };
NgxJdenticonModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgxJdenticonModule });
NgxJdenticonModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxJdenticonModule, [{
        type: NgModule,
        args: [{
                declarations: [SvgJdenticonDirective, CanvasJdenticonDirective],
                exports: [SvgJdenticonDirective, CanvasJdenticonDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxJdenticonModule, { declarations: [SvgJdenticonDirective, CanvasJdenticonDirective], exports: [SvgJdenticonDirective, CanvasJdenticonDirective] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-jdenticon.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { CanvasJdenticonDirective, JDENTICON_CONFIG, NgxJdenticonModule, SvgJdenticonDirective };

//# sourceMappingURL=ngx-jdenticon.js.map