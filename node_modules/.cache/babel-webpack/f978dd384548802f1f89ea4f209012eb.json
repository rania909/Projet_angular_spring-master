{"ast":null,"code":"import _classCallCheck from \"A:/machine learning/test/Projet_angular_spring/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"A:/machine learning/test/Projet_angular_spring/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Component, EventEmitter, Input, Output, ViewChild, Renderer2, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nvar _c0 = [\"videoWrapper\"];\nvar _c1 = [\"qrCanvas\"];\n\nfunction QrScannerComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelement(1, \"canvas\", 3, 4);\n    ɵngcc0.ɵɵelement(3, \"div\", null, 5);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"hidden\", ctx_r0.canvasHidden)(\"width\", ctx_r0.canvasWidth)(\"height\", ctx_r0.canvasHeight);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵstyleProp(\"width\", ctx_r0.canvasWidth)(\"height\", ctx_r0.canvasHeight);\n  }\n}\n\nfunction QrScannerComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"p\");\n    ɵngcc0.ɵɵtext(2, \" You are using an \");\n    ɵngcc0.ɵɵelementStart(3, \"strong\");\n    ɵngcc0.ɵɵtext(4, \"outdated\");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtext(5, \" browser. Please \");\n    ɵngcc0.ɵɵelementStart(6, \"a\", 6);\n    ɵngcc0.ɵɵtext(7, \"upgrade your browser\");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtext(8, \" to improve your experience. \");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n}\n\nvar AlignmentPattern = /*#__PURE__*/function () {\n  /**\n   * @param {?} posX\n   * @param {?} posY\n   * @param {?} estimatedModuleSize\n   */\n  function AlignmentPattern(posX, posY, estimatedModuleSize) {\n    _classCallCheck(this, AlignmentPattern);\n\n    this.count = 1;\n\n    this.incrementCount = function () {\n      this.count++;\n    };\n\n    this.aboutEquals = function (moduleSize, i, j) {\n      if (Math.abs(i - this.y) <= moduleSize && Math.abs(j - this.x) <= moduleSize) {\n        var\n        /** @type {?} */\n        moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n        return moduleSizeDiff <= 1.0 || moduleSizeDiff / this.estimatedModuleSize <= 1.0;\n      }\n\n      return false;\n    };\n\n    this.x = posX;\n    this.y = posY;\n    this.estimatedModuleSize = estimatedModuleSize;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(AlignmentPattern, [{\n    key: \"EstimatedModuleSize\",\n    get: function get() {\n      return this.estimatedModuleSize;\n    }\n  }, {\n    key: \"Count\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.count;\n    }\n  }, {\n    key: \"X\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return Math.floor(this.x);\n    }\n  }, {\n    key: \"Y\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return Math.floor(this.y);\n    }\n  }]);\n\n  return AlignmentPattern;\n}();\n\nvar AlignmentPatternFinder =\n/**\n * @param {?} image\n * @param {?} startX\n * @param {?} startY\n * @param {?} width\n * @param {?} height\n * @param {?} moduleSize\n * @param {?} imageWidth\n * @param {?} imageHeight\n * @param {?} resultPointCallback\n */\nfunction AlignmentPatternFinder(image, startX, startY, width, height, moduleSize, imageWidth, imageHeight, resultPointCallback) {\n  _classCallCheck(this, AlignmentPatternFinder);\n\n  this.possibleCenters = new Array();\n  this.crossCheckStateCount = new Array(0, 0, 0);\n\n  this.centerFromEnd = function (stateCount, end) {\n    return end - stateCount[2] - stateCount[1] / 2.0;\n  };\n\n  this.foundPatternCross = function (stateCount) {\n    var\n    /** @type {?} */\n    moduleSize = this.moduleSize;\n    var\n    /** @type {?} */\n    maxVariance = moduleSize / 2.0;\n\n    for (var\n    /** @type {?} */\n    i = 0; i < 3; i++) {\n      if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  this.crossCheckVertical = function (startI, centerJ, maxCount, originalStateCountTotal) {\n    var\n    /** @type {?} */\n    image = this.image;\n    var\n    /** @type {?} */\n    maxI = this.imageHeight;\n    var\n    /** @type {?} */\n    stateCount = this.crossCheckStateCount;\n    stateCount[0] = 0;\n    stateCount[1] = 0;\n    stateCount[2] = 0; // Start counting up from center\n\n    var\n    /** @type {?} */\n    i = startI;\n\n    while (i >= 0 && image[centerJ + i * this.imageWidth] && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i--;\n    } // If already too many modules in this state or ran off the edge:\n\n\n    if (i < 0 || stateCount[1] > maxCount) {\n      return NaN;\n    }\n\n    while (i >= 0 && !image[centerJ + i * this.imageWidth] && stateCount[0] <= maxCount) {\n      stateCount[0]++;\n      i--;\n    }\n\n    if (stateCount[0] > maxCount) {\n      return NaN;\n    } // Now also count down from center\n\n\n    i = startI + 1;\n\n    while (i < maxI && image[centerJ + i * this.imageWidth] && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i++;\n    }\n\n    if (i == maxI || stateCount[1] > maxCount) {\n      return NaN;\n    }\n\n    while (i < maxI && !image[centerJ + i * this.imageWidth] && stateCount[2] <= maxCount) {\n      stateCount[2]++;\n      i++;\n    }\n\n    if (stateCount[2] > maxCount) {\n      return NaN;\n    }\n\n    var\n    /** @type {?} */\n    stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n\n    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n      return NaN;\n    }\n\n    return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, i) : NaN;\n  };\n\n  this.handlePossibleCenter = function (stateCount, i, j) {\n    var\n    /** @type {?} */\n    stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n    var\n    /** @type {?} */\n    centerJ = this.centerFromEnd(stateCount, j);\n    var\n    /** @type {?} */\n    centerI = this.crossCheckVertical(i, Math.floor(centerJ), 2 * stateCount[1], stateCountTotal);\n\n    if (!isNaN(centerI)) {\n      var\n      /** @type {?} */\n      estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;\n      var\n      /** @type {?} */\n      max = this.possibleCenters.length;\n\n      for (var\n      /** @type {?} */\n      index = 0; index < max; index++) {\n        var\n        /** @type {?} */\n        center = this.possibleCenters[index]; // Look for about the same center and module size:\n\n        if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n          return new AlignmentPattern(centerJ, centerI, estimatedModuleSize);\n        }\n      } // Hadn't found this before; save it\n\n\n      var\n      /** @type {?} */\n      point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);\n      this.possibleCenters.push(point);\n\n      if (this.resultPointCallback != null) {\n        this.resultPointCallback.foundPossibleResultPoint(point);\n      }\n    }\n\n    return null;\n  };\n\n  this.find = function () {\n    var\n    /** @type {?} */\n    startX = this.startX;\n    var\n    /** @type {?} */\n    height = this.height;\n    var\n    /** @type {?} */\n    maxJ = startX + this.width;\n    var\n    /** @type {?} */\n    middleI = this.startY + (height >> 1); // We are looking for black/white/black modules in 1:1:1 ratio;\n    // this tracks the number of black/white/black modules seen so far\n\n    var\n    /** @type {?} */\n    stateCount = new Array(0, 0, 0);\n\n    for (var\n    /** @type {?} */\n    iGen = 0; iGen < height; iGen++) {\n      // Search from middle outwards\n      var\n      /** @type {?} */\n      i = middleI + ((iGen & 0x01) == 0 ? iGen + 1 >> 1 : -(iGen + 1 >> 1));\n      stateCount[0] = 0;\n      stateCount[1] = 0;\n      stateCount[2] = 0;\n      var\n      /** @type {?} */\n      j = startX; // Burn off leading white pixels before anything else; if we start in the middle of\n      // a white run, it doesn't make sense to count its length, since we don't know if the\n      // white run continued to the left of the start point\n\n      while (j < maxJ && !this.image[j + this.imageWidth * i]) {\n        j++;\n      }\n\n      var\n      /** @type {?} */\n      currentState = 0;\n\n      while (j < maxJ) {\n        if (this.image[j + i * this.imageWidth]) {\n          // Black pixel\n          if (currentState == 1) {\n            // Counting black pixels\n            stateCount[currentState]++;\n          } else {\n            // Counting white pixels\n            if (currentState == 2) {\n              // A winner?\n              if (this.foundPatternCross(stateCount)) {\n                // Yes\n                var\n                /** @type {?} */\n                confirmed = this.handlePossibleCenter(stateCount, i, j);\n\n                if (confirmed != null) {\n                  return confirmed;\n                }\n              }\n\n              stateCount[0] = stateCount[2];\n              stateCount[1] = 1;\n              stateCount[2] = 0;\n              currentState = 1;\n            } else {\n              stateCount[++currentState]++;\n            }\n          }\n        } else {\n          // White pixel\n          if (currentState == 1) {\n            // Counting black pixels\n            currentState++;\n          }\n\n          stateCount[currentState]++;\n        }\n\n        j++;\n      }\n\n      if (this.foundPatternCross(stateCount)) {\n        var\n        /** @type {?} */\n        confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\n\n        if (confirmed != null) {\n          return confirmed;\n        }\n      }\n    } // Hmm, nothing we saw was observed and confirmed twice. If we had\n    // any guess at all, return it.\n\n\n    if (!(this.possibleCenters.length == 0)) {\n      return this.possibleCenters[0];\n    }\n\n    throw \"Couldn't find enough alignment patterns\";\n  };\n\n  this.image = image;\n  this.startX = startX;\n  this.startY = startY;\n  this.width = width;\n  this.height = height;\n  this.moduleSize = moduleSize;\n  this.resultPointCallback = resultPointCallback;\n  this.imageWidth = imageWidth;\n  this.imageHeight = imageHeight;\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\n\nvar PerspectiveTransform = /*#__PURE__*/function () {\n  /**\n   * @param {?} a11\n   * @param {?} a21\n   * @param {?} a31\n   * @param {?} a12\n   * @param {?} a22\n   * @param {?} a32\n   * @param {?} a13\n   * @param {?} a23\n   * @param {?} a33\n   */\n  function PerspectiveTransform(a11, a21, a31, a12, a22, a32, a13, a23, a33) {\n    _classCallCheck(this, PerspectiveTransform);\n\n    this.transformPoints1 = function (points) {\n      var\n      /** @type {?} */\n      max = points.length;\n      var\n      /** @type {?} */\n      a11 = this.a11;\n      var\n      /** @type {?} */\n      a12 = this.a12;\n      var\n      /** @type {?} */\n      a13 = this.a13;\n      var\n      /** @type {?} */\n      a21 = this.a21;\n      var\n      /** @type {?} */\n      a22 = this.a22;\n      var\n      /** @type {?} */\n      a23 = this.a23;\n      var\n      /** @type {?} */\n      a31 = this.a31;\n      var\n      /** @type {?} */\n      a32 = this.a32;\n      var\n      /** @type {?} */\n      a33 = this.a33;\n\n      for (var\n      /** @type {?} */\n      i = 0; i < max; i += 2) {\n        var\n        /** @type {?} */\n        x = points[i];\n        var\n        /** @type {?} */\n        y = points[i + 1];\n        var\n        /** @type {?} */\n        denominator = a13 * x + a23 * y + a33;\n        points[i] = (a11 * x + a21 * y + a31) / denominator;\n        points[i + 1] = (a12 * x + a22 * y + a32) / denominator;\n      }\n    };\n\n    this.transformPoints2 = function (xValues, yValues) {\n      var\n      /** @type {?} */\n      n = xValues.length;\n\n      for (var\n      /** @type {?} */\n      i = 0; i < n; i++) {\n        var\n        /** @type {?} */\n        x = xValues[i];\n        var\n        /** @type {?} */\n        y = yValues[i];\n        var\n        /** @type {?} */\n        denominator = this.a13 * x + this.a23 * y + this.a33;\n        xValues[i] = (this.a11 * x + this.a21 * y + this.a31) / denominator;\n        yValues[i] = (this.a12 * x + this.a22 * y + this.a32) / denominator;\n      }\n    };\n\n    this.buildAdjoint = function () {\n      // Adjoint is the transpose of the cofactor matrix:\n      return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);\n    };\n\n    this.times = function (other) {\n      return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);\n    };\n\n    this.a11 = a11;\n    this.a12 = a12;\n    this.a13 = a13;\n    this.a21 = a21;\n    this.a22 = a22;\n    this.a23 = a23;\n    this.a31 = a31;\n    this.a32 = a32;\n    this.a33 = a33;\n  }\n  /**\n   * @param {?} x0\n   * @param {?} y0\n   * @param {?} x1\n   * @param {?} y1\n   * @param {?} x2\n   * @param {?} y2\n   * @param {?} x3\n   * @param {?} y3\n   * @param {?} x0p\n   * @param {?} y0p\n   * @param {?} x1p\n   * @param {?} y1p\n   * @param {?} x2p\n   * @param {?} y2p\n   * @param {?} x3p\n   * @param {?} y3p\n   * @return {?}\n   */\n\n\n  _createClass(PerspectiveTransform, null, [{\n    key: \"quadrilateralToQuadrilateral\",\n    value: function quadrilateralToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p) {\n      var\n      /** @type {?} */\n      qToS = this.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);\n      var\n      /** @type {?} */\n      sToQ = this.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);\n      return sToQ.times(qToS);\n    }\n    /**\n     * @param {?} x0\n     * @param {?} y0\n     * @param {?} x1\n     * @param {?} y1\n     * @param {?} x2\n     * @param {?} y2\n     * @param {?} x3\n     * @param {?} y3\n     * @return {?}\n     */\n\n  }, {\n    key: \"squareToQuadrilateral\",\n    value: function squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3) {\n      var\n      /** @type {?} */\n      dy2 = y3 - y2;\n      var\n      /** @type {?} */\n      dy3 = y0 - y1 + y2 - y3;\n\n      if (dy2 == 0.0 && dy3 == 0.0) {\n        return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0.0, 0.0, 1.0);\n      } else {\n        var\n        /** @type {?} */\n        dx1 = x1 - x2;\n        var\n        /** @type {?} */\n        dx2 = x3 - x2;\n        var\n        /** @type {?} */\n        dx3 = x0 - x1 + x2 - x3;\n        var\n        /** @type {?} */\n        dy1 = y1 - y2;\n        var\n        /** @type {?} */\n        denominator = dx1 * dy2 - dx2 * dy1;\n        var\n        /** @type {?} */\n        a13 = (dx3 * dy2 - dx2 * dy3) / denominator;\n        var\n        /** @type {?} */\n        a23 = (dx1 * dy3 - dx3 * dy1) / denominator;\n        return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1.0);\n      }\n    }\n    /**\n     * @param {?} x0\n     * @param {?} y0\n     * @param {?} x1\n     * @param {?} y1\n     * @param {?} x2\n     * @param {?} y2\n     * @param {?} x3\n     * @param {?} y3\n     * @return {?}\n     */\n\n  }, {\n    key: \"quadrilateralToSquare\",\n    value: function quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3) {\n      // Here, the adjoint serves as the inverse:\n      var\n      /** @type {?} */\n      t = this.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3);\n      return t.buildAdjoint();\n    }\n  }]);\n\n  return PerspectiveTransform;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n\nvar BitMatrix = /*#__PURE__*/function () {\n  /**\n   * @param {?} width\n   * @param {?=} height\n   */\n  function BitMatrix(width, height) {\n    _classCallCheck(this, BitMatrix);\n\n    if (!height) height = width;\n\n    if (width < 1 || height < 1) {\n      throw \"Both dimensions must be greater than 0\";\n    }\n\n    this.width = width;\n    this.height = height;\n    this.rowSize = width >> 5;\n\n    if ((width & 0x1f) != 0) {\n      this.rowSize++;\n    }\n\n    this.bits = new Array(this.rowSize * height);\n\n    for (var\n    /** @type {?} */\n    i = 0; i < this.bits.length; i++) {\n      this.bits[i] = 0;\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(BitMatrix, [{\n    key: \"Width\",\n    get: function get() {\n      return this.width;\n    }\n  }, {\n    key: \"Height\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.height;\n    }\n  }, {\n    key: \"Dimension\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      if (this.width != this.height) {\n        throw \"Can't call getDimension() on a non-square matrix\";\n      }\n\n      return this.width;\n    }\n  }, {\n    key: \"URShift\",\n    value:\n    /**\n     * @param {?} number\n     * @param {?} bits\n     * @return {?}\n     */\n    function URShift(number, bits) {\n      if (number >= 0) return number >> bits;else return (number >> bits) + (2 << ~bits);\n    }\n    /**\n     * @param {?} x\n     * @param {?} y\n     * @return {?}\n     */\n\n  }, {\n    key: \"get_Renamed\",\n    value: function get_Renamed(x, y) {\n      var\n      /** @type {?} */\n      offset = y * this.rowSize + (x >> 5);\n      return (this.URShift(this.bits[offset], x & 0x1f) & 1) != 0;\n    }\n    /**\n     * @param {?} x\n     * @param {?} y\n     * @return {?}\n     */\n\n  }, {\n    key: \"set_Renamed\",\n    value: function set_Renamed(x, y) {\n      var\n      /** @type {?} */\n      offset = y * this.rowSize + (x >> 5);\n      this.bits[offset] |= 1 << (x & 0x1f);\n    }\n    /**\n     * @param {?} x\n     * @param {?} y\n     * @return {?}\n     */\n\n  }, {\n    key: \"flip\",\n    value: function flip(x, y) {\n      var\n      /** @type {?} */\n      offset = y * this.rowSize + (x >> 5);\n      this.bits[offset] ^= 1 << (x & 0x1f);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var\n      /** @type {?} */\n      max = this.bits.length;\n\n      for (var\n      /** @type {?} */\n      i = 0; i < max; i++) {\n        this.bits[i] = 0;\n      }\n    }\n    /**\n     * @param {?} left\n     * @param {?} top\n     * @param {?} width\n     * @param {?} height\n     * @return {?}\n     */\n\n  }, {\n    key: \"setRegion\",\n    value: function setRegion(left, top, width, height) {\n      if (top < 0 || left < 0) {\n        throw \"Left and top must be nonnegative\";\n      }\n\n      if (height < 1 || width < 1) {\n        throw \"Height and width must be at least 1\";\n      }\n\n      var\n      /** @type {?} */\n      right = left + width;\n      var\n      /** @type {?} */\n      bottom = top + height;\n\n      if (bottom > this.height || right > this.width) {\n        throw \"The region must fit inside the matrix\";\n      }\n\n      for (var\n      /** @type {?} */\n      y = top; y < bottom; y++) {\n        var\n        /** @type {?} */\n        offset = y * this.rowSize;\n\n        for (var\n        /** @type {?} */\n        x = left; x < right; x++) {\n          this.bits[offset + (x >> 5)] |= 1 << (x & 0x1f);\n        }\n      }\n    }\n  }]);\n\n  return BitMatrix;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\n\nvar GridSampler = /*#__PURE__*/function () {\n  /**\n   * @param {?} width\n   * @param {?} height\n   */\n  function GridSampler(width, height) {\n    _classCallCheck(this, GridSampler);\n\n    this.width = width;\n    this.height = height;\n  }\n  /**\n   * @param {?} image\n   * @param {?} points\n   * @return {?}\n   */\n\n\n  _createClass(GridSampler, [{\n    key: \"checkAndNudgePoints\",\n    value: function checkAndNudgePoints(image, points) {\n      var\n      /** @type {?} */\n      width = this.width;\n      var\n      /** @type {?} */\n      height = this.height; // Check and nudge points from start until we see some that are OK:\n\n      var\n      /** @type {?} */\n      nudged = true;\n\n      for (var\n      /** @type {?} */\n      offset = 0; offset < points.length && nudged; offset += 2) {\n        var\n        /** @type {?} */\n        x = Math.floor(points[offset]);\n        var\n        /** @type {?} */\n        y = Math.floor(points[offset + 1]);\n\n        if (x < -1 || x > width || y < -1 || y > height) {\n          throw \"Error.checkAndNudgePoints \";\n        }\n\n        nudged = false;\n\n        if (x == -1) {\n          points[offset] = 0.0;\n          nudged = true;\n        } else if (x == width) {\n          points[offset] = width - 1;\n          nudged = true;\n        }\n\n        if (y == -1) {\n          points[offset + 1] = 0.0;\n          nudged = true;\n        } else if (y == height) {\n          points[offset + 1] = height - 1;\n          nudged = true;\n        }\n      } // Check and nudge points from end:\n\n\n      nudged = true;\n\n      for (var\n      /** @type {?} */\n      offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {\n        var\n        /** @type {?} */\n        x = Math.floor(points[offset]);\n        var\n        /** @type {?} */\n        y = Math.floor(points[offset + 1]);\n\n        if (x < -1 || x > width || y < -1 || y > height) {\n          throw \"Error.checkAndNudgePoints \";\n        }\n\n        nudged = false;\n\n        if (x == -1) {\n          points[offset] = 0.0;\n          nudged = true;\n        } else if (x == width) {\n          points[offset] = width - 1;\n          nudged = true;\n        }\n\n        if (y == -1) {\n          points[offset + 1] = 0.0;\n          nudged = true;\n        } else if (y == height) {\n          points[offset + 1] = height - 1;\n          nudged = true;\n        }\n      }\n    }\n    /**\n     * @param {?} image\n     * @param {?} rawImage\n     * @param {?} dimension\n     * @param {?} transform\n     * @return {?}\n     */\n\n  }, {\n    key: \"sampleGrid3\",\n    value: function sampleGrid3(image, rawImage, dimension, transform) {\n      var\n      /** @type {?} */\n      bits = new BitMatrix(dimension, dimension);\n      var\n      /** @type {?} */\n      points = new Array(dimension << 1);\n\n      for (var\n      /** @type {?} */\n      y = 0; y < dimension; y++) {\n        var\n        /** @type {?} */\n        max = points.length;\n        var\n        /** @type {?} */\n        iValue = y + 0.5;\n\n        for (var\n        /** @type {?} */\n        x = 0; x < max; x += 2) {\n          points[x] = (x >> 1) + 0.5;\n          points[x + 1] = iValue;\n        }\n\n        transform.transformPoints1(points); // Quick check to see if points transformed to something inside the image;\n        // sufficient to check the endpoints\n\n        this.checkAndNudgePoints(image, points);\n\n        try {\n          for (var\n          /** @type {?} */\n          x = 0; x < max; x += 2) {\n            var\n            /** @type {?} */\n            xpoint = Math.floor(points[x]) * 4 + Math.floor(points[x + 1]) * this.width * 4;\n            var\n            /** @type {?} */\n            bit = image[Math.floor(points[x]) + this.width * Math.floor(points[x + 1])];\n            rawImage.data[xpoint] = bit ? 255 : 0;\n            rawImage.data[xpoint + 1] = bit ? 255 : 0;\n            rawImage.data[xpoint + 2] = 0;\n            rawImage.data[xpoint + 3] = 255; //bits[x >> 1][ y]=bit;\n\n            if (bit) bits.set_Renamed(x >> 1, y);\n          }\n        } catch (\n        /** @type {?} */\n        aioobe) {\n          // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting\n          // transform gets \"twisted\" such that it maps a straight line of points to a set of points\n          // whose endpoints are in bounds, but others are not. There is probably some mathematical\n          // way to detect this about the transformation that I don't know yet.\n          // This results in an ugly runtime exception despite our clever checks above -- can't have\n          // that. We could check each point's coordinates but that feels duplicative. We settle for\n          // catching and wrapping ArrayIndexOutOfBoundsException.\n          throw \"Error.checkAndNudgePoints\";\n        }\n      }\n\n      return bits;\n    }\n    /**\n     * @param {?} image\n     * @param {?} dimension\n     * @param {?} p1ToX\n     * @param {?} p1ToY\n     * @param {?} p2ToX\n     * @param {?} p2ToY\n     * @param {?} p3ToX\n     * @param {?} p3ToY\n     * @param {?} p4ToX\n     * @param {?} p4ToY\n     * @param {?} p1FromX\n     * @param {?} p1FromY\n     * @param {?} p2FromX\n     * @param {?} p2FromY\n     * @param {?} p3FromX\n     * @param {?} p3FromY\n     * @param {?} p4FromX\n     * @param {?} p4FromY\n     * @return {?}\n     */\n\n  }, {\n    key: \"sampleGridx\",\n    value: function sampleGridx(image, dimension, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY) {\n      var\n      /** @type {?} */\n      transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);\n      return this.sampleGrid3(image, {}, dimension, transform);\n    }\n  }]);\n\n  return GridSampler;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n\nvar ErrorCorrectionLevel = /*#__PURE__*/function () {\n  /**\n   * @param {?} ordinal\n   * @param {?} bits\n   * @param {?} name\n   */\n  function ErrorCorrectionLevel(ordinal, bits, name) {\n    _classCallCheck(this, ErrorCorrectionLevel);\n\n    this.ordinal_Renamed_Field = ordinal;\n    this.bits = bits;\n    this.name = name;\n  }\n  /**\n   * @param {?} bits\n   * @return {?}\n   */\n\n\n  _createClass(ErrorCorrectionLevel, [{\n    key: \"Bits\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.bits;\n    }\n  }, {\n    key: \"Name\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.name;\n    }\n  }, {\n    key: \"ordinal\",\n    value:\n    /**\n     * @return {?}\n     */\n    function ordinal() {\n      return this.ordinal_Renamed_Field;\n    }\n  }], [{\n    key: \"forBits\",\n    value: function forBits(bits) {\n      if (bits < 0 || bits >= this.FOR_BITS.length) {\n        throw \"ArgumentException\";\n      }\n\n      return this.FOR_BITS[bits];\n    }\n  }]);\n\n  return ErrorCorrectionLevel;\n}();\n\nErrorCorrectionLevel.L = new ErrorCorrectionLevel(0, 0x01, \"L\");\nErrorCorrectionLevel.M = new ErrorCorrectionLevel(1, 0x00, \"M\");\nErrorCorrectionLevel.Q = new ErrorCorrectionLevel(2, 0x03, \"Q\");\nErrorCorrectionLevel.H = new ErrorCorrectionLevel(3, 0x02, \"H\");\nErrorCorrectionLevel.FOR_BITS = new Array(ErrorCorrectionLevel.M, ErrorCorrectionLevel.L, ErrorCorrectionLevel.H, ErrorCorrectionLevel.Q);\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\nvar FormatInformation = /*#__PURE__*/function () {\n  /**\n   * @param {?} formatInfo\n   */\n  function FormatInformation(formatInfo) {\n    _classCallCheck(this, FormatInformation);\n\n    this.Equals = function (o) {\n      var\n      /** @type {?} */\n      other = o;\n      return this.errorCorrectionLevel == other.errorCorrectionLevel && this.dataMask == other.dataMask;\n    };\n\n    this.errorCorrectionLevel = ErrorCorrectionLevel.forBits(formatInfo >> 3 & 0x03);\n    this.dataMask = formatInfo & 0x07;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(FormatInformation, [{\n    key: \"ErrorCorrectionLevel\",\n    get: function get() {\n      return this.errorCorrectionLevel;\n    }\n  }, {\n    key: \"DataMask\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.dataMask;\n    }\n  }, {\n    key: \"GetHashCode\",\n    value:\n    /**\n     * @return {?}\n     */\n    function GetHashCode() {\n      return this.errorCorrectionLevel.ordinal() << 3 | this.dataMask;\n    }\n    /**\n     * @param {?} number\n     * @param {?} bits\n     * @return {?}\n     */\n\n  }], [{\n    key: \"URShift\",\n    value: function URShift(number, bits) {\n      if (number >= 0) return number >> bits;else return (number >> bits) + (2 << ~bits);\n    }\n    /**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n\n  }, {\n    key: \"numBitsDiffering\",\n    value: function numBitsDiffering(a, b) {\n      a ^= b; // a now has a 1 bit exactly where its bit differs with b's\n      // Count bits set quickly with a series of lookups:\n\n      return FormatInformation.BITS_SET_IN_HALF_BYTE[a & 0x0F] + FormatInformation.BITS_SET_IN_HALF_BYTE[this.URShift(a, 4) & 0x0F] + FormatInformation.BITS_SET_IN_HALF_BYTE[this.URShift(a, 8) & 0x0F] + FormatInformation.BITS_SET_IN_HALF_BYTE[this.URShift(a, 12) & 0x0F] + FormatInformation.BITS_SET_IN_HALF_BYTE[this.URShift(a, 16) & 0x0F] + FormatInformation.BITS_SET_IN_HALF_BYTE[this.URShift(a, 20) & 0x0F] + FormatInformation.BITS_SET_IN_HALF_BYTE[this.URShift(a, 24) & 0x0F] + FormatInformation.BITS_SET_IN_HALF_BYTE[this.URShift(a, 28) & 0x0F];\n    }\n    /**\n     * @param {?} maskedFormatInfo\n     * @return {?}\n     */\n\n  }, {\n    key: \"decodeFormatInformation\",\n    value: function decodeFormatInformation(maskedFormatInfo) {\n      var\n      /** @type {?} */\n      formatInfo = this.doDecodeFormatInformation(maskedFormatInfo);\n\n      if (formatInfo != null) {\n        return formatInfo;\n      } // Should return null, but, some QR codes apparently\n      // do not mask this info. Try again by actually masking the pattern\n      // first\n\n\n      return this.doDecodeFormatInformation(maskedFormatInfo ^ FormatInformation.FORMAT_INFO_MASK_QR);\n    }\n    /**\n     * @param {?} maskedFormatInfo\n     * @return {?}\n     */\n\n  }, {\n    key: \"doDecodeFormatInformation\",\n    value: function doDecodeFormatInformation(maskedFormatInfo) {\n      // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing\n      var\n      /** @type {?} */\n      bestDifference = 0xffffffff;\n      var\n      /** @type {?} */\n      bestFormatInfo = 0;\n\n      for (var\n      /** @type {?} */\n      i = 0; i < FormatInformation.FORMAT_INFO_DECODE_LOOKUP.length; i++) {\n        var\n        /** @type {?} */\n        decodeInfo = FormatInformation.FORMAT_INFO_DECODE_LOOKUP[i];\n        var\n        /** @type {?} */\n        targetInfo = decodeInfo[0];\n\n        if (targetInfo == maskedFormatInfo) {\n          // Found an exact match\n          return new FormatInformation(decodeInfo[1]);\n        }\n\n        var\n        /** @type {?} */\n        bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo, targetInfo);\n\n        if (bitsDifference < bestDifference) {\n          bestFormatInfo = decodeInfo[1];\n          bestDifference = bitsDifference;\n        }\n      } // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits\n      // differing means we found a match\n\n\n      if (bestDifference <= 3) {\n        return new FormatInformation(bestFormatInfo);\n      }\n\n      return null;\n    }\n    /**\n     * @param {?} bits\n     * @return {?}\n     */\n\n  }, {\n    key: \"forBits\",\n    value: function forBits(bits) {\n      {\n        if (bits < 0 || bits >= FormatInformation.FOR_BITS.length) {\n          throw \"ArgumentException\";\n        }\n\n        return FormatInformation.FOR_BITS[bits];\n      }\n    }\n  }]);\n\n  return FormatInformation;\n}();\n\nFormatInformation.FORMAT_INFO_MASK_QR = 0x5412;\nFormatInformation.FORMAT_INFO_DECODE_LOOKUP = new Array(new Array(0x5412, 0x00), new Array(0x5125, 0x01), new Array(0x5E7C, 0x02), new Array(0x5B4B, 0x03), new Array(0x45F9, 0x04), new Array(0x40CE, 0x05), new Array(0x4F97, 0x06), new Array(0x4AA0, 0x07), new Array(0x77C4, 0x08), new Array(0x72F3, 0x09), new Array(0x7DAA, 0x0A), new Array(0x789D, 0x0B), new Array(0x662F, 0x0C), new Array(0x6318, 0x0D), new Array(0x6C41, 0x0E), new Array(0x6976, 0x0F), new Array(0x1689, 0x10), new Array(0x13BE, 0x11), new Array(0x1CE7, 0x12), new Array(0x19D0, 0x13), new Array(0x0762, 0x14), new Array(0x0255, 0x15), new Array(0x0D0C, 0x16), new Array(0x083B, 0x17), new Array(0x355F, 0x18), new Array(0x3068, 0x19), new Array(0x3F31, 0x1A), new Array(0x3A06, 0x1B), new Array(0x24B4, 0x1C), new Array(0x2183, 0x1D), new Array(0x2EDA, 0x1E), new Array(0x2BED, 0x1F));\nFormatInformation.BITS_SET_IN_HALF_BYTE = new Array(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\nFormatInformation.L = new ErrorCorrectionLevel(0, 0x01, \"L\");\nFormatInformation.M = new ErrorCorrectionLevel(1, 0x00, \"M\");\nFormatInformation.Q = new ErrorCorrectionLevel(2, 0x03, \"Q\");\nFormatInformation.H = new ErrorCorrectionLevel(3, 0x02, \"H\");\nFormatInformation.FOR_BITS = new Array(FormatInformation.M, FormatInformation.L, FormatInformation.H, FormatInformation.Q);\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\nvar ECB = /*#__PURE__*/function () {\n  /**\n   * @param {?} count\n   * @param {?} dataCodewords\n   */\n  function ECB(count, dataCodewords) {\n    _classCallCheck(this, ECB);\n\n    this.count = count;\n    this.dataCodewords = dataCodewords;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ECB, [{\n    key: \"Count\",\n    get: function get() {\n      return this.count;\n    }\n  }, {\n    key: \"DataCodewords\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.dataCodewords;\n    }\n  }]);\n\n  return ECB;\n}();\n\nvar ECBlocks = /*#__PURE__*/function () {\n  /**\n   * @param {?} ecCodewordsPerBlock\n   * @param {?} ecBlocks1\n   * @param {?=} ecBlocks2\n   */\n  function ECBlocks(ecCodewordsPerBlock, ecBlocks1, ecBlocks2) {\n    _classCallCheck(this, ECBlocks);\n\n    this.getECBlocks = function () {\n      return this.ecBlocks;\n    };\n\n    this.ecCodewordsPerBlock = ecCodewordsPerBlock;\n    if (ecBlocks2) this.ecBlocks = new Array(ecBlocks1, ecBlocks2);else this.ecBlocks = new Array(ecBlocks1);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ECBlocks, [{\n    key: \"ECCodewordsPerBlock\",\n    get: function get() {\n      return this.ecCodewordsPerBlock;\n    }\n  }, {\n    key: \"TotalECCodewords\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.ecCodewordsPerBlock * this.NumBlocks;\n    }\n  }, {\n    key: \"NumBlocks\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      var\n      /** @type {?} */\n      total = 0;\n\n      for (var\n      /** @type {?} */\n      i = 0; i < this.ecBlocks.length; i++) {\n        total += this.ecBlocks[i].length;\n      }\n\n      return total;\n    }\n  }]);\n\n  return ECBlocks;\n}();\n\nvar Version = /*#__PURE__*/function () {\n  /**\n   * @param {?} versionNumber\n   * @param {?} alignmentPatternCenters\n   * @param {?} ecBlocks1\n   * @param {?} ecBlocks2\n   * @param {?} ecBlocks3\n   * @param {?} ecBlocks4\n   */\n  function Version(versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4) {\n    _classCallCheck(this, Version);\n\n    this.buildFunctionPattern = function () {\n      var\n      /** @type {?} */\n      dimension = this.DimensionForVersion;\n      var\n      /** @type {?} */\n      bitMatrix = new BitMatrix(dimension); // Top left finder pattern + separator + format\n\n      bitMatrix.setRegion(0, 0, 9, 9); // Top right finder pattern + separator + format\n\n      bitMatrix.setRegion(dimension - 8, 0, 8, 9); // Bottom left finder pattern + separator + format\n\n      bitMatrix.setRegion(0, dimension - 8, 9, 8); // Alignment patterns\n\n      var\n      /** @type {?} */\n      max = this.alignmentPatternCenters.length;\n\n      for (var\n      /** @type {?} */\n      x = 0; x < max; x++) {\n        var\n        /** @type {?} */\n        i = this.alignmentPatternCenters[x] - 2;\n\n        for (var\n        /** @type {?} */\n        y = 0; y < max; y++) {\n          if (x == 0 && (y == 0 || y == max - 1) || x == max - 1 && y == 0) {\n            // No alignment patterns near the three finder paterns\n            continue;\n          }\n\n          bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);\n        }\n      } // Vertical timing pattern\n\n\n      bitMatrix.setRegion(6, 9, 1, dimension - 17); // Horizontal timing pattern\n\n      bitMatrix.setRegion(9, 6, dimension - 17, 1);\n\n      if (this.versionNumber > 6) {\n        // Version info, top right\n        bitMatrix.setRegion(dimension - 11, 0, 3, 6); // Version info, bottom left\n\n        bitMatrix.setRegion(0, dimension - 11, 6, 3);\n      }\n\n      return bitMatrix;\n    };\n\n    this.getECBlocksForLevel = function (ecLevel) {\n      return this.ecBlocks[ecLevel.ordinal()];\n    };\n\n    this.versionNumber = versionNumber;\n    this.alignmentPatternCenters = alignmentPatternCenters;\n    this.ecBlocks = new Array(ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4);\n    var\n    /** @type {?} */\n    total = 0;\n    var\n    /** @type {?} */\n    ecCodewords = ecBlocks1.ECCodewordsPerBlock;\n    var\n    /** @type {?} */\n    ecbArray = ecBlocks1.getECBlocks();\n\n    for (var\n    /** @type {?} */\n    i = 0; i < ecbArray.length; i++) {\n      var\n      /** @type {?} */\n      ecBlock = ecbArray[i];\n      total += ecBlock.Count * (ecBlock.DataCodewords + ecCodewords);\n    }\n\n    this.totalCodewords = total;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(Version, [{\n    key: \"VersionNumber\",\n    get: function get() {\n      return this.versionNumber;\n    }\n  }, {\n    key: \"AlignmentPatternCenters\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.alignmentPatternCenters;\n    }\n  }, {\n    key: \"TotalCodewords\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.totalCodewords;\n    }\n  }, {\n    key: \"DimensionForVersion\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return 17 + 4 * this.versionNumber;\n    }\n  }], [{\n    key: \"getVersionForNumber\",\n    value:\n    /**\n     * @param {?} versionNumber\n     * @return {?}\n     */\n    function getVersionForNumber(versionNumber) {\n      if (versionNumber < 1 || versionNumber > 40) {\n        throw \"ArgumentException\";\n      }\n\n      return Version.VERSIONS[versionNumber - 1];\n    }\n    /**\n     * @param {?} dimension\n     * @return {?}\n     */\n\n  }, {\n    key: \"getProvisionalVersionForDimension\",\n    value: function getProvisionalVersionForDimension(dimension) {\n      if (dimension % 4 != 1) {\n        throw \"Error getProvisionalVersionForDimension\";\n      }\n\n      try {\n        return Version.getVersionForNumber(dimension - 17 >> 2);\n      } catch (\n      /** @type {?} */\n      iae) {\n        throw \"Error getVersionForNumber\";\n      }\n    }\n    /**\n     * @param {?} versionBits\n     * @return {?}\n     */\n\n  }, {\n    key: \"decodeVersionInformation\",\n    value: function decodeVersionInformation(versionBits) {\n      var\n      /** @type {?} */\n      bestDifference = 0xffffffff;\n      var\n      /** @type {?} */\n      bestVersion = 0;\n\n      for (var\n      /** @type {?} */\n      i = 0; i < Version.VERSION_DECODE_INFO.length; i++) {\n        var\n        /** @type {?} */\n        targetVersion = Version.VERSION_DECODE_INFO[i]; // Do the version info bits match exactly? done.\n\n        if (targetVersion == versionBits) {\n          return this.getVersionForNumber(i + 7);\n        } // Otherwise see if this is the closest to a real version info bit string\n        // we have seen so far\n\n\n        var\n        /** @type {?} */\n        bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);\n\n        if (bitsDifference < bestDifference) {\n          bestVersion = i + 7;\n          bestDifference = bitsDifference;\n        }\n      } // We can tolerate up to 3 bits of error since no two version info codewords will\n      // differ in less than 4 bits.\n\n\n      if (bestDifference <= 3) {\n        return this.getVersionForNumber(bestVersion);\n      } // If we didn't find a close enough match, fail\n\n\n      return null;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"buildVersions\",\n    value: function buildVersions() {\n      return new Array(new Version(1, new Array(), new ECBlocks(7, new ECB(1, 19)), new ECBlocks(10, new ECB(1, 16)), new ECBlocks(13, new ECB(1, 13)), new ECBlocks(17, new ECB(1, 9))), new Version(2, new Array(6, 18), new ECBlocks(10, new ECB(1, 34)), new ECBlocks(16, new ECB(1, 28)), new ECBlocks(22, new ECB(1, 22)), new ECBlocks(28, new ECB(1, 16))), new Version(3, new Array(6, 22), new ECBlocks(15, new ECB(1, 55)), new ECBlocks(26, new ECB(1, 44)), new ECBlocks(18, new ECB(2, 17)), new ECBlocks(22, new ECB(2, 13))), new Version(4, new Array(6, 26), new ECBlocks(20, new ECB(1, 80)), new ECBlocks(18, new ECB(2, 32)), new ECBlocks(26, new ECB(2, 24)), new ECBlocks(16, new ECB(4, 9))), new Version(5, new Array(6, 30), new ECBlocks(26, new ECB(1, 108)), new ECBlocks(24, new ECB(2, 43)), new ECBlocks(18, new ECB(2, 15), new ECB(2, 16)), new ECBlocks(22, new ECB(2, 11), new ECB(2, 12))), new Version(6, new Array(6, 34), new ECBlocks(18, new ECB(2, 68)), new ECBlocks(16, new ECB(4, 27)), new ECBlocks(24, new ECB(4, 19)), new ECBlocks(28, new ECB(4, 15))), new Version(7, new Array(6, 22, 38), new ECBlocks(20, new ECB(2, 78)), new ECBlocks(18, new ECB(4, 31)), new ECBlocks(18, new ECB(2, 14), new ECB(4, 15)), new ECBlocks(26, new ECB(4, 13), new ECB(1, 14))), new Version(8, new Array(6, 24, 42), new ECBlocks(24, new ECB(2, 97)), new ECBlocks(22, new ECB(2, 38), new ECB(2, 39)), new ECBlocks(22, new ECB(4, 18), new ECB(2, 19)), new ECBlocks(26, new ECB(4, 14), new ECB(2, 15))), new Version(9, new Array(6, 26, 46), new ECBlocks(30, new ECB(2, 116)), new ECBlocks(22, new ECB(3, 36), new ECB(2, 37)), new ECBlocks(20, new ECB(4, 16), new ECB(4, 17)), new ECBlocks(24, new ECB(4, 12), new ECB(4, 13))), new Version(10, new Array(6, 28, 50), new ECBlocks(18, new ECB(2, 68), new ECB(2, 69)), new ECBlocks(26, new ECB(4, 43), new ECB(1, 44)), new ECBlocks(24, new ECB(6, 19), new ECB(2, 20)), new ECBlocks(28, new ECB(6, 15), new ECB(2, 16))), new Version(11, new Array(6, 30, 54), new ECBlocks(20, new ECB(4, 81)), new ECBlocks(30, new ECB(1, 50), new ECB(4, 51)), new ECBlocks(28, new ECB(4, 22), new ECB(4, 23)), new ECBlocks(24, new ECB(3, 12), new ECB(8, 13))), new Version(12, new Array(6, 32, 58), new ECBlocks(24, new ECB(2, 92), new ECB(2, 93)), new ECBlocks(22, new ECB(6, 36), new ECB(2, 37)), new ECBlocks(26, new ECB(4, 20), new ECB(6, 21)), new ECBlocks(28, new ECB(7, 14), new ECB(4, 15))), new Version(13, new Array(6, 34, 62), new ECBlocks(26, new ECB(4, 107)), new ECBlocks(22, new ECB(8, 37), new ECB(1, 38)), new ECBlocks(24, new ECB(8, 20), new ECB(4, 21)), new ECBlocks(22, new ECB(12, 11), new ECB(4, 12))), new Version(14, new Array(6, 26, 46, 66), new ECBlocks(30, new ECB(3, 115), new ECB(1, 116)), new ECBlocks(24, new ECB(4, 40), new ECB(5, 41)), new ECBlocks(20, new ECB(11, 16), new ECB(5, 17)), new ECBlocks(24, new ECB(11, 12), new ECB(5, 13))), new Version(15, new Array(6, 26, 48, 70), new ECBlocks(22, new ECB(5, 87), new ECB(1, 88)), new ECBlocks(24, new ECB(5, 41), new ECB(5, 42)), new ECBlocks(30, new ECB(5, 24), new ECB(7, 25)), new ECBlocks(24, new ECB(11, 12), new ECB(7, 13))), new Version(16, new Array(6, 26, 50, 74), new ECBlocks(24, new ECB(5, 98), new ECB(1, 99)), new ECBlocks(28, new ECB(7, 45), new ECB(3, 46)), new ECBlocks(24, new ECB(15, 19), new ECB(2, 20)), new ECBlocks(30, new ECB(3, 15), new ECB(13, 16))), new Version(17, new Array(6, 30, 54, 78), new ECBlocks(28, new ECB(1, 107), new ECB(5, 108)), new ECBlocks(28, new ECB(10, 46), new ECB(1, 47)), new ECBlocks(28, new ECB(1, 22), new ECB(15, 23)), new ECBlocks(28, new ECB(2, 14), new ECB(17, 15))), new Version(18, new Array(6, 30, 56, 82), new ECBlocks(30, new ECB(5, 120), new ECB(1, 121)), new ECBlocks(26, new ECB(9, 43), new ECB(4, 44)), new ECBlocks(28, new ECB(17, 22), new ECB(1, 23)), new ECBlocks(28, new ECB(2, 14), new ECB(19, 15))), new Version(19, new Array(6, 30, 58, 86), new ECBlocks(28, new ECB(3, 113), new ECB(4, 114)), new ECBlocks(26, new ECB(3, 44), new ECB(11, 45)), new ECBlocks(26, new ECB(17, 21), new ECB(4, 22)), new ECBlocks(26, new ECB(9, 13), new ECB(16, 14))), new Version(20, new Array(6, 34, 62, 90), new ECBlocks(28, new ECB(3, 107), new ECB(5, 108)), new ECBlocks(26, new ECB(3, 41), new ECB(13, 42)), new ECBlocks(30, new ECB(15, 24), new ECB(5, 25)), new ECBlocks(28, new ECB(15, 15), new ECB(10, 16))), new Version(21, new Array(6, 28, 50, 72, 94), new ECBlocks(28, new ECB(4, 116), new ECB(4, 117)), new ECBlocks(26, new ECB(17, 42)), new ECBlocks(28, new ECB(17, 22), new ECB(6, 23)), new ECBlocks(30, new ECB(19, 16), new ECB(6, 17))), new Version(22, new Array(6, 26, 50, 74, 98), new ECBlocks(28, new ECB(2, 111), new ECB(7, 112)), new ECBlocks(28, new ECB(17, 46)), new ECBlocks(30, new ECB(7, 24), new ECB(16, 25)), new ECBlocks(24, new ECB(34, 13))), new Version(23, new Array(6, 30, 54, 74, 102), new ECBlocks(30, new ECB(4, 121), new ECB(5, 122)), new ECBlocks(28, new ECB(4, 47), new ECB(14, 48)), new ECBlocks(30, new ECB(11, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(16, 15), new ECB(14, 16))), new Version(24, new Array(6, 28, 54, 80, 106), new ECBlocks(30, new ECB(6, 117), new ECB(4, 118)), new ECBlocks(28, new ECB(6, 45), new ECB(14, 46)), new ECBlocks(30, new ECB(11, 24), new ECB(16, 25)), new ECBlocks(30, new ECB(30, 16), new ECB(2, 17))), new Version(25, new Array(6, 32, 58, 84, 110), new ECBlocks(26, new ECB(8, 106), new ECB(4, 107)), new ECBlocks(28, new ECB(8, 47), new ECB(13, 48)), new ECBlocks(30, new ECB(7, 24), new ECB(22, 25)), new ECBlocks(30, new ECB(22, 15), new ECB(13, 16))), new Version(26, new Array(6, 30, 58, 86, 114), new ECBlocks(28, new ECB(10, 114), new ECB(2, 115)), new ECBlocks(28, new ECB(19, 46), new ECB(4, 47)), new ECBlocks(28, new ECB(28, 22), new ECB(6, 23)), new ECBlocks(30, new ECB(33, 16), new ECB(4, 17))), new Version(27, new Array(6, 34, 62, 90, 118), new ECBlocks(30, new ECB(8, 122), new ECB(4, 123)), new ECBlocks(28, new ECB(22, 45), new ECB(3, 46)), new ECBlocks(30, new ECB(8, 23), new ECB(26, 24)), new ECBlocks(30, new ECB(12, 15), new ECB(28, 16))), new Version(28, new Array(6, 26, 50, 74, 98, 122), new ECBlocks(30, new ECB(3, 117), new ECB(10, 118)), new ECBlocks(28, new ECB(3, 45), new ECB(23, 46)), new ECBlocks(30, new ECB(4, 24), new ECB(31, 25)), new ECBlocks(30, new ECB(11, 15), new ECB(31, 16))), new Version(29, new Array(6, 30, 54, 78, 102, 126), new ECBlocks(30, new ECB(7, 116), new ECB(7, 117)), new ECBlocks(28, new ECB(21, 45), new ECB(7, 46)), new ECBlocks(30, new ECB(1, 23), new ECB(37, 24)), new ECBlocks(30, new ECB(19, 15), new ECB(26, 16))), new Version(30, new Array(6, 26, 52, 78, 104, 130), new ECBlocks(30, new ECB(5, 115), new ECB(10, 116)), new ECBlocks(28, new ECB(19, 47), new ECB(10, 48)), new ECBlocks(30, new ECB(15, 24), new ECB(25, 25)), new ECBlocks(30, new ECB(23, 15), new ECB(25, 16))), new Version(31, new Array(6, 30, 56, 82, 108, 134), new ECBlocks(30, new ECB(13, 115), new ECB(3, 116)), new ECBlocks(28, new ECB(2, 46), new ECB(29, 47)), new ECBlocks(30, new ECB(42, 24), new ECB(1, 25)), new ECBlocks(30, new ECB(23, 15), new ECB(28, 16))), new Version(32, new Array(6, 34, 60, 86, 112, 138), new ECBlocks(30, new ECB(17, 115)), new ECBlocks(28, new ECB(10, 46), new ECB(23, 47)), new ECBlocks(30, new ECB(10, 24), new ECB(35, 25)), new ECBlocks(30, new ECB(19, 15), new ECB(35, 16))), new Version(33, new Array(6, 30, 58, 86, 114, 142), new ECBlocks(30, new ECB(17, 115), new ECB(1, 116)), new ECBlocks(28, new ECB(14, 46), new ECB(21, 47)), new ECBlocks(30, new ECB(29, 24), new ECB(19, 25)), new ECBlocks(30, new ECB(11, 15), new ECB(46, 16))), new Version(34, new Array(6, 34, 62, 90, 118, 146), new ECBlocks(30, new ECB(13, 115), new ECB(6, 116)), new ECBlocks(28, new ECB(14, 46), new ECB(23, 47)), new ECBlocks(30, new ECB(44, 24), new ECB(7, 25)), new ECBlocks(30, new ECB(59, 16), new ECB(1, 17))), new Version(35, new Array(6, 30, 54, 78, 102, 126, 150), new ECBlocks(30, new ECB(12, 121), new ECB(7, 122)), new ECBlocks(28, new ECB(12, 47), new ECB(26, 48)), new ECBlocks(30, new ECB(39, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(22, 15), new ECB(41, 16))), new Version(36, new Array(6, 24, 50, 76, 102, 128, 154), new ECBlocks(30, new ECB(6, 121), new ECB(14, 122)), new ECBlocks(28, new ECB(6, 47), new ECB(34, 48)), new ECBlocks(30, new ECB(46, 24), new ECB(10, 25)), new ECBlocks(30, new ECB(2, 15), new ECB(64, 16))), new Version(37, new Array(6, 28, 54, 80, 106, 132, 158), new ECBlocks(30, new ECB(17, 122), new ECB(4, 123)), new ECBlocks(28, new ECB(29, 46), new ECB(14, 47)), new ECBlocks(30, new ECB(49, 24), new ECB(10, 25)), new ECBlocks(30, new ECB(24, 15), new ECB(46, 16))), new Version(38, new Array(6, 32, 58, 84, 110, 136, 162), new ECBlocks(30, new ECB(4, 122), new ECB(18, 123)), new ECBlocks(28, new ECB(13, 46), new ECB(32, 47)), new ECBlocks(30, new ECB(48, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(42, 15), new ECB(32, 16))), new Version(39, new Array(6, 26, 54, 82, 110, 138, 166), new ECBlocks(30, new ECB(20, 117), new ECB(4, 118)), new ECBlocks(28, new ECB(40, 47), new ECB(7, 48)), new ECBlocks(30, new ECB(43, 24), new ECB(22, 25)), new ECBlocks(30, new ECB(10, 15), new ECB(67, 16))), new Version(40, new Array(6, 30, 58, 86, 114, 142, 170), new ECBlocks(30, new ECB(19, 118), new ECB(6, 119)), new ECBlocks(28, new ECB(18, 47), new ECB(31, 48)), new ECBlocks(30, new ECB(34, 24), new ECB(34, 25)), new ECBlocks(30, new ECB(20, 15), new ECB(61, 16))));\n    }\n  }]);\n\n  return Version;\n}();\n\nVersion.VERSION_DECODE_INFO = new Array(0x07C94, 0x085BC, 0x09A99, 0x0A4D3, 0x0BBF6, 0x0C762, 0x0D847, 0x0E60D, 0x0F928, 0x10B78, 0x1145D, 0x12A17, 0x13532, 0x149A6, 0x15683, 0x168C9, 0x177EC, 0x18EC4, 0x191E1, 0x1AFAB, 0x1B08E, 0x1CC1A, 0x1D33F, 0x1ED75, 0x1F250, 0x209D5, 0x216F0, 0x228BA, 0x2379F, 0x24B0B, 0x2542E, 0x26A64, 0x27541, 0x28C69);\nVersion.VERSIONS = Version.buildVersions();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\nif (!Array.prototype.remove) {\n  Array.prototype.remove = function (from) {\n    var\n    /** @type {?} */\n    rest = this.slice(from + 1 || this.length);\n    this.length = from < 0 ? this.length + from : from;\n    return this.push.apply(this, rest);\n  };\n}\n\nvar FinderPattern = /*#__PURE__*/function () {\n  /**\n   * @param {?} posX\n   * @param {?} posY\n   * @param {?} estimatedModuleSize\n   */\n  function FinderPattern(posX, posY, estimatedModuleSize) {\n    _classCallCheck(this, FinderPattern);\n\n    this.incrementCount = function () {\n      this.count++;\n    };\n\n    this.aboutEquals = function (moduleSize, i, j) {\n      if (Math.abs(i - this.y) <= moduleSize && Math.abs(j - this.x) <= moduleSize) {\n        var\n        /** @type {?} */\n        moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n        return moduleSizeDiff <= 1.0 || moduleSizeDiff / this.estimatedModuleSize <= 1.0;\n      }\n\n      return false;\n    };\n\n    this.x = posX;\n    this.y = posY;\n    this.count = 1;\n    this.estimatedModuleSize = estimatedModuleSize;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(FinderPattern, [{\n    key: \"EstimatedModuleSize\",\n    get: function get() {\n      return this.estimatedModuleSize;\n    }\n  }, {\n    key: \"Count\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.count;\n    }\n  }, {\n    key: \"X\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.x;\n    }\n  }, {\n    key: \"Y\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.y;\n    }\n  }]);\n\n  return FinderPattern;\n}();\n\nFinderPattern.MIN_SKIP = 3;\nFinderPattern.MAX_MODULES = 57;\nFinderPattern.INTEGER_MATH_SHIFT = 8;\nFinderPattern.CENTER_QUORUM = 2;\n\nvar FinderPatternInfo = /*#__PURE__*/function () {\n  /**\n   * @param {?} patternCenters\n   */\n  function FinderPatternInfo(patternCenters) {\n    _classCallCheck(this, FinderPatternInfo);\n\n    this.bottomLeft = patternCenters[0];\n    this.topLeft = patternCenters[1];\n    this.topRight = patternCenters[2];\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(FinderPatternInfo, [{\n    key: \"BottomLeft\",\n    get: function get() {\n      return this.bottomLeft;\n    }\n  }, {\n    key: \"TopLeft\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.topLeft;\n    }\n  }, {\n    key: \"TopRight\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.topRight;\n    }\n  }]);\n\n  return FinderPatternInfo;\n}();\n\nvar FinderPatternFinder = /*#__PURE__*/function () {\n  /**\n   * @param {?} width\n   * @param {?} height\n   */\n  function FinderPatternFinder(width, height) {\n    _classCallCheck(this, FinderPatternFinder);\n\n    this.possibleCenters = new Array();\n    this.hasSkipped = false;\n    this.crossCheckStateCount = new Array(0, 0, 0, 0, 0);\n\n    this.orderBestPatterns = function (patterns) {\n      /**\n       * @param {?} pattern1\n       * @param {?} pattern2\n       * @return {?}\n       */\n      function distance(pattern1, pattern2) {\n        var\n        /** @type {?} */\n        xDiff = pattern1.X - pattern2.X;\n        var\n        /** @type {?} */\n        yDiff = pattern1.Y - pattern2.Y;\n        return Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n      }\n      /**\n       * @param {?} pointA\n       * @param {?} pointB\n       * @param {?} pointC\n       * @return {?}\n       */\n\n\n      function crossProductZ(pointA, pointB, pointC) {\n        var\n        /** @type {?} */\n        bX = pointB.x;\n        var\n        /** @type {?} */\n        bY = pointB.y;\n        return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);\n      } // Find distances between pattern centers\n\n\n      var\n      /** @type {?} */\n      zeroOneDistance = distance(patterns[0], patterns[1]);\n      var\n      /** @type {?} */\n      oneTwoDistance = distance(patterns[1], patterns[2]);\n      var\n      /** @type {?} */\n      zeroTwoDistance = distance(patterns[0], patterns[2]);\n      var\n      /** @type {?} */\n      pointA,\n      /** @type {?} */\n      pointB,\n      /** @type {?} */\n      pointC; // Assume one closest to other two is B; A and C will just be guesses at first\n\n      if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {\n        pointB = patterns[0];\n        pointA = patterns[1];\n        pointC = patterns[2];\n      } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {\n        pointB = patterns[1];\n        pointA = patterns[0];\n        pointC = patterns[2];\n      } else {\n        pointB = patterns[2];\n        pointA = patterns[0];\n        pointC = patterns[1];\n      } // Use cross product to figure out whether A and C are correct or flipped.\n      // This asks whether BC x BA has a positive z component, which is the arrangement\n      // we want for A, B, C. If it's negative, then we've got it flipped around and\n      // should swap A and C.\n\n\n      if (crossProductZ(pointA, pointB, pointC) < 0.0) {\n        var\n        /** @type {?} */\n        temp = pointA;\n        pointA = pointC;\n        pointC = temp;\n      }\n\n      patterns[0] = pointA;\n      patterns[1] = pointB;\n      patterns[2] = pointC;\n    };\n\n    this.foundPatternCross = function (stateCount) {\n      var\n      /** @type {?} */\n      totalModuleSize = 0;\n\n      for (var\n      /** @type {?} */\n      i = 0; i < 5; i++) {\n        var\n        /** @type {?} */\n        count = stateCount[i];\n\n        if (count == 0) {\n          return false;\n        }\n\n        totalModuleSize += count;\n      }\n\n      if (totalModuleSize < 7) {\n        return false;\n      }\n\n      var\n      /** @type {?} */\n      moduleSize = Math.floor((totalModuleSize << FinderPattern.INTEGER_MATH_SHIFT) / 7);\n      var\n      /** @type {?} */\n      maxVariance = Math.floor(moduleSize / 2); // Allow less than 50% variance from 1-1-3-1-1 proportions\n\n      return Math.abs(moduleSize - (stateCount[0] << FinderPattern.INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(moduleSize - (stateCount[1] << FinderPattern.INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(3 * moduleSize - (stateCount[2] << FinderPattern.INTEGER_MATH_SHIFT)) < 3 * maxVariance && Math.abs(moduleSize - (stateCount[3] << FinderPattern.INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(moduleSize - (stateCount[4] << FinderPattern.INTEGER_MATH_SHIFT)) < maxVariance;\n    };\n\n    this.centerFromEnd = function (stateCount, end) {\n      return end - stateCount[4] - stateCount[3] - stateCount[2] / 2.0;\n    };\n\n    this.crossCheckVertical = function (startI, centerJ, maxCount, originalStateCountTotal) {\n      var\n      /** @type {?} */\n      image = this.image;\n      var\n      /** @type {?} */\n      maxI = this.height;\n      var\n      /** @type {?} */\n      stateCount = this.CrossCheckStateCount; // Start counting up from center\n\n      var\n      /** @type {?} */\n      i = startI;\n\n      while (i >= 0 && image[centerJ + i * this.width]) {\n        stateCount[2]++;\n        i--;\n      }\n\n      if (i < 0) {\n        return NaN;\n      }\n\n      while (i >= 0 && !image[centerJ + i * this.width] && stateCount[1] <= maxCount) {\n        stateCount[1]++;\n        i--;\n      } // If already too many modules in this state or ran off the edge:\n\n\n      if (i < 0 || stateCount[1] > maxCount) {\n        return NaN;\n      }\n\n      while (i >= 0 && image[centerJ + i * this.width] && stateCount[0] <= maxCount) {\n        stateCount[0]++;\n        i--;\n      }\n\n      if (stateCount[0] > maxCount) {\n        return NaN;\n      } // Now also count down from center\n\n\n      i = startI + 1;\n\n      while (i < maxI && image[centerJ + i * this.width]) {\n        stateCount[2]++;\n        i++;\n      }\n\n      if (i == maxI) {\n        return NaN;\n      }\n\n      while (i < maxI && !image[centerJ + i * this.width] && stateCount[3] < maxCount) {\n        stateCount[3]++;\n        i++;\n      }\n\n      if (i == maxI || stateCount[3] >= maxCount) {\n        return NaN;\n      }\n\n      while (i < maxI && image[centerJ + i * this.width] && stateCount[4] < maxCount) {\n        stateCount[4]++;\n        i++;\n      }\n\n      if (stateCount[4] >= maxCount) {\n        return NaN;\n      } // If we found a finder-pattern-like section, but its size is more than 40% different than\n      // the original, assume it's a false positive\n\n\n      var\n      /** @type {?} */\n      stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n\n      if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n        return NaN;\n      }\n\n      return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, i) : NaN;\n    };\n\n    this.crossCheckHorizontal = function (startJ, centerI, maxCount, originalStateCountTotal) {\n      var\n      /** @type {?} */\n      image = this.image;\n      var\n      /** @type {?} */\n      maxJ = this.width;\n      var\n      /** @type {?} */\n      stateCount = this.CrossCheckStateCount;\n      var\n      /** @type {?} */\n      j = startJ;\n\n      while (j >= 0 && image[j + centerI * this.width]) {\n        stateCount[2]++;\n        j--;\n      }\n\n      if (j < 0) {\n        return NaN;\n      }\n\n      while (j >= 0 && !image[j + centerI * this.width] && stateCount[1] <= maxCount) {\n        stateCount[1]++;\n        j--;\n      }\n\n      if (j < 0 || stateCount[1] > maxCount) {\n        return NaN;\n      }\n\n      while (j >= 0 && image[j + centerI * this.width] && stateCount[0] <= maxCount) {\n        stateCount[0]++;\n        j--;\n      }\n\n      if (stateCount[0] > maxCount) {\n        return NaN;\n      }\n\n      j = startJ + 1;\n\n      while (j < maxJ && image[j + centerI * this.width]) {\n        stateCount[2]++;\n        j++;\n      }\n\n      if (j == maxJ) {\n        return NaN;\n      }\n\n      while (j < maxJ && !image[j + centerI * this.width] && stateCount[3] < maxCount) {\n        stateCount[3]++;\n        j++;\n      }\n\n      if (j == maxJ || stateCount[3] >= maxCount) {\n        return NaN;\n      }\n\n      while (j < maxJ && image[j + centerI * this.width] && stateCount[4] < maxCount) {\n        stateCount[4]++;\n        j++;\n      }\n\n      if (stateCount[4] >= maxCount) {\n        return NaN;\n      } // If we found a finder-pattern-like section, but its size is significantly different than\n      // the original, assume it's a false positive\n\n\n      var\n      /** @type {?} */\n      stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n\n      if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {\n        return NaN;\n      }\n\n      return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, j) : NaN;\n    };\n\n    this.handlePossibleCenter = function (stateCount, i, j) {\n      var\n      /** @type {?} */\n      stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n      var\n      /** @type {?} */\n      centerJ = this.centerFromEnd(stateCount, j); //float\n\n      var\n      /** @type {?} */\n      centerI = this.crossCheckVertical(i, Math.floor(centerJ), stateCount[2], stateCountTotal); //float\n\n      if (!isNaN(centerI)) {\n        // Re-cross check\n        centerJ = this.crossCheckHorizontal(Math.floor(centerJ), Math.floor(centerI), stateCount[2], stateCountTotal);\n\n        if (!isNaN(centerJ)) {\n          var\n          /** @type {?} */\n          estimatedModuleSize = stateCountTotal / 7.0;\n          var\n          /** @type {?} */\n          found = false;\n          var\n          /** @type {?} */\n          max = this.possibleCenters.length;\n\n          for (var\n          /** @type {?} */\n          index = 0; index < max; index++) {\n            var\n            /** @type {?} */\n            center = this.possibleCenters[index]; // Look for about the same center and module size:\n\n            if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n              center.incrementCount();\n              found = true;\n              break;\n            }\n          }\n\n          if (!found) {\n            var\n            /** @type {?} */\n            point = new FinderPattern(centerJ, centerI, estimatedModuleSize);\n            this.possibleCenters.push(point);\n\n            if (this.resultPointCallback != null) {\n              this.resultPointCallback.foundPossibleResultPoint(point);\n            }\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    this.selectBestPatterns = function () {\n      var\n      /** @type {?} */\n      startSize = this.possibleCenters.length;\n\n      if (startSize < 3) {\n        // Couldn't find enough finder patterns\n        throw \"Couldn't find enough finder patterns (found: \".concat(startSize, \")\");\n      } // Filter outlier possibilities whose module size is too different\n\n\n      if (startSize > 3) {\n        // But we can only afford to do so if we have at least 4 possibilities to choose from\n        var\n        /** @type {?} */\n        totalModuleSize = 0.0;\n        var\n        /** @type {?} */\n        square = 0.0;\n\n        for (var\n        /** @type {?} */\n        i = 0; i < startSize; i++) {\n          //totalModuleSize +=  this.possibleCenters[i].EstimatedModuleSize;\n          var\n          /** @type {?} */\n          centerValue = this.possibleCenters[i].EstimatedModuleSize;\n          totalModuleSize += centerValue;\n          square += centerValue * centerValue;\n        }\n\n        var\n        /** @type {?} */\n        average = totalModuleSize / startSize;\n        this.possibleCenters.sort(function (center1, center2) {\n          var\n          /** @type {?} */\n          dA = Math.abs(center2.EstimatedModuleSize - average);\n          var\n          /** @type {?} */\n          dB = Math.abs(center1.EstimatedModuleSize - average);\n\n          if (dA < dB) {\n            return -1;\n          } else if (dA == dB) {\n            return 0;\n          } else {\n            return 1;\n          }\n        });\n        var\n        /** @type {?} */\n        stdDev = Math.sqrt(square / startSize - average * average);\n        var\n        /** @type {?} */\n        limit = Math.max(0.2 * average, stdDev);\n\n        for (var\n        /** @type {?} */\n        i = this.possibleCenters.length - 1; i >= 0; i--) {\n          var\n          /** @type {?} */\n          pattern = this.possibleCenters[i]; //if (Math.abs(pattern.EstimatedModuleSize - average) > 0.2 * average)\n\n          if (Math.abs(pattern.EstimatedModuleSize - average) > limit) {\n            this.possibleCenters.remove(i);\n          }\n        }\n      }\n\n      if (this.possibleCenters.length > 3) {\n        // Throw away all but those first size candidate points we found.\n        this.possibleCenters.sort(function (a, b) {\n          if (a.count > b.count) {\n            return -1;\n          }\n\n          if (a.count < b.count) {\n            return 1;\n          }\n\n          return 0;\n        });\n      }\n\n      return new Array(this.possibleCenters[0], this.possibleCenters[1], this.possibleCenters[2]);\n    };\n\n    this.findRowSkip = function () {\n      var\n      /** @type {?} */\n      max = this.possibleCenters.length;\n\n      if (max <= 1) {\n        return 0;\n      }\n\n      var\n      /** @type {?} */\n      firstConfirmedCenter = null;\n\n      for (var\n      /** @type {?} */\n      i = 0; i < max; i++) {\n        var\n        /** @type {?} */\n        center = this.possibleCenters[i];\n\n        if (center.Count >= FinderPattern.CENTER_QUORUM) {\n          if (firstConfirmedCenter == null) {\n            firstConfirmedCenter = center;\n          } else {\n            // We have two confirmed centers\n            // How far down can we skip before resuming looking for the next\n            // pattern? In the worst case, only the difference between the\n            // difference in the x / y coordinates of the two centers.\n            // This is the case where you find top left last.\n            this.hasSkipped = true;\n            return Math.floor((Math.abs(firstConfirmedCenter.X - center.X) - Math.abs(firstConfirmedCenter.Y - center.Y)) / 2);\n          }\n        }\n      }\n\n      return 0;\n    };\n\n    this.haveMultiplyConfirmedCenters = function () {\n      var\n      /** @type {?} */\n      confirmedCount = 0;\n      var\n      /** @type {?} */\n      totalModuleSize = 0.0;\n      var\n      /** @type {?} */\n      max = this.possibleCenters.length;\n\n      for (var\n      /** @type {?} */\n      i = 0; i < max; i++) {\n        var\n        /** @type {?} */\n        pattern = this.possibleCenters[i];\n\n        if (pattern.Count >= FinderPattern.CENTER_QUORUM) {\n          confirmedCount++;\n          totalModuleSize += pattern.EstimatedModuleSize;\n        }\n      }\n\n      if (confirmedCount < 3) {\n        return false;\n      } // OK, we have at least 3 confirmed centers, but, it's possible that one is a \"false positive\"\n      // and that we need to keep looking. We detect this by asking if the estimated module sizes\n      // vary too much. We arbitrarily say that when the total deviation from average exceeds\n      // 5% of the total module size estimates, it's too much.\n\n\n      var\n      /** @type {?} */\n      average = totalModuleSize / max;\n      var\n      /** @type {?} */\n      totalDeviation = 0.0;\n\n      for (var\n      /** @type {?} */\n      i = 0; i < max; i++) {\n        pattern = this.possibleCenters[i];\n        totalDeviation += Math.abs(pattern.EstimatedModuleSize - average);\n      }\n\n      return totalDeviation <= 0.05 * totalModuleSize;\n    };\n\n    this.findFinderPattern = function (image) {\n      var\n      /** @type {?} */\n      tryHarder = false;\n      this.image = image;\n      var\n      /** @type {?} */\n      maxI = this.height;\n      var\n      /** @type {?} */\n      maxJ = this.width;\n      var\n      /** @type {?} */\n      iSkip = Math.floor(3 * maxI / (4 * FinderPattern.MAX_MODULES));\n\n      if (iSkip < FinderPattern.MIN_SKIP || tryHarder) {\n        iSkip = FinderPattern.MIN_SKIP;\n      }\n\n      var\n      /** @type {?} */\n      done = false;\n      var\n      /** @type {?} */\n      stateCount = new Array(5);\n\n      for (var\n      /** @type {?} */\n      i = iSkip - 1; i < maxI && !done; i += iSkip) {\n        // Get a row of black/white values\n        stateCount[0] = 0;\n        stateCount[1] = 0;\n        stateCount[2] = 0;\n        stateCount[3] = 0;\n        stateCount[4] = 0;\n        var\n        /** @type {?} */\n        currentState = 0;\n\n        for (var\n        /** @type {?} */\n        j = 0; j < maxJ; j++) {\n          if (image[j + i * this.width]) {\n            // Black pixel\n            if ((currentState & 1) == 1) {\n              // Counting white pixels\n              currentState++;\n            }\n\n            stateCount[currentState]++;\n          } else {\n            // White pixel\n            if ((currentState & 1) == 0) {\n              // Counting black pixels\n              if (currentState == 4) {\n                // A winner?\n                if (this.foundPatternCross(stateCount)) {\n                  // Yes\n                  var\n                  /** @type {?} */\n                  confirmed = this.handlePossibleCenter(stateCount, i, j);\n\n                  if (confirmed) {\n                    // Start examining every other line. Checking each line turned out to be too\n                    // expensive and didn't improve performance.\n                    iSkip = 2;\n\n                    if (this.hasSkipped) {\n                      done = this.haveMultiplyConfirmedCenters();\n                    } else {\n                      var\n                      /** @type {?} */\n                      rowSkip = this.findRowSkip();\n\n                      if (rowSkip > stateCount[2]) {\n                        // Skip rows between row of lower confirmed center\n                        // and top of presumed third confirmed center\n                        // but back up a bit to get a full chance of detecting\n                        // it, entire width of center of finder pattern\n                        // Skip by rowSkip, but back off by stateCount[2] (size of last center\n                        // of pattern we saw) to be conservative, and also back off by iSkip which\n                        // is about to be re-added\n                        i += rowSkip - stateCount[2] - iSkip;\n                        j = maxJ - 1;\n                      }\n                    }\n                  } else {\n                    // Advance to next black pixel\n                    do {\n                      j++;\n                    } while (j < maxJ && !image[j + i * this.width]);\n\n                    j--; // back up to that last white pixel\n                  } // Clear state to start looking again\n\n\n                  currentState = 0;\n                  stateCount[0] = 0;\n                  stateCount[1] = 0;\n                  stateCount[2] = 0;\n                  stateCount[3] = 0;\n                  stateCount[4] = 0;\n                } else {\n                  // No, shift counts back by two\n                  stateCount[0] = stateCount[2];\n                  stateCount[1] = stateCount[3];\n                  stateCount[2] = stateCount[4];\n                  stateCount[3] = 1;\n                  stateCount[4] = 0;\n                  currentState = 3;\n                }\n              } else {\n                stateCount[++currentState]++;\n              }\n            } else {\n              // Counting white pixels\n              stateCount[currentState]++;\n            }\n          }\n        }\n\n        if (this.foundPatternCross(stateCount)) {\n          var\n          /** @type {?} */\n          confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\n\n          if (confirmed) {\n            iSkip = stateCount[0];\n\n            if (this.hasSkipped) {\n              // Found a third one\n              done = this.haveMultiplyConfirmedCenters();\n            }\n          }\n        }\n      }\n\n      var\n      /** @type {?} */\n      patternInfo = this.selectBestPatterns();\n      this.orderBestPatterns(patternInfo);\n      return new FinderPatternInfo(patternInfo);\n    };\n\n    this.width = width;\n    this.height = height;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(FinderPatternFinder, [{\n    key: \"CrossCheckStateCount\",\n    get: function get() {\n      this.crossCheckStateCount[0] = 0;\n      this.crossCheckStateCount[1] = 0;\n      this.crossCheckStateCount[2] = 0;\n      this.crossCheckStateCount[3] = 0;\n      this.crossCheckStateCount[4] = 0;\n      return this.crossCheckStateCount;\n    }\n  }]);\n\n  return FinderPatternFinder;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\n\nvar DetectorResult =\n/**\n * @param {?} bits\n * @param {?} points\n */\nfunction DetectorResult(bits, points) {\n  _classCallCheck(this, DetectorResult);\n\n  this.bits = bits;\n  this.points = points;\n};\n\nvar Detector = /*#__PURE__*/function () {\n  /**\n   * @param {?} image\n   * @param {?} rawImage\n   * @param {?} width\n   * @param {?} height\n   */\n  function Detector(image, rawImage, width, height) {\n    _classCallCheck(this, Detector);\n\n    this.calculateModuleSizeOneWay = function (pattern, otherPattern) {\n      var\n      /** @type {?} */\n      moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(pattern.X), Math.floor(pattern.Y), Math.floor(otherPattern.X), Math.floor(otherPattern.Y));\n      var\n      /** @type {?} */\n      moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(otherPattern.X), Math.floor(otherPattern.Y), Math.floor(pattern.X), Math.floor(pattern.Y));\n\n      if (isNaN(moduleSizeEst1)) {\n        return moduleSizeEst2 / 7.0;\n      }\n\n      if (isNaN(moduleSizeEst2)) {\n        return moduleSizeEst1 / 7.0;\n      } // Average them, and divide by 7 since we've counted the width of 3 black modules,\n      // and 1 white and 1 black module on either side. Ergo, divide sum by 14.\n\n\n      return (moduleSizeEst1 + moduleSizeEst2) / 14.0;\n    };\n\n    this.calculateModuleSize = function (topLeft, topRight, bottomLeft) {\n      // Take the average\n      return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;\n    };\n\n    this.distance = function (pattern1, pattern2) {\n      var\n      /** @type {?} */\n      xDiff = pattern1.X - pattern2.X;\n      var\n      /** @type {?} */\n      yDiff = pattern1.Y - pattern2.Y;\n      return Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n    };\n\n    this.computeDimension = function (topLeft, topRight, bottomLeft, moduleSize) {\n      var\n      /** @type {?} */\n      tltrCentersDimension = Math.round(this.distance(topLeft, topRight) / moduleSize);\n      var\n      /** @type {?} */\n      tlblCentersDimension = Math.round(this.distance(topLeft, bottomLeft) / moduleSize);\n      var\n      /** @type {?} */\n      dimension = (tltrCentersDimension + tlblCentersDimension >> 1) + 7;\n\n      switch (dimension & 0x03) {\n        // mod 4\n        case 0:\n          dimension++;\n          break;\n        // 1? do nothing\n\n        case 2:\n          dimension--;\n          break;\n\n        case 3:\n          throw \"Error\";\n      }\n\n      return dimension;\n    };\n\n    this.findAlignmentInRegion = function (overallEstModuleSize, estAlignmentX, estAlignmentY, allowanceFactor) {\n      // Look for an alignment pattern (3 modules in size) around where it\n      // should be\n      var\n      /** @type {?} */\n      allowance = Math.floor(allowanceFactor * overallEstModuleSize);\n      var\n      /** @type {?} */\n      alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);\n      var\n      /** @type {?} */\n      alignmentAreaRightX = Math.min(this.width - 1, estAlignmentX + allowance);\n\n      if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {\n        throw \"Error\";\n      }\n\n      var\n      /** @type {?} */\n      alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);\n      var\n      /** @type {?} */\n      alignmentAreaBottomY = Math.min(this.height - 1, estAlignmentY + allowance);\n      var\n      /** @type {?} */\n      alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.width, this.height, this.resultPointCallback);\n      return alignmentFinder.find();\n    };\n\n    this.createTransform = function (topLeft, topRight, bottomLeft, alignmentPattern, dimension) {\n      var\n      /** @type {?} */\n      dimMinusThree = dimension - 3.5;\n      var\n      /** @type {?} */\n      bottomRightX;\n      var\n      /** @type {?} */\n      bottomRightY;\n      var\n      /** @type {?} */\n      sourceBottomRightX;\n      var\n      /** @type {?} */\n      sourceBottomRightY;\n\n      if (alignmentPattern != null) {\n        bottomRightX = alignmentPattern.X;\n        bottomRightY = alignmentPattern.Y;\n        sourceBottomRightX = sourceBottomRightY = dimMinusThree - 3.0;\n      } else {\n        // Don't have an alignment pattern, just make up the bottom-right point\n        bottomRightX = topRight.X - topLeft.X + bottomLeft.X;\n        bottomRightY = topRight.Y - topLeft.Y + bottomLeft.Y;\n        sourceBottomRightX = sourceBottomRightY = dimMinusThree;\n      }\n\n      var\n      /** @type {?} */\n      transform = PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.X, topLeft.Y, topRight.X, topRight.Y, bottomRightX, bottomRightY, bottomLeft.X, bottomLeft.Y);\n      return transform;\n    };\n\n    this.sampleGrid = function (image, transform, dimension) {\n      var\n      /** @type {?} */\n      sampler = new GridSampler(this.width, this.height);\n      return sampler.sampleGrid3(image, this.rawImage, dimension, transform);\n    };\n\n    this.detect = function () {\n      var\n      /** @type {?} */\n      info = new FinderPatternFinder(this.width, this.height).findFinderPattern(this.image);\n      return this.processFinderPatternInfo(info);\n    };\n\n    this.image = image;\n    this.rawImage = rawImage;\n    this.height = height;\n    this.width = width;\n  }\n  /**\n   * @param {?} fromX\n   * @param {?} fromY\n   * @param {?} toX\n   * @param {?} toY\n   * @return {?}\n   */\n\n\n  _createClass(Detector, [{\n    key: \"sizeOfBlackWhiteBlackRun\",\n    value: function sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY) {\n      // Mild variant of Bresenham's algorithm;\n      // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm\n      var\n      /** @type {?} */\n      steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n\n      if (steep) {\n        var\n        /** @type {?} */\n        temp = fromX;\n        fromX = fromY;\n        fromY = temp;\n        temp = toX;\n        toX = toY;\n        toY = temp;\n      }\n\n      var\n      /** @type {?} */\n      dx = Math.abs(toX - fromX);\n      var\n      /** @type {?} */\n      dy = Math.abs(toY - fromY);\n      var\n      /** @type {?} */\n      error = -dx >> 1;\n      var\n      /** @type {?} */\n      ystep = fromY < toY ? 1 : -1;\n      var\n      /** @type {?} */\n      xstep = fromX < toX ? 1 : -1;\n      var\n      /** @type {?} */\n      state = 0; // In black pixels, looking for white, first or second time\n\n      for (var\n      /** @type {?} */\n      x = fromX,\n      /** @type {?} */\n      y = fromY; x != toX; x += xstep) {\n        var\n        /** @type {?} */\n        realX = steep ? y : x;\n        var\n        /** @type {?} */\n        realY = steep ? x : y;\n\n        if (state == 1) {\n          // In white pixels, looking for black\n          if (this.image[realX + realY * this.width]) {\n            state++;\n          }\n        } else {\n          if (!this.image[realX + realY * this.width]) {\n            state++;\n          }\n        }\n\n        if (state == 3) {\n          // Found black, white, black, and stumbled back onto white; done\n          var\n          /** @type {?} */\n          diffX = x - fromX;\n          var\n          /** @type {?} */\n          diffY = y - fromY;\n          return Math.sqrt(diffX * diffX + diffY * diffY);\n        }\n\n        error += dy;\n\n        if (error > 0) {\n          if (y == toY) {\n            break;\n          }\n\n          y += ystep;\n          error -= dx;\n        }\n      }\n\n      var\n      /** @type {?} */\n      diffX2 = toX - fromX;\n      var\n      /** @type {?} */\n      diffY2 = toY - fromY;\n      return Math.sqrt(diffX2 * diffX2 + diffY2 * diffY2);\n    }\n    /**\n     * @param {?} fromX\n     * @param {?} fromY\n     * @param {?} toX\n     * @param {?} toY\n     * @return {?}\n     */\n\n  }, {\n    key: \"sizeOfBlackWhiteBlackRunBothWays\",\n    value: function sizeOfBlackWhiteBlackRunBothWays(fromX, fromY, toX, toY) {\n      var\n      /** @type {?} */\n      result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY); // Now count other way -- don't run off image though of course\n\n      var\n      /** @type {?} */\n      scale = 1.0;\n      var\n      /** @type {?} */\n      otherToX = fromX - (toX - fromX);\n\n      if (otherToX < 0) {\n        scale = fromX / (fromX - otherToX);\n        otherToX = 0;\n      } else if (otherToX >= this.width) {\n        scale = (this.width - 1 - fromX) / (otherToX - fromX);\n        otherToX = this.width - 1;\n      }\n\n      var\n      /** @type {?} */\n      otherToY = Math.floor(fromY - (toY - fromY) * scale);\n      scale = 1.0;\n\n      if (otherToY < 0) {\n        scale = fromY / (fromY - otherToY);\n        otherToY = 0;\n      } else if (otherToY >= this.height) {\n        scale = (this.height - 1 - fromY) / (otherToY - fromY);\n        otherToY = this.height - 1;\n      }\n\n      otherToX = Math.floor(fromX + (otherToX - fromX) * scale);\n      result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);\n      return result - 1.0; // -1 because we counted the middle pixel twice\n    }\n    /**\n     * @param {?} info\n     * @return {?}\n     */\n\n  }, {\n    key: \"processFinderPatternInfo\",\n    value: function processFinderPatternInfo(info) {\n      var\n      /** @type {?} */\n      topLeft = info.TopLeft;\n      var\n      /** @type {?} */\n      topRight = info.TopRight;\n      var\n      /** @type {?} */\n      bottomLeft = info.BottomLeft;\n      var\n      /** @type {?} */\n      moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);\n\n      if (moduleSize < 1.0) {\n        throw \"Error\";\n      }\n\n      var\n      /** @type {?} */\n      dimension = this.computeDimension(topLeft, topRight, bottomLeft, moduleSize);\n      var\n      /** @type {?} */\n      provisionalVersion = Version.getProvisionalVersionForDimension(dimension);\n      var\n      /** @type {?} */\n      modulesBetweenFPCenters = provisionalVersion.DimensionForVersion - 7;\n      var\n      /** @type {?} */\n      alignmentPattern = null; // Anything above version 1 has an alignment pattern\n\n      if (provisionalVersion.AlignmentPatternCenters.length > 0) {\n        // Guess where a \"bottom right\" finder pattern would have been\n        var\n        /** @type {?} */\n        bottomRightX = topRight.X - topLeft.X + bottomLeft.X;\n        var\n        /** @type {?} */\n        bottomRightY = topRight.Y - topLeft.Y + bottomLeft.Y; // Estimate that alignment pattern is closer by 3 modules\n        // from \"bottom right\" to known top left location\n\n        var\n        /** @type {?} */\n        correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;\n        var\n        /** @type {?} */\n        estAlignmentX = Math.floor(topLeft.X + correctionToTopLeft * (bottomRightX - topLeft.X));\n        var\n        /** @type {?} */\n        estAlignmentY = Math.floor(topLeft.Y + correctionToTopLeft * (bottomRightY - topLeft.Y)); // Kind of arbitrary -- expand search radius before giving up\n\n        for (var\n        /** @type {?} */\n        i = 4; i <= 16; i <<= 1) {\n          //try\n          //{\n          alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);\n          break; //}\n          //catch (re)\n          //{\n          // try next round\n          //}\n        } // If we didn't find alignment pattern... well try anyway without it\n\n      }\n\n      var\n      /** @type {?} */\n      transform = this.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);\n      var\n      /** @type {?} */\n      bits = this.sampleGrid(this.image, transform, dimension);\n      var\n      /** @type {?} */\n      points;\n\n      if (alignmentPattern == null) {\n        points = new Array(bottomLeft, topLeft, topRight);\n      } else {\n        points = new Array(bottomLeft, topLeft, topRight, alignmentPattern);\n      }\n\n      return new DetectorResult(bits, points);\n    }\n  }]);\n\n  return Detector;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n\nvar GF256Poly = /*#__PURE__*/function () {\n  /**\n   * @param {?} field\n   * @param {?} coefficients\n   */\n  function GF256Poly(field, coefficients) {\n    _classCallCheck(this, GF256Poly);\n\n    this.divide = function (other) {\n      if (this.field != other.field) {\n        throw \"GF256Polys do not have same GF256 field\";\n      }\n\n      if (other.Zero) {\n        throw \"Divide by 0\";\n      }\n\n      var\n      /** @type {?} */\n      quotient = this.field.Zero;\n      var\n      /** @type {?} */\n      remainder = this;\n      var\n      /** @type {?} */\n      denominatorLeadingTerm = other.getCoefficient(other.Degree);\n      var\n      /** @type {?} */\n      inverseDenominatorLeadingTerm = this.field.inverse(denominatorLeadingTerm);\n\n      while (remainder.Degree >= other.Degree && !remainder.Zero) {\n        var\n        /** @type {?} */\n        degreeDifference = remainder.Degree - other.Degree;\n        var\n        /** @type {?} */\n        scale = this.field.multiply(remainder.getCoefficient(remainder.Degree), inverseDenominatorLeadingTerm);\n        var\n        /** @type {?} */\n        term = other.multiplyByMonomial(degreeDifference, scale);\n        var\n        /** @type {?} */\n        iterationQuotient = this.field.buildMonomial(degreeDifference, scale);\n        quotient = quotient.addOrSubtract(iterationQuotient);\n        remainder = remainder.addOrSubtract(term);\n      }\n\n      return new Array(quotient, remainder);\n    };\n\n    if (coefficients == null || coefficients.length == 0) {\n      throw \"System.ArgumentException\";\n    }\n\n    this.field = field;\n    var\n    /** @type {?} */\n    coefficientsLength = coefficients.length;\n\n    if (coefficientsLength > 1 && coefficients[0] == 0) {\n      // Leading term must be non-zero for anything except the constant polynomial \"0\"\n      var\n      /** @type {?} */\n      firstNonZero = 1;\n\n      while (firstNonZero < coefficientsLength && coefficients[firstNonZero] == 0) {\n        firstNonZero++;\n      }\n\n      if (firstNonZero == coefficientsLength) {\n        this.coefficients = field.Zero.coefficients;\n      } else {\n        this.coefficients = new Array(coefficientsLength - firstNonZero);\n\n        for (var\n        /** @type {?} */\n        i = 0; i < this.coefficients.length; i++) {\n          this.coefficients[i] = 0;\n        } //Array.Copy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);\n\n\n        for (var\n        /** @type {?} */\n        ci = 0; ci < this.coefficients.length; ci++) {\n          this.coefficients[ci] = coefficients[firstNonZero + ci];\n        }\n      }\n    } else {\n      this.coefficients = coefficients;\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(GF256Poly, [{\n    key: \"Zero\",\n    get: function get() {\n      return this.coefficients[0] == 0;\n    }\n  }, {\n    key: \"Degree\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.coefficients.length - 1;\n    }\n  }, {\n    key: \"Coefficients\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.coefficients;\n    }\n  }, {\n    key: \"getCoefficient\",\n    value:\n    /**\n     * @param {?} degree\n     * @return {?}\n     */\n    function getCoefficient(degree) {\n      return this.coefficients[this.coefficients.length - 1 - degree];\n    }\n    /**\n     * @param {?} a\n     * @return {?}\n     */\n\n  }, {\n    key: \"evaluateAt\",\n    value: function evaluateAt(a) {\n      if (a == 0) {\n        // Just return the x^0 coefficient\n        return this.getCoefficient(0);\n      }\n\n      var\n      /** @type {?} */\n      size = this.coefficients.length;\n\n      if (a == 1) {\n        // Just the sum of the coefficients\n        var\n        /** @type {?} */\n        result = 0;\n\n        for (var\n        /** @type {?} */\n        i = 0; i < size; i++) {\n          result = GF256.addOrSubtract(result, this.coefficients[i]);\n        }\n\n        return result;\n      }\n\n      var\n      /** @type {?} */\n      result2 = this.coefficients[0];\n\n      for (var\n      /** @type {?} */\n      i = 1; i < size; i++) {\n        result2 = GF256.addOrSubtract(this.field.multiply(a, result2), this.coefficients[i]);\n      }\n\n      return result2;\n    }\n    /**\n     * @param {?} other\n     * @return {?}\n     */\n\n  }, {\n    key: \"addOrSubtract\",\n    value: function addOrSubtract(other) {\n      if (this.field != other.field) {\n        throw \"GF256Polys do not have same GF256 field\";\n      }\n\n      if (this.Zero) {\n        return other;\n      }\n\n      if (other.Zero) {\n        return this;\n      }\n\n      var\n      /** @type {?} */\n      smallerCoefficients = this.coefficients;\n      var\n      /** @type {?} */\n      largerCoefficients = other.coefficients;\n\n      if (smallerCoefficients.length > largerCoefficients.length) {\n        var\n        /** @type {?} */\n        temp = smallerCoefficients;\n        smallerCoefficients = largerCoefficients;\n        largerCoefficients = temp;\n      }\n\n      var\n      /** @type {?} */\n      sumDiff = new Array(largerCoefficients.length);\n      var\n      /** @type {?} */\n      lengthDiff = largerCoefficients.length - smallerCoefficients.length; // Copy high-order terms only found in higher-degree polynomial's coefficients\n      //Array.Copy(largerCoefficients, 0, sumDiff, 0, lengthDiff);\n\n      for (var\n      /** @type {?} */\n      ci = 0; ci < lengthDiff; ci++) {\n        sumDiff[ci] = largerCoefficients[ci];\n      }\n\n      for (var\n      /** @type {?} */\n      i = lengthDiff; i < largerCoefficients.length; i++) {\n        sumDiff[i] = GF256.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);\n      }\n\n      return new GF256Poly(this.field, sumDiff);\n    }\n    /**\n     * @param {?} other\n     * @return {?}\n     */\n\n  }, {\n    key: \"multiply1\",\n    value: function multiply1(other) {\n      if (this.field != other.field) {\n        throw \"GF256Polys do not have same GF256 field\";\n      }\n\n      if (this.Zero || other.Zero) {\n        return this.field.Zero;\n      }\n\n      var\n      /** @type {?} */\n      aCoefficients = this.coefficients;\n      var\n      /** @type {?} */\n      aLength = aCoefficients.length;\n      var\n      /** @type {?} */\n      bCoefficients = other.coefficients;\n      var\n      /** @type {?} */\n      bLength = bCoefficients.length;\n      var\n      /** @type {?} */\n      product = new Array(aLength + bLength - 1);\n\n      for (var\n      /** @type {?} */\n      i = 0; i < aLength; i++) {\n        var\n        /** @type {?} */\n        aCoeff = aCoefficients[i];\n\n        for (var\n        /** @type {?} */\n        j = 0; j < bLength; j++) {\n          product[i + j] = GF256.addOrSubtract(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));\n        }\n      }\n\n      return new GF256Poly(this.field, product);\n    }\n    /**\n     * @param {?} scalar\n     * @return {?}\n     */\n\n  }, {\n    key: \"multiply2\",\n    value: function multiply2(scalar) {\n      if (scalar == 0) {\n        return this.field.Zero;\n      }\n\n      if (scalar == 1) {\n        return this;\n      }\n\n      var\n      /** @type {?} */\n      size = this.coefficients.length;\n      var\n      /** @type {?} */\n      product = new Array(size);\n\n      for (var\n      /** @type {?} */\n      i = 0; i < size; i++) {\n        product[i] = this.field.multiply(this.coefficients[i], scalar);\n      }\n\n      return new GF256Poly(this.field, product);\n    }\n    /**\n     * @param {?} degree\n     * @param {?} coefficient\n     * @return {?}\n     */\n\n  }, {\n    key: \"multiplyByMonomial\",\n    value: function multiplyByMonomial(degree, coefficient) {\n      if (degree < 0) {\n        throw \"System.ArgumentException\";\n      }\n\n      if (coefficient == 0) {\n        return this.field.Zero;\n      }\n\n      var\n      /** @type {?} */\n      size = this.coefficients.length;\n      var\n      /** @type {?} */\n      product = new Array(size + degree);\n\n      for (var\n      /** @type {?} */\n      i = 0; i < product.length; i++) {\n        product[i] = 0;\n      }\n\n      for (var\n      /** @type {?} */\n      i = 0; i < size; i++) {\n        product[i] = this.field.multiply(this.coefficients[i], coefficient);\n      }\n\n      return new GF256Poly(this.field, product);\n    }\n  }]);\n\n  return GF256Poly;\n}();\n\nvar GF256 = /*#__PURE__*/function () {\n  /**\n   * @param {?} primitive\n   */\n  function GF256(primitive) {\n    _classCallCheck(this, GF256);\n\n    this.expTable = new Array(256);\n    this.logTable = new Array(256);\n    var\n    /** @type {?} */\n    x = 1;\n\n    for (var\n    /** @type {?} */\n    i = 0; i < 256; i++) {\n      this.expTable[i] = x;\n      x <<= 1; // x = x * 2; we're assuming the generator alpha is 2\n\n      if (x >= 0x100) {\n        x ^= primitive;\n      }\n    }\n\n    for (var\n    /** @type {?} */\n    i = 0; i < 255; i++) {\n      this.logTable[this.expTable[i]] = i;\n    } // logTable[0] == 0 but this should never be used\n\n\n    var\n    /** @type {?} */\n    at0 = new Array(1);\n    at0[0] = 0;\n    this.zero = new GF256Poly(this, new Array(at0));\n    var\n    /** @type {?} */\n    at1 = new Array(1);\n    at1[0] = 1;\n    this.one = new GF256Poly(this, new Array(at1));\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(GF256, [{\n    key: \"Zero\",\n    get: function get() {\n      return this.zero;\n    }\n  }, {\n    key: \"One\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.one;\n    }\n  }, {\n    key: \"buildMonomial\",\n    value:\n    /**\n     * @param {?} degree\n     * @param {?} coefficient\n     * @return {?}\n     */\n    function buildMonomial(degree, coefficient) {\n      if (degree < 0) {\n        throw \"System.ArgumentException\";\n      }\n\n      if (coefficient == 0) {\n        return this.zero;\n      }\n\n      var\n      /** @type {?} */\n      coefficients = new Array(degree + 1);\n\n      for (var\n      /** @type {?} */\n      i = 0; i < coefficients.length; i++) {\n        coefficients[i] = 0;\n      }\n\n      coefficients[0] = coefficient;\n      return new GF256Poly(this, coefficients);\n    }\n    /**\n     * @param {?} a\n     * @return {?}\n     */\n\n  }, {\n    key: \"exp\",\n    value: function exp(a) {\n      return this.expTable[a];\n    }\n    /**\n     * @param {?} a\n     * @return {?}\n     */\n\n  }, {\n    key: \"log\",\n    value: function log(a) {\n      if (a == 0) {\n        throw \"System.ArgumentException\";\n      }\n\n      return this.logTable[a];\n    }\n    /**\n     * @param {?} a\n     * @return {?}\n     */\n\n  }, {\n    key: \"inverse\",\n    value: function inverse(a) {\n      if (a == 0) {\n        throw \"System.ArithmeticException\";\n      }\n\n      return this.expTable[255 - this.logTable[a]];\n    }\n    /**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n\n  }, {\n    key: \"multiply\",\n    value: function multiply(a, b) {\n      if (a == 0 || b == 0) {\n        return 0;\n      }\n\n      if (a == 1) {\n        return b;\n      }\n\n      if (b == 1) {\n        return a;\n      }\n\n      return this.expTable[(this.logTable[a] + this.logTable[b]) % 255];\n    }\n    /**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n\n  }], [{\n    key: \"addOrSubtract\",\n    value: function addOrSubtract(a, b) {\n      return a ^ b;\n    }\n  }]);\n\n  return GF256;\n}();\n\nGF256.QR_CODE_FIELD = new GF256(0x011D);\nGF256.DATA_MATRIX_FIELD = new GF256(0x012D);\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\nvar ReedSolomonDecoder = /*#__PURE__*/function () {\n  /**\n   * @param {?} field\n   */\n  function ReedSolomonDecoder(field) {\n    _classCallCheck(this, ReedSolomonDecoder);\n\n    this.field = field;\n  }\n  /**\n   * @param {?} received\n   * @param {?} twoS\n   * @return {?}\n   */\n\n\n  _createClass(ReedSolomonDecoder, [{\n    key: \"decode\",\n    value: function decode(received, twoS) {\n      var\n      /** @type {?} */\n      poly = new GF256Poly(this.field, received);\n      var\n      /** @type {?} */\n      syndromeCoefficients = new Array(twoS);\n\n      for (var\n      /** @type {?} */\n      i = 0; i < syndromeCoefficients.length; i++) {\n        syndromeCoefficients[i] = 0;\n      }\n\n      var\n      /** @type {?} */\n      dataMatrix = false; //this.field.Equals(GF256.DATA_MATRIX_FIELD);\n\n      var\n      /** @type {?} */\n      noError = true;\n\n      for (var\n      /** @type {?} */\n      i = 0; i < twoS; i++) {\n        // Thanks to sanfordsquires for this fix:\n        var\n        /** @type {?} */\n        evalu = poly.evaluateAt(this.field.exp(dataMatrix ? i + 1 : i));\n        syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalu;\n\n        if (evalu != 0) {\n          noError = false;\n        }\n      }\n\n      if (noError) {\n        return;\n      }\n\n      var\n      /** @type {?} */\n      syndrome = new GF256Poly(this.field, syndromeCoefficients);\n      var\n      /** @type {?} */\n      sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(twoS, 1), syndrome, twoS);\n      var\n      /** @type {?} */\n      sigma = sigmaOmega[0];\n      var\n      /** @type {?} */\n      omega = sigmaOmega[1];\n      var\n      /** @type {?} */\n      errorLocations = this.findErrorLocations(sigma);\n      var\n      /** @type {?} */\n      errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations, dataMatrix);\n\n      for (var\n      /** @type {?} */\n      i = 0; i < errorLocations.length; i++) {\n        var\n        /** @type {?} */\n        position = received.length - 1 - this.field.log(errorLocations[i]);\n\n        if (position < 0) {\n          throw \"ReedSolomonException Bad error location\";\n        }\n\n        received[position] = GF256.addOrSubtract(received[position], errorMagnitudes[i]);\n      }\n    }\n    /**\n     * @param {?} a\n     * @param {?} b\n     * @param {?} R\n     * @return {?}\n     */\n\n  }, {\n    key: \"runEuclideanAlgorithm\",\n    value: function runEuclideanAlgorithm(a, b, R) {\n      // Assume a's degree is >= b's\n      if (a.Degree < b.Degree) {\n        var\n        /** @type {?} */\n        temp = a;\n        a = b;\n        b = temp;\n      }\n\n      var\n      /** @type {?} */\n      rLast = a;\n      var\n      /** @type {?} */\n      r = b;\n      var\n      /** @type {?} */\n      sLast = this.field.One;\n      var\n      /** @type {?} */\n      s = this.field.Zero;\n      var\n      /** @type {?} */\n      tLast = this.field.Zero;\n      var\n      /** @type {?} */\n      t = this.field.One; // Run Euclidean algorithm until r's degree is less than R/2\n\n      while (r.Degree >= Math.floor(R / 2)) {\n        var\n        /** @type {?} */\n        rLastLast = rLast;\n        var\n        /** @type {?} */\n        sLastLast = sLast;\n        var\n        /** @type {?} */\n        tLastLast = tLast;\n        rLast = r;\n        sLast = s;\n        tLast = t; // Divide rLastLast by rLast, with quotient in q and remainder in r\n\n        if (rLast.Zero) {\n          // Oops, Euclidean algorithm already terminated?\n          throw \"r_{i-1} was zero\";\n        }\n\n        r = rLastLast;\n        var\n        /** @type {?} */\n        q = this.field.Zero;\n        var\n        /** @type {?} */\n        denominatorLeadingTerm = rLast.getCoefficient(rLast.Degree);\n        var\n        /** @type {?} */\n        dltInverse = this.field.inverse(denominatorLeadingTerm);\n\n        while (r.Degree >= rLast.Degree && !r.Zero) {\n          var\n          /** @type {?} */\n          degreeDiff = r.Degree - rLast.Degree;\n          var\n          /** @type {?} */\n          scale = this.field.multiply(r.getCoefficient(r.Degree), dltInverse);\n          q = q.addOrSubtract(this.field.buildMonomial(degreeDiff, scale));\n          r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale)); //r.EXE();\n        }\n\n        s = q.multiply1(sLast).addOrSubtract(sLastLast);\n        t = q.multiply1(tLast).addOrSubtract(tLastLast);\n      }\n\n      var\n      /** @type {?} */\n      sigmaTildeAtZero = t.getCoefficient(0);\n\n      if (sigmaTildeAtZero == 0) {\n        throw \"ReedSolomonException sigmaTilde(0) was zero\";\n      }\n\n      var\n      /** @type {?} */\n      inverse = this.field.inverse(sigmaTildeAtZero);\n      var\n      /** @type {?} */\n      sigma = t.multiply2(inverse);\n      var\n      /** @type {?} */\n      omega = r.multiply2(inverse);\n      return new Array(sigma, omega);\n    }\n    /**\n     * @param {?} errorLocator\n     * @return {?}\n     */\n\n  }, {\n    key: \"findErrorLocations\",\n    value: function findErrorLocations(errorLocator) {\n      // This is a direct application of Chien's search\n      var\n      /** @type {?} */\n      numErrors = errorLocator.Degree;\n\n      if (numErrors == 1) {\n        // shortcut\n        return new Array(errorLocator.getCoefficient(1));\n      }\n\n      var\n      /** @type {?} */\n      result = new Array(numErrors);\n      var\n      /** @type {?} */\n      e = 0;\n\n      for (var\n      /** @type {?} */\n      i = 1; i < 256 && e < numErrors; i++) {\n        if (errorLocator.evaluateAt(i) == 0) {\n          result[e] = this.field.inverse(i);\n          e++;\n        }\n      }\n\n      if (e != numErrors) {\n        throw \"Error locator degree does not match number of roots\";\n      }\n\n      return result;\n    }\n    /**\n     * @param {?} errorEvaluator\n     * @param {?} errorLocations\n     * @param {?} dataMatrix\n     * @return {?}\n     */\n\n  }, {\n    key: \"findErrorMagnitudes\",\n    value: function findErrorMagnitudes(errorEvaluator, errorLocations, dataMatrix) {\n      // This is directly applying Forney's Formula\n      var\n      /** @type {?} */\n      s = errorLocations.length;\n      var\n      /** @type {?} */\n      result = new Array(s);\n\n      for (var\n      /** @type {?} */\n      i = 0; i < s; i++) {\n        var\n        /** @type {?} */\n        xiInverse = this.field.inverse(errorLocations[i]);\n        var\n        /** @type {?} */\n        denominator = 1;\n\n        for (var\n        /** @type {?} */\n        j = 0; j < s; j++) {\n          if (i != j) {\n            denominator = this.field.multiply(denominator, GF256.addOrSubtract(1, this.field.multiply(errorLocations[j], xiInverse)));\n          }\n        }\n\n        result[i] = this.field.multiply(errorEvaluator.evaluateAt(xiInverse), this.field.inverse(denominator)); // Thanks to sanfordsquires for this fix:\n\n        if (dataMatrix) {\n          result[i] = this.field.multiply(result[i], xiInverse);\n        }\n      }\n\n      return result;\n    }\n  }]);\n\n  return ReedSolomonDecoder;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n\nvar DataMask000 = /*#__PURE__*/function () {\n  function DataMask000() {\n    _classCallCheck(this, DataMask000);\n\n    this.isMasked = function (i, j) {\n      return (i + j & 0x01) == 0;\n    };\n  }\n  /**\n   * @param {?} bits\n   * @param {?} dimension\n   * @return {?}\n   */\n\n\n  _createClass(DataMask000, [{\n    key: \"unmaskBitMatrix\",\n    value: function unmaskBitMatrix(bits, dimension) {\n      for (var\n      /** @type {?} */\n      i = 0; i < dimension; i++) {\n        for (var\n        /** @type {?} */\n        j = 0; j < dimension; j++) {\n          if (this.isMasked(i, j)) {\n            bits.flip(j, i);\n          }\n        }\n      }\n    }\n  }]);\n\n  return DataMask000;\n}();\n\nvar DataMask001 = /*#__PURE__*/function () {\n  function DataMask001() {\n    _classCallCheck(this, DataMask001);\n\n    this.isMasked = function (i, j) {\n      return (i & 0x01) == 0;\n    };\n  }\n  /**\n   * @param {?} bits\n   * @param {?} dimension\n   * @return {?}\n   */\n\n\n  _createClass(DataMask001, [{\n    key: \"unmaskBitMatrix\",\n    value: function unmaskBitMatrix(bits, dimension) {\n      for (var\n      /** @type {?} */\n      i = 0; i < dimension; i++) {\n        for (var\n        /** @type {?} */\n        j = 0; j < dimension; j++) {\n          if (this.isMasked(i, j)) {\n            bits.flip(j, i);\n          }\n        }\n      }\n    }\n  }]);\n\n  return DataMask001;\n}();\n\nvar DataMask010 = /*#__PURE__*/function () {\n  function DataMask010() {\n    _classCallCheck(this, DataMask010);\n\n    this.isMasked = function (i, j) {\n      return j % 3 == 0;\n    };\n  }\n  /**\n   * @param {?} bits\n   * @param {?} dimension\n   * @return {?}\n   */\n\n\n  _createClass(DataMask010, [{\n    key: \"unmaskBitMatrix\",\n    value: function unmaskBitMatrix(bits, dimension) {\n      for (var\n      /** @type {?} */\n      i = 0; i < dimension; i++) {\n        for (var\n        /** @type {?} */\n        j = 0; j < dimension; j++) {\n          if (this.isMasked(i, j)) {\n            bits.flip(j, i);\n          }\n        }\n      }\n    }\n  }]);\n\n  return DataMask010;\n}();\n\nvar DataMask011 = /*#__PURE__*/function () {\n  function DataMask011() {\n    _classCallCheck(this, DataMask011);\n\n    this.isMasked = function (i, j) {\n      return (i + j) % 3 == 0;\n    };\n  }\n  /**\n   * @param {?} bits\n   * @param {?} dimension\n   * @return {?}\n   */\n\n\n  _createClass(DataMask011, [{\n    key: \"unmaskBitMatrix\",\n    value: function unmaskBitMatrix(bits, dimension) {\n      for (var\n      /** @type {?} */\n      i = 0; i < dimension; i++) {\n        for (var\n        /** @type {?} */\n        j = 0; j < dimension; j++) {\n          if (this.isMasked(i, j)) {\n            bits.flip(j, i);\n          }\n        }\n      }\n    }\n  }]);\n\n  return DataMask011;\n}();\n\nvar DataMask100 = /*#__PURE__*/function () {\n  function DataMask100() {\n    _classCallCheck(this, DataMask100);\n\n    this.isMasked = function (i, j) {\n      return (this.URShift(i, 1) + j / 3 & 0x01) == 0;\n    };\n  }\n  /**\n   * @param {?} bits\n   * @param {?} dimension\n   * @return {?}\n   */\n\n\n  _createClass(DataMask100, [{\n    key: \"unmaskBitMatrix\",\n    value: function unmaskBitMatrix(bits, dimension) {\n      for (var\n      /** @type {?} */\n      i = 0; i < dimension; i++) {\n        for (var\n        /** @type {?} */\n        j = 0; j < dimension; j++) {\n          if (this.isMasked(i, j)) {\n            bits.flip(j, i);\n          }\n        }\n      }\n    }\n    /**\n     * @param {?} number\n     * @param {?} bits\n     * @return {?}\n     */\n\n  }, {\n    key: \"URShift\",\n    value: function URShift(number, bits) {\n      if (number >= 0) return number >> bits;else return (number >> bits) + (2 << ~bits);\n    }\n  }]);\n\n  return DataMask100;\n}();\n\nvar DataMask101 = /*#__PURE__*/function () {\n  function DataMask101() {\n    _classCallCheck(this, DataMask101);\n\n    this.isMasked = function (i, j) {\n      var\n      /** @type {?} */\n      temp = i * j;\n      return (temp & 0x01) + temp % 3 == 0;\n    };\n  }\n  /**\n   * @param {?} bits\n   * @param {?} dimension\n   * @return {?}\n   */\n\n\n  _createClass(DataMask101, [{\n    key: \"unmaskBitMatrix\",\n    value: function unmaskBitMatrix(bits, dimension) {\n      for (var\n      /** @type {?} */\n      i = 0; i < dimension; i++) {\n        for (var\n        /** @type {?} */\n        j = 0; j < dimension; j++) {\n          if (this.isMasked(i, j)) {\n            bits.flip(j, i);\n          }\n        }\n      }\n    }\n  }]);\n\n  return DataMask101;\n}();\n\nvar DataMask110 = /*#__PURE__*/function () {\n  function DataMask110() {\n    _classCallCheck(this, DataMask110);\n\n    this.isMasked = function (i, j) {\n      var\n      /** @type {?} */\n      temp = i * j;\n      return ((temp & 0x01) + temp % 3 & 0x01) == 0;\n    };\n  }\n  /**\n   * @param {?} bits\n   * @param {?} dimension\n   * @return {?}\n   */\n\n\n  _createClass(DataMask110, [{\n    key: \"unmaskBitMatrix\",\n    value: function unmaskBitMatrix(bits, dimension) {\n      for (var\n      /** @type {?} */\n      i = 0; i < dimension; i++) {\n        for (var\n        /** @type {?} */\n        j = 0; j < dimension; j++) {\n          if (this.isMasked(i, j)) {\n            bits.flip(j, i);\n          }\n        }\n      }\n    }\n  }]);\n\n  return DataMask110;\n}();\n\nvar DataMask111 = /*#__PURE__*/function () {\n  function DataMask111() {\n    _classCallCheck(this, DataMask111);\n\n    this.isMasked = function (i, j) {\n      return ((i + j & 0x01) + i * j % 3 & 0x01) == 0;\n    };\n  }\n  /**\n   * @param {?} bits\n   * @param {?} dimension\n   * @return {?}\n   */\n\n\n  _createClass(DataMask111, [{\n    key: \"unmaskBitMatrix\",\n    value: function unmaskBitMatrix(bits, dimension) {\n      for (var\n      /** @type {?} */\n      i = 0; i < dimension; i++) {\n        for (var\n        /** @type {?} */\n        j = 0; j < dimension; j++) {\n          if (this.isMasked(i, j)) {\n            bits.flip(j, i);\n          }\n        }\n      }\n    }\n  }]);\n\n  return DataMask111;\n}();\n\nvar DataMask = /*#__PURE__*/function () {\n  function DataMask() {\n    _classCallCheck(this, DataMask);\n  }\n\n  _createClass(DataMask, null, [{\n    key: \"forReference\",\n    value:\n    /**\n     * @param {?} reference\n     * @return {?}\n     */\n    function forReference(reference) {\n      if (reference < 0 || reference > 7) {\n        throw \"System.ArgumentException\";\n      }\n\n      return DataMask.DATA_MASKS[reference];\n    }\n  }]);\n\n  return DataMask;\n}();\n\nDataMask.DATA_MASKS = new Array(new DataMask000(), new DataMask001(), new DataMask010(), new DataMask011(), new DataMask100(), new DataMask101(), new DataMask110(), new DataMask111());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\nvar BitMatrixParser = /*#__PURE__*/function () {\n  /**\n   * @param {?} bitmatrix\n   */\n  function BitMatrixParser(bitmatrix) {\n    _classCallCheck(this, BitMatrixParser);\n\n    var\n    /** @type {?} */\n    dimension = bitmatrix.Dimension;\n\n    if (dimension < 21 || (dimension & 0x03) != 1) {\n      throw \"Error BitMatrixParser\";\n    }\n\n    this.bitMatrix = bitmatrix;\n  }\n  /**\n   * @param {?} i\n   * @param {?} j\n   * @param {?} versionBits\n   * @return {?}\n   */\n\n\n  _createClass(BitMatrixParser, [{\n    key: \"copyBit\",\n    value: function copyBit(i, j, versionBits) {\n      return this.bitMatrix.get_Renamed(i, j) ? versionBits << 1 | 0x1 : versionBits << 1;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"readFormatInformation\",\n    value: function readFormatInformation() {\n      if (this.parsedFormatInfo != null) {\n        return this.parsedFormatInfo;\n      } // Read top-left format info bits\n\n\n      var\n      /** @type {?} */\n      formatInfoBits = 0;\n\n      for (var\n      /** @type {?} */\n      i = 0; i < 6; i++) {\n        formatInfoBits = this.copyBit(i, 8, formatInfoBits);\n      } // .. and skip a bit in the timing pattern ...\n\n\n      formatInfoBits = this.copyBit(7, 8, formatInfoBits);\n      formatInfoBits = this.copyBit(8, 8, formatInfoBits);\n      formatInfoBits = this.copyBit(8, 7, formatInfoBits); // .. and skip a bit in the timing pattern ...\n\n      for (var\n      /** @type {?} */\n      j = 5; j >= 0; j--) {\n        formatInfoBits = this.copyBit(8, j, formatInfoBits);\n      }\n\n      this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits);\n\n      if (this.parsedFormatInfo != null) {\n        return this.parsedFormatInfo;\n      } // Hmm, failed. Try the top-right/bottom-left pattern\n\n\n      var\n      /** @type {?} */\n      dimension = this.bitMatrix.Dimension;\n      formatInfoBits = 0;\n      var\n      /** @type {?} */\n      iMin = dimension - 8;\n\n      for (var\n      /** @type {?} */\n      i = dimension - 1; i >= iMin; i--) {\n        formatInfoBits = this.copyBit(i, 8, formatInfoBits);\n      }\n\n      for (var\n      /** @type {?} */\n      j = dimension - 7; j < dimension; j++) {\n        formatInfoBits = this.copyBit(8, j, formatInfoBits);\n      }\n\n      this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits);\n\n      if (this.parsedFormatInfo != null) {\n        return this.parsedFormatInfo;\n      }\n\n      throw \"Error readFormatInformation\";\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"readVersion\",\n    value: function readVersion() {\n      if (this.parsedVersion != null) {\n        return this.parsedVersion;\n      }\n\n      var\n      /** @type {?} */\n      dimension = this.bitMatrix.Dimension;\n      var\n      /** @type {?} */\n      provisionalVersion = dimension - 17 >> 2;\n\n      if (provisionalVersion <= 6) {\n        return Version.getVersionForNumber(provisionalVersion);\n      } // Read top-right version info: 3 wide by 6 tall\n\n\n      var\n      /** @type {?} */\n      versionBits = 0;\n      var\n      /** @type {?} */\n      ijMin = dimension - 11;\n\n      for (var\n      /** @type {?} */\n      j = 5; j >= 0; j--) {\n        for (var\n        /** @type {?} */\n        i = dimension - 9; i >= ijMin; i--) {\n          versionBits = this.copyBit(i, j, versionBits);\n        }\n      }\n\n      this.parsedVersion = Version.decodeVersionInformation(versionBits);\n\n      if (this.parsedVersion != null && this.parsedVersion.DimensionForVersion == dimension) {\n        return this.parsedVersion;\n      } // Hmm, failed. Try bottom left: 6 wide by 3 tall\n\n\n      versionBits = 0;\n\n      for (var\n      /** @type {?} */\n      i = 5; i >= 0; i--) {\n        for (var\n        /** @type {?} */\n        j = dimension - 9; j >= ijMin; j--) {\n          versionBits = this.copyBit(i, j, versionBits);\n        }\n      }\n\n      this.parsedVersion = Version.decodeVersionInformation(versionBits);\n\n      if (this.parsedVersion != null && this.parsedVersion.DimensionForVersion == dimension) {\n        return this.parsedVersion;\n      }\n\n      throw \"Error readVersion\";\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"readCodewords\",\n    value: function readCodewords() {\n      var\n      /** @type {?} */\n      formatInfo = this.readFormatInformation();\n      var\n      /** @type {?} */\n      version = this.readVersion(); // Get the data mask for the format used in this QR Code. This will exclude\n      // some bits from reading as we wind through the bit matrix.\n\n      var\n      /** @type {?} */\n      dataMask = DataMask.forReference(formatInfo.DataMask);\n      var\n      /** @type {?} */\n      dimension = this.bitMatrix.Dimension;\n      dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n      var\n      /** @type {?} */\n      functionPattern = version.buildFunctionPattern();\n      var\n      /** @type {?} */\n      readingUp = true;\n      var\n      /** @type {?} */\n      result = new Array(version.TotalCodewords);\n      var\n      /** @type {?} */\n      resultOffset = 0;\n      var\n      /** @type {?} */\n      currentByte = 0;\n      var\n      /** @type {?} */\n      bitsRead = 0; // Read columns in pairs, from right to left\n\n      for (var\n      /** @type {?} */\n      j = dimension - 1; j > 0; j -= 2) {\n        if (j == 6) {\n          // Skip whole column with vertical alignment pattern;\n          // saves time and makes the other code proceed more cleanly\n          j--;\n        } // Read alternatingly from bottom to top then top to bottom\n\n\n        for (var\n        /** @type {?} */\n        count = 0; count < dimension; count++) {\n          var\n          /** @type {?} */\n          i = readingUp ? dimension - 1 - count : count;\n\n          for (var\n          /** @type {?} */\n          col = 0; col < 2; col++) {\n            // Ignore bits covered by the function pattern\n            if (!functionPattern.get_Renamed(j - col, i)) {\n              // Read a bit\n              bitsRead++;\n              currentByte <<= 1;\n\n              if (this.bitMatrix.get_Renamed(j - col, i)) {\n                currentByte |= 1;\n              } // If we've made a whole byte, save it off\n\n\n              if (bitsRead == 8) {\n                result[resultOffset++] = currentByte;\n                bitsRead = 0;\n                currentByte = 0;\n              }\n            }\n          }\n        }\n\n        readingUp = !readingUp; // readingUp = !readingUp; // switch directions\n      }\n\n      if (resultOffset != version.TotalCodewords) {\n        throw \"Error readCodewords\";\n      }\n\n      return result;\n    }\n  }]);\n\n  return BitMatrixParser;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\n/*\n*\n* Copyright 2007 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n\nvar DataBlock = /*#__PURE__*/function () {\n  /**\n   * @param {?} numDataCodewords\n   * @param {?} codewords\n   */\n  function DataBlock(numDataCodewords, codewords) {\n    _classCallCheck(this, DataBlock);\n\n    this.numDataCodewords = numDataCodewords;\n    this.codewords = codewords;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(DataBlock, [{\n    key: \"NumDataCodewords\",\n    get: function get() {\n      return this.numDataCodewords;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"Codewords\",\n    get: function get() {\n      return this.codewords;\n    }\n    /**\n     * @param {?} rawCodewords\n     * @param {?} version\n     * @param {?} ecLevel\n     * @return {?}\n     */\n\n  }], [{\n    key: \"getDataBlocks\",\n    value: function getDataBlocks(rawCodewords, version, ecLevel) {\n      if (rawCodewords.length != version.TotalCodewords) {\n        throw \"ArgumentException\";\n      } // Figure out the number and size of data blocks used by this version and\n      // error correction level\n\n\n      var\n      /** @type {?} */\n      ecBlocks = version.getECBlocksForLevel(ecLevel); // First count the total number of data blocks\n\n      var\n      /** @type {?} */\n      totalBlocks = 0;\n      var\n      /** @type {?} */\n      ecBlockArray = ecBlocks.getECBlocks();\n\n      for (var\n      /** @type {?} */\n      i = 0; i < ecBlockArray.length; i++) {\n        totalBlocks += ecBlockArray[i].Count;\n      } // Now establish DataBlocks of the appropriate size and number of data codewords\n\n\n      var\n      /** @type {?} */\n      result = new Array(totalBlocks);\n      var\n      /** @type {?} */\n      numResultBlocks = 0;\n\n      for (var\n      /** @type {?} */\n      j = 0; j < ecBlockArray.length; j++) {\n        var\n        /** @type {?} */\n        ecBlock = ecBlockArray[j];\n\n        for (var\n        /** @type {?} */\n        i = 0; i < ecBlock.Count; i++) {\n          var\n          /** @type {?} */\n          numDataCodewords = ecBlock.DataCodewords;\n          var\n          /** @type {?} */\n          numBlockCodewords = ecBlocks.ECCodewordsPerBlock + numDataCodewords;\n          result[numResultBlocks++] = new DataBlock(numDataCodewords, new Array(numBlockCodewords));\n        }\n      } // All blocks have the same amount of data, except that the last n\n      // (where n may be 0) have 1 more byte. Figure out where these start.\n\n\n      var\n      /** @type {?} */\n      shorterBlocksTotalCodewords = result[0].codewords.length;\n      var\n      /** @type {?} */\n      longerBlocksStartAt = result.length - 1;\n\n      while (longerBlocksStartAt >= 0) {\n        var\n        /** @type {?} */\n        numCodewords = result[longerBlocksStartAt].codewords.length;\n\n        if (numCodewords == shorterBlocksTotalCodewords) {\n          break;\n        }\n\n        longerBlocksStartAt--;\n      }\n\n      longerBlocksStartAt++;\n      var\n      /** @type {?} */\n      shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.ECCodewordsPerBlock; // The last elements of result may be 1 element longer;\n      // first fill out as many elements as all of them have\n\n      var\n      /** @type {?} */\n      rawCodewordsOffset = 0;\n\n      for (var\n      /** @type {?} */\n      i = 0; i < shorterBlocksNumDataCodewords; i++) {\n        for (var\n        /** @type {?} */\n        j = 0; j < numResultBlocks; j++) {\n          result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\n        }\n      } // Fill out the last data block in the longer ones\n\n\n      for (var\n      /** @type {?} */\n      j = longerBlocksStartAt; j < numResultBlocks; j++) {\n        result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];\n      } // Now add in error correction blocks\n\n\n      var\n      /** @type {?} */\n      max = result[0].codewords.length;\n\n      for (var\n      /** @type {?} */\n      i = shorterBlocksNumDataCodewords; i < max; i++) {\n        for (var\n        /** @type {?} */\n        j = 0; j < numResultBlocks; j++) {\n          var\n          /** @type {?} */\n          iOffset = j < longerBlocksStartAt ? i : i + 1;\n          result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\n        }\n      }\n\n      return result;\n    }\n  }]);\n\n  return DataBlock;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\n\nvar QRCodeDataBlockReader = /*#__PURE__*/function () {\n  /**\n   * @param {?} blocks\n   * @param {?} version\n   * @param {?} numErrorCorrectionCode\n   */\n  function QRCodeDataBlockReader(blocks, version, numErrorCorrectionCode) {\n    _classCallCheck(this, QRCodeDataBlockReader);\n\n    this.blockPointer = 0;\n    this.bitPointer = 7;\n    this.dataLength = 0;\n    this.blocks = blocks;\n    this.numErrorCorrectionCode = numErrorCorrectionCode;\n    if (version <= 9) this.dataLengthMode = 0;else if (version >= 10 && version <= 26) this.dataLengthMode = 1;else if (version >= 27 && version <= 40) this.dataLengthMode = 2;\n  }\n  /**\n   * @param {?} numBits\n   * @return {?}\n   */\n\n\n  _createClass(QRCodeDataBlockReader, [{\n    key: \"getNextBits\",\n    value: function getNextBits(numBits) {\n      var\n      /** @type {?} */\n      bits = 0;\n\n      if (numBits < this.bitPointer + 1) {\n        // next word fits into current data block\n        var\n        /** @type {?} */\n        mask = 0;\n\n        for (var\n        /** @type {?} */\n        i = 0; i < numBits; i++) {\n          mask += 1 << i;\n        }\n\n        mask <<= this.bitPointer - numBits + 1;\n        bits = (this.blocks[this.blockPointer] & mask) >> this.bitPointer - numBits + 1;\n        this.bitPointer -= numBits;\n        return bits;\n      } else if (numBits < this.bitPointer + 1 + 8) {\n        // next word crosses 2 data blocks\n        var\n        /** @type {?} */\n        mask1 = 0;\n\n        for (var\n        /** @type {?} */\n        i = 0; i < this.bitPointer + 1; i++) {\n          mask1 += 1 << i;\n        }\n\n        bits = (this.blocks[this.blockPointer] & mask1) << numBits - (this.bitPointer + 1);\n        this.blockPointer++;\n        bits += this.blocks[this.blockPointer] >> 8 - (numBits - (this.bitPointer + 1));\n        this.bitPointer = this.bitPointer - numBits % 8;\n\n        if (this.bitPointer < 0) {\n          this.bitPointer = 8 + this.bitPointer;\n        }\n\n        return bits;\n      } else if (numBits < this.bitPointer + 1 + 16) {\n        // next word crosses 3 data blocks\n        var\n        /** @type {?} */\n        mask1 = 0; // mask of first block\n\n        var\n        /** @type {?} */\n        mask3 = 0; // mask of 3rd block\n        //bitPointer + 1 : number of bits of the 1st block\n        //8 : number of the 2nd block (note that use already 8bits because next word uses 3 data blocks)\n        //numBits - (bitPointer + 1 + 8) : number of bits of the 3rd block\n\n        for (var\n        /** @type {?} */\n        i = 0; i < this.bitPointer + 1; i++) {\n          mask1 += 1 << i;\n        }\n\n        var\n        /** @type {?} */\n        bitsFirstBlock = (this.blocks[this.blockPointer] & mask1) << numBits - (this.bitPointer + 1);\n        this.blockPointer++;\n        var\n        /** @type {?} */\n        bitsSecondBlock = this.blocks[this.blockPointer] << numBits - (this.bitPointer + 1 + 8);\n        this.blockPointer++;\n\n        for (var\n        /** @type {?} */\n        i = 0; i < numBits - (this.bitPointer + 1 + 8); i++) {\n          mask3 += 1 << i;\n        }\n\n        mask3 <<= 8 - (numBits - (this.bitPointer + 1 + 8));\n        var\n        /** @type {?} */\n        bitsThirdBlock = (this.blocks[this.blockPointer] & mask3) >> 8 - (numBits - (this.bitPointer + 1 + 8));\n        bits = bitsFirstBlock + bitsSecondBlock + bitsThirdBlock;\n        this.bitPointer = this.bitPointer - (numBits - 8) % 8;\n\n        if (this.bitPointer < 0) {\n          this.bitPointer = 8 + this.bitPointer;\n        }\n\n        return bits;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"NextMode\",\n    value: function NextMode() {\n      if (this.blockPointer > this.blocks.length - this.numErrorCorrectionCode - 2) return 0;else return this.getNextBits(4);\n    }\n    /**\n     * @param {?} modeIndicator\n     * @return {?}\n     */\n\n  }, {\n    key: \"getDataLength\",\n    value: function getDataLength(modeIndicator) {\n      var\n      /** @type {?} */\n      index = 0;\n\n      while (true) {\n        if (modeIndicator >> index == 1) break;\n        index++;\n      }\n\n      return this.getNextBits(QRCodeDataBlockReader.sizeOfDataLengthInfo[this.dataLengthMode][index]);\n    }\n    /**\n     * @param {?} dataLength\n     * @return {?}\n     */\n\n  }, {\n    key: \"getRomanAndFigureString\",\n    value: function getRomanAndFigureString(dataLength) {\n      var\n      /** @type {?} */\n      length = dataLength;\n      var\n      /** @type {?} */\n      intData = 0;\n      var\n      /** @type {?} */\n      strData = \"\";\n      var\n      /** @type {?} */\n      tableRomanAndFigure = new Array('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', '$', '%', '*', '+', '-', '.', '/', ':');\n\n      do {\n        if (length > 1) {\n          intData = this.getNextBits(11);\n          var\n          /** @type {?} */\n          firstLetter = Math.floor(intData / 45);\n          var\n          /** @type {?} */\n          secondLetter = intData % 45;\n          strData += tableRomanAndFigure[firstLetter];\n          strData += tableRomanAndFigure[secondLetter];\n          length -= 2;\n        } else if (length == 1) {\n          intData = this.getNextBits(6);\n          strData += tableRomanAndFigure[intData];\n          length -= 1;\n        }\n      } while (length > 0);\n\n      return strData;\n    }\n    /**\n     * @param {?} dataLength\n     * @return {?}\n     */\n\n  }, {\n    key: \"getFigureString\",\n    value: function getFigureString(dataLength) {\n      var\n      /** @type {?} */\n      length = dataLength;\n      var\n      /** @type {?} */\n      intData = 0;\n      var\n      /** @type {?} */\n      strData = \"\";\n\n      do {\n        if (length >= 3) {\n          intData = this.getNextBits(10);\n          if (intData < 100) strData += \"0\";\n          if (intData < 10) strData += \"0\";\n          length -= 3;\n        } else if (length == 2) {\n          intData = this.getNextBits(7);\n          if (intData < 10) strData += \"0\";\n          length -= 2;\n        } else if (length == 1) {\n          intData = this.getNextBits(4);\n          length -= 1;\n        }\n\n        strData += intData;\n      } while (length > 0);\n\n      return strData;\n    }\n    /**\n     * @param {?} dataLength\n     * @return {?}\n     */\n\n  }, {\n    key: \"get8bitByteArray\",\n    value: function get8bitByteArray(dataLength) {\n      var\n      /** @type {?} */\n      length = dataLength;\n      var\n      /** @type {?} */\n      intData = 0;\n      var\n      /** @type {?} */\n      output = new Array();\n\n      do {\n        intData = this.getNextBits(8);\n        output.push(intData);\n        length--;\n      } while (length > 0);\n\n      return output;\n    }\n    /**\n     * @param {?} dataLength\n     * @return {?}\n     */\n\n  }, {\n    key: \"getKanjiString\",\n    value: function getKanjiString(dataLength) {\n      var\n      /** @type {?} */\n      length = dataLength;\n      var\n      /** @type {?} */\n      intData = 0;\n      var\n      /** @type {?} */\n      unicodeString = \"\";\n\n      do {\n        intData = this.getNextBits(13);\n        var\n        /** @type {?} */\n        lowerByte = intData % 0xC0;\n        var\n        /** @type {?} */\n        higherByte = intData / 0xC0;\n        var\n        /** @type {?} */\n        tempWord = (higherByte << 8) + lowerByte;\n        var\n        /** @type {?} */\n        shiftjisWord = 0;\n\n        if (tempWord + 0x8140 <= 0x9FFC) {\n          // between 8140 - 9FFC on Shift_JIS character set\n          shiftjisWord = tempWord + 0x8140;\n        } else {\n          // between E040 - EBBF on Shift_JIS character set\n          shiftjisWord = tempWord + 0xC140;\n        } //var tempByte = new Array(0,0);\n        //tempByte[0] = (sbyte) (shiftjisWord >> 8);\n        //tempByte[1] = (sbyte) (shiftjisWord & 0xFF);\n        //unicodeString += new String(SystemUtils.ToCharArray(SystemUtils.ToByteArray(tempByte)));\n\n\n        unicodeString += String.fromCharCode(shiftjisWord);\n        length--;\n      } while (length > 0);\n\n      return unicodeString;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"DataByte\",\n    get: function get() {\n      var\n      /** @type {?} */\n      output = new Array();\n      var\n      /** @type {?} */\n      MODE_NUMBER = 1;\n      var\n      /** @type {?} */\n      MODE_ROMAN_AND_NUMBER = 2;\n      var\n      /** @type {?} */\n      MODE_8BIT_BYTE = 4;\n      var\n      /** @type {?} */\n      MODE_KANJI = 8;\n\n      do {\n        var\n        /** @type {?} */\n        mode = this.NextMode(); //canvas.println(\"mode: \" + mode);\n\n        if (mode == 0) {\n          if (output.length > 0) break;else throw \"Empty data block\";\n        } //if (mode != 1 && mode != 2 && mode != 4 && mode != 8)\n        //\tbreak;\n        //}\n\n\n        if (mode != MODE_NUMBER && mode != MODE_ROMAN_AND_NUMBER && mode != MODE_8BIT_BYTE && mode != MODE_KANJI) {\n          /*\t\t\t\t\tcanvas.println(\"Invalid mode: \" + mode);\n                           mode = guessMode(mode);\n                           canvas.println(\"Guessed mode: \" + mode); */\n          throw \"Invalid mode: \" + mode + \" in (block:\" + this.blockPointer + \" bit:\" + this.bitPointer + \")\";\n        }\n\n        var\n        /** @type {?} */\n        dataLength = this.getDataLength(mode);\n        if (dataLength < 1) throw \"Invalid data length: \" + dataLength; //canvas.println(\"length: \" + dataLength);\n\n        switch (mode) {\n          case MODE_NUMBER:\n            //canvas.println(\"Mode: Figure\");\n            var\n            /** @type {?} */\n            temp_str = this.getFigureString(dataLength);\n            var\n            /** @type {?} */\n            ta = new Array(temp_str.length);\n\n            for (var\n            /** @type {?} */\n            j = 0; j < temp_str.length; j++) {\n              ta[j] = temp_str.charCodeAt(j);\n            }\n\n            output.push(ta);\n            break;\n\n          case MODE_ROMAN_AND_NUMBER:\n            //canvas.println(\"Mode: Roman&Figure\");\n            var\n            /** @type {?} */\n            temp_str = this.getRomanAndFigureString(dataLength);\n            var\n            /** @type {?} */\n            ta = new Array(temp_str.length);\n\n            for (var\n            /** @type {?} */\n            j = 0; j < temp_str.length; j++) {\n              ta[j] = temp_str.charCodeAt(j);\n            }\n\n            output.push(ta); //output.Write(SystemUtils.ToByteArray(temp_sbyteArray2), 0, temp_sbyteArray2.Length);\n\n            break;\n\n          case MODE_8BIT_BYTE:\n            //canvas.println(\"Mode: 8bit Byte\");\n            //sbyte[] temp_sbyteArray3;\n            var\n            /** @type {?} */\n            temp_sbyteArray3 = this.get8bitByteArray(dataLength);\n            output.push(temp_sbyteArray3); //output.Write(SystemUtils.ToByteArray(temp_sbyteArray3), 0, temp_sbyteArray3.Length);\n\n            break;\n\n          case MODE_KANJI:\n            //canvas.println(\"Mode: Kanji\");\n            //sbyte[] temp_sbyteArray4;\n            //temp_sbyteArray4 = SystemUtils.ToSByteArray(SystemUtils.ToByteArray(getKanjiString(dataLength)));\n            //output.Write(SystemUtils.ToByteArray(temp_sbyteArray4), 0, temp_sbyteArray4.Length);\n            var\n            /** @type {?} */\n            temp_str = this.getKanjiString(dataLength);\n            output.push(temp_str);\n            break;\n        } //\n        //canvas.println(\"DataLength: \" + dataLength);\n        //Console.out.println(dataString);\n\n      } while (true);\n\n      return output;\n    }\n  }]);\n\n  return QRCodeDataBlockReader;\n}();\n\nQRCodeDataBlockReader.sizeOfDataLengthInfo = [[10, 9, 8, 8], [12, 11, 16, 10], [14, 13, 16, 12]];\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/*\n  Ported to JavaScript by Lazar Laszlo 2011\n  lazarsoft@gmail.com, www.lazarsoft.info\n*/\n\nvar Decoder = /*#__PURE__*/function () {\n  function Decoder() {\n    _classCallCheck(this, Decoder);\n\n    this.rsDecoder = new ReedSolomonDecoder(GF256.QR_CODE_FIELD);\n\n    this.decode = function (bits) {\n      var\n      /** @type {?} */\n      parser = new BitMatrixParser(bits);\n      var\n      /** @type {?} */\n      version = parser.readVersion();\n      var\n      /** @type {?} */\n      ecLevel = parser.readFormatInformation().ErrorCorrectionLevel; // Read codewords\n\n      var\n      /** @type {?} */\n      codewords = parser.readCodewords(); // Separate into data blocks\n\n      var\n      /** @type {?} */\n      dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel); // Count total number of data bytes\n\n      var\n      /** @type {?} */\n      totalBytes = 0;\n\n      for (var\n      /** @type {?} */\n      i = 0; i < dataBlocks.length; i++) {\n        totalBytes += dataBlocks[i].NumDataCodewords;\n      }\n\n      var\n      /** @type {?} */\n      resultBytes = new Array(totalBytes);\n      var\n      /** @type {?} */\n      resultOffset = 0; // Error-correct and copy data blocks together into a stream of bytes\n\n      for (var\n      /** @type {?} */\n      j = 0; j < dataBlocks.length; j++) {\n        var\n        /** @type {?} */\n        dataBlock = dataBlocks[j];\n        var\n        /** @type {?} */\n        codewordBytes = dataBlock.Codewords;\n        var\n        /** @type {?} */\n        numDataCodewords = dataBlock.NumDataCodewords;\n        this.correctErrors(codewordBytes, numDataCodewords);\n\n        for (var\n        /** @type {?} */\n        i = 0; i < numDataCodewords; i++) {\n          resultBytes[resultOffset++] = codewordBytes[i];\n        }\n      } // Decode the contents of that stream of bytes\n\n\n      var\n      /** @type {?} */\n      reader = new QRCodeDataBlockReader(resultBytes, version.VersionNumber, ecLevel.Bits);\n      return reader; //return DecodedBitStreamParser.decode(resultBytes, version, ecLevel);\n    };\n  }\n  /**\n   * @param {?} codewordBytes\n   * @param {?} numDataCodewords\n   * @return {?}\n   */\n\n\n  _createClass(Decoder, [{\n    key: \"correctErrors\",\n    value: function correctErrors(codewordBytes, numDataCodewords) {\n      var\n      /** @type {?} */\n      numCodewords = codewordBytes.length; // First read into an array of ints\n\n      var\n      /** @type {?} */\n      codewordsInts = new Array(numCodewords);\n\n      for (var\n      /** @type {?} */\n      i = 0; i < numCodewords; i++) {\n        codewordsInts[i] = codewordBytes[i] & 0xFF;\n      }\n\n      var\n      /** @type {?} */\n      numECCodewords = codewordBytes.length - numDataCodewords;\n\n      try {\n        this.rsDecoder.decode(codewordsInts, numECCodewords); //var corrector = new ReedSolomon(codewordsInts, numECCodewords);\n        //corrector.correct();\n      } catch (\n      /** @type {?} */\n      rse) {\n        throw rse;\n      } // Copy back into array of bytes -- only need to worry about the bytes that were data\n      // We don't care about errors in the error-correction codewords\n\n\n      for (var\n      /** @type {?} */\n      i = 0; i < numDataCodewords; i++) {\n        codewordBytes[i] = codewordsInts[i];\n      }\n    }\n  }]);\n\n  return Decoder;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar QRCode = /*#__PURE__*/function () {\n  function QRCode() {\n    _classCallCheck(this, QRCode);\n\n    this.debug = false;\n    this.maxImgSize = 1024 * 1024;\n    this.sizeOfDataLengthInfo = [[10, 9, 8, 8], [12, 11, 16, 10], [14, 13, 16, 12]];\n  }\n  /**\n   * @param {?} canvas\n   * @return {?}\n   */\n\n\n  _createClass(QRCode, [{\n    key: \"decode\",\n    value: function decode(canvas) {\n      var\n      /** @type {?} */\n      context = canvas.getContext('2d');\n      this.width = canvas.width;\n      this.height = canvas.height;\n      this.imagedata = context.getImageData(0, 0, this.width, this.height);\n      this.result = this.process(context);\n      if (this.myCallback != null) this.myCallback(this.result);\n      return this.result;\n    }\n    /**\n     * @param {?} context\n     * @return {?}\n     */\n\n  }, {\n    key: \"process\",\n    value: function process(context) {\n      var\n      /** @type {?} */\n      start = new Date().getTime();\n      var\n      /** @type {?} */\n      image = this.grayScaleToBitmap(this.grayscale());\n\n      if (this.debug) {\n        for (var\n        /** @type {?} */\n        y = 0; y < this.height; y++) {\n          for (var\n          /** @type {?} */\n          x = 0; x < this.width; x++) {\n            var\n            /** @type {?} */\n            point = x * 4 + y * this.width * 4;\n            this.imagedata.data[point] = image[x + y * this.width] ? 0 : 0;\n            this.imagedata.data[point + 1] = image[x + y * this.width] ? 0 : 0;\n            this.imagedata.data[point + 2] = image[x + y * this.width] ? 255 : 0;\n          }\n        }\n\n        context.putImageData(this.imagedata, 0, 0);\n      }\n\n      var\n      /** @type {?} */\n      detector = new Detector(image, this.imagedata, this.width, this.height);\n      var\n      /** @type {?} */\n      qRCodeMatrix = detector.detect();\n      if (this.debug) context.putImageData(this.imagedata, 0, 0);\n      var\n      /** @type {?} */\n      decoder = new Decoder();\n      var\n      /** @type {?} */\n      reader = decoder.decode(qRCodeMatrix.bits);\n      var\n      /** @type {?} */\n      data = reader.DataByte;\n      var\n      /** @type {?} */\n      str = \"\";\n\n      for (var\n      /** @type {?} */\n      i = 0; i < data.length; i++) {\n        for (var\n        /** @type {?} */\n        j = 0; j < data[i].length; j++) {\n          str += String.fromCharCode(data[i][j]);\n        }\n      }\n\n      var\n      /** @type {?} */\n      end = new Date().getTime();\n      var\n      /** @type {?} */\n      time = end - start;\n      console.log(time);\n      return str;\n    }\n    /**\n     * @param {?} grayScale\n     * @return {?}\n     */\n\n  }, {\n    key: \"grayScaleToBitmap\",\n    value: function grayScaleToBitmap(grayScale) {\n      var\n      /** @type {?} */\n      middle = this.getMiddleBrightnessPerArea(grayScale);\n      var\n      /** @type {?} */\n      sqrtNumArea = middle.length;\n      var\n      /** @type {?} */\n      areaWidth = Math.floor(this.width / sqrtNumArea);\n      var\n      /** @type {?} */\n      areaHeight = Math.floor(this.height / sqrtNumArea);\n      var\n      /** @type {?} */\n      bitmap = new Array(this.height * this.width);\n\n      for (var\n      /** @type {?} */\n      ay = 0; ay < sqrtNumArea; ay++) {\n        for (var\n        /** @type {?} */\n        ax = 0; ax < sqrtNumArea; ax++) {\n          for (var\n          /** @type {?} */\n          dy = 0; dy < areaHeight; dy++) {\n            for (var\n            /** @type {?} */\n            dx = 0; dx < areaWidth; dx++) {\n              bitmap[areaWidth * ax + dx + (areaHeight * ay + dy) * this.width] = grayScale[areaWidth * ax + dx + (areaHeight * ay + dy) * this.width] < middle[ax][ay] ? true : false;\n            }\n          }\n        }\n      }\n\n      return bitmap;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"grayscale\",\n    value: function grayscale() {\n      var\n      /** @type {?} */\n      ret = new Array(this.width * this.height);\n\n      for (var\n      /** @type {?} */\n      y = 0; y < this.height; y++) {\n        for (var\n        /** @type {?} */\n        x = 0; x < this.width; x++) {\n          var\n          /** @type {?} */\n          gray = this.getPixel(x, y);\n          ret[x + y * this.width] = gray;\n        }\n      }\n\n      return ret;\n    }\n    /**\n     * @param {?} x\n     * @param {?} y\n     * @return {?}\n     */\n\n  }, {\n    key: \"getPixel\",\n    value: function getPixel(x, y) {\n      if (this.width < x) {\n        throw \"point error\";\n      }\n\n      if (this.height < y) {\n        throw \"point error\";\n      }\n\n      var\n      /** @type {?} */\n      point = x * 4 + y * this.width * 4;\n      var\n      /** @type {?} */\n      p = (this.imagedata.data[point] * 33 + this.imagedata.data[point + 1] * 34 + this.imagedata.data[point + 2] * 33) / 100;\n      return p;\n    }\n    /**\n     * @param {?} image\n     * @return {?}\n     */\n\n  }, {\n    key: \"getMiddleBrightnessPerArea\",\n    value: function getMiddleBrightnessPerArea(image) {\n      var\n      /** @type {?} */\n      numSqrtArea = 4; //obtain middle brightness((min + max) / 2) per area\n\n      var\n      /** @type {?} */\n      areaWidth = Math.floor(this.width / numSqrtArea);\n      var\n      /** @type {?} */\n      areaHeight = Math.floor(this.height / numSqrtArea);\n      var\n      /** @type {?} */\n      minmax = new Array(numSqrtArea);\n\n      for (var\n      /** @type {?} */\n      i = 0; i < numSqrtArea; i++) {\n        minmax[i] = new Array(numSqrtArea);\n\n        for (var\n        /** @type {?} */\n        i2 = 0; i2 < numSqrtArea; i2++) {\n          minmax[i][i2] = new Array(0, 0);\n        }\n      }\n\n      for (var\n      /** @type {?} */\n      ay = 0; ay < numSqrtArea; ay++) {\n        for (var\n        /** @type {?} */\n        ax = 0; ax < numSqrtArea; ax++) {\n          minmax[ax][ay][0] = 0xFF;\n\n          for (var\n          /** @type {?} */\n          dy = 0; dy < areaHeight; dy++) {\n            for (var\n            /** @type {?} */\n            dx = 0; dx < areaWidth; dx++) {\n              var\n              /** @type {?} */\n              target = image[areaWidth * ax + dx + (areaHeight * ay + dy) * this.width];\n              if (target < minmax[ax][ay][0]) minmax[ax][ay][0] = target;\n              if (target > minmax[ax][ay][1]) minmax[ax][ay][1] = target;\n            }\n          } //minmax[ax][ay][0] = (minmax[ax][ay][0] + minmax[ax][ay][1]) / 2;\n\n        }\n      }\n\n      var\n      /** @type {?} */\n      middle = new Array(numSqrtArea);\n\n      for (var\n      /** @type {?} */\n      i3 = 0; i3 < numSqrtArea; i3++) {\n        middle[i3] = new Array(numSqrtArea);\n      }\n\n      for (var\n      /** @type {?} */\n      ay = 0; ay < numSqrtArea; ay++) {\n        for (var\n        /** @type {?} */\n        ax = 0; ax < numSqrtArea; ax++) {\n          middle[ax][ay] = Math.floor((minmax[ax][ay][0] + minmax[ax][ay][1]) / 2); //Console.out.print(middle[ax][ay] + \",\");\n        } //Console.out.println(\"\");\n\n      } //Console.out.println(\"\");\n\n\n      return middle;\n    }\n  }]);\n\n  return QRCode;\n}(); //\n//\n// Array.prototype.remove = function(from, to) {\n//   var rest = this.slice((to || from) + 1 || this.length);\n//   this.length = from < 0 ? this.length + from : from;\n//   return this.push.apply(this, rest);\n// };\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar QrScannerComponent = /*#__PURE__*/function () {\n  /**\n   * @param {?} renderer\n   */\n  function QrScannerComponent(renderer) {\n    _classCallCheck(this, QrScannerComponent);\n\n    this.renderer = renderer;\n    this.canvasWidth = 640;\n    this.canvasHeight = 480;\n    this.debug = false;\n    this.stopAfterScan = true;\n    this.updateTime = 500;\n    this.capturedQr = new EventEmitter();\n    this.foundCameras = new EventEmitter();\n    this.chooseCamera = new Subject();\n    this.canvasHidden = true;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(QrScannerComponent, [{\n    key: \"isCanvasSupported\",\n    get: function get() {\n      var\n      /** @type {?} */\n      canvas = this.renderer.createElement('canvas');\n      return !!(canvas.getContext && canvas.getContext('2d'));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {}\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.chooseCamera$.unsubscribe();\n      this.stopScanning();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngAfterViewInit\",\n    value: function ngAfterViewInit() {\n      var _this = this;\n\n      if (this.debug) console.log('[QrScanner] ViewInit, isSupported: ', this.isCanvasSupported);\n\n      if (this.isCanvasSupported) {\n        this.gCtx = this.qrCanvas.nativeElement.getContext('2d');\n        this.gCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n        this.qrCode = new QRCode();\n        if (this.debug) this.qrCode.debug = true;\n\n        this.qrCode.myCallback = function (decoded) {\n          return _this.QrDecodeCallback(decoded);\n        };\n      }\n\n      this.chooseCamera$ = this.chooseCamera.subscribe(function (camera) {\n        return _this.useDevice(camera);\n      });\n      this.getMediaDevices().then(function (devices) {\n        return _this.foundCameras.next(devices);\n      });\n    }\n    /**\n     * @param {?} device\n     * @return {?}\n     */\n\n  }, {\n    key: \"startScanning\",\n    value: function startScanning(device) {\n      this.useDevice(device);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"stopScanning\",\n    value: function stopScanning() {\n      if (this.captureTimeout) {\n        clearTimeout(this.captureTimeout);\n        this.captureTimeout = 0;\n      }\n\n      this.canvasHidden = false;\n      var\n      /** @type {?} */\n      stream = this.stream && this.stream.getTracks().length && this.stream;\n\n      if (stream) {\n        stream.getTracks().forEach(function (track) {\n          return track.enabled && track.stop();\n        });\n        this.stream = null;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"getMediaDevices\",\n    value: function getMediaDevices() {\n      var _this2 = this;\n\n      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return Promise.resolve([]);\n      return navigator.mediaDevices.enumerateDevices().then(function (devices) {\n        return devices;\n      }).catch(function (error) {\n        if (_this2.debug) console.warn('Error', error);\n        return [];\n      });\n    }\n    /**\n     * @param {?} decoded\n     * @return {?}\n     */\n\n  }, {\n    key: \"QrDecodeCallback\",\n    value: function QrDecodeCallback(decoded) {\n      var _this3 = this;\n\n      if (this.stopAfterScan) {\n        this.stopScanning();\n        this.capturedQr.next(decoded);\n      } else {\n        this.capturedQr.next(decoded);\n        this.captureTimeout = setTimeout(function () {\n          return _this3.captureToCanvas();\n        }, this.updateTime);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"captureToCanvas\",\n    value: function captureToCanvas() {\n      var _this4 = this;\n\n      try {\n        this.gCtx.drawImage(this.videoElement, 0, 0, this.canvasWidth, this.canvasHeight);\n        this.qrCode.decode(this.qrCanvas.nativeElement);\n      } catch (\n      /** @type {?} */\n      e) {\n        if (this.debug) console.log('[QrScanner] Thrown', e);\n        if (!this.stream) return;\n        this.captureTimeout = setTimeout(function () {\n          return _this4.captureToCanvas();\n        }, this.updateTime);\n      }\n    }\n    /**\n     * @param {?} stream\n     * @return {?}\n     */\n\n  }, {\n    key: \"setStream\",\n    value: function setStream(stream) {\n      var _this5 = this;\n\n      this.canvasHidden = true;\n      this.gCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n      this.stream = stream;\n      this.videoElement.srcObject = stream;\n      this.captureTimeout = setTimeout(function () {\n        return _this5.captureToCanvas();\n      }, this.updateTime);\n    }\n    /**\n     * @param {?} _device\n     * @return {?}\n     */\n\n  }, {\n    key: \"useDevice\",\n    value: function useDevice(_device) {\n      var\n      /** @type {?} */\n      _navigator = navigator;\n\n      if (this.captureTimeout) {\n        this.stopScanning();\n      }\n\n      if (!this.videoElement) {\n        this.videoElement = this.renderer.createElement('video');\n        this.videoElement.setAttribute('autoplay', 'true');\n        this.videoElement.setAttribute('muted', 'true');\n        this.renderer.appendChild(this.videoWrapper.nativeElement, this.videoElement);\n      }\n\n      var\n      /** @type {?} */\n      self = this;\n      var\n      /** @type {?} */\n      constraints;\n\n      if (_device) {\n        constraints = {\n          audio: false,\n          video: {\n            deviceId: _device.deviceId\n          }\n        };\n      } else {\n        constraints = {\n          audio: false,\n          video: true\n        };\n      }\n\n      _navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\n        self.setStream(stream);\n      }).catch(function (err) {\n        return self.debug && console.warn('Error', err);\n      });\n    }\n  }]);\n\n  return QrScannerComponent;\n}();\n\nQrScannerComponent.ɵfac = function QrScannerComponent_Factory(t) {\n  return new (t || QrScannerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n};\n\nQrScannerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: QrScannerComponent,\n  selectors: [[\"qr-scanner\"]],\n  viewQuery: function QrScannerComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c0, 5);\n      ɵngcc0.ɵɵviewQuery(_c1, 5);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.videoWrapper = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.qrCanvas = _t.first);\n    }\n  },\n  inputs: {\n    canvasWidth: \"canvasWidth\",\n    canvasHeight: \"canvasHeight\",\n    debug: \"debug\",\n    stopAfterScan: \"stopAfterScan\",\n    updateTime: \"updateTime\",\n    chooseCamera: \"chooseCamera\"\n  },\n  outputs: {\n    capturedQr: \"capturedQr\",\n    foundCameras: \"foundCameras\"\n  },\n  decls: 3,\n  vars: 2,\n  consts: [[3, \"ngSwitch\"], [4, \"ngSwitchDefault\"], [4, \"ngSwitchCase\"], [3, \"hidden\", \"width\", \"height\"], [\"qrCanvas\", \"\"], [\"videoWrapper\", \"\"], [\"href\", \"http://browsehappy.com/\"]],\n  template: function QrScannerComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵelementContainerStart(0, 0);\n      ɵngcc0.ɵɵtemplate(1, QrScannerComponent_ng_container_1_Template, 5, 7, \"ng-container\", 1);\n      ɵngcc0.ɵɵtemplate(2, QrScannerComponent_ng_container_2_Template, 9, 0, \"ng-container\", 2);\n      ɵngcc0.ɵɵelementContainerEnd();\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵproperty(\"ngSwitch\", ctx.isCanvasSupported);\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"ngSwitchCase\", false);\n    }\n  },\n  directives: [ɵngcc1.NgSwitch, ɵngcc1.NgSwitchDefault, ɵngcc1.NgSwitchCase],\n  styles: [\"[_nghost-%COMP%]   video[_ngcontent-%COMP%] {height: auto; width: 100%;}\", \"[_nghost-%COMP%]   .mirrored[_ngcontent-%COMP%] { transform: rotateY(180deg); -webkit-transform:rotateY(180deg); -moz-transform:rotateY(180deg); }\", \"[_nghost-%COMP%] {}\"]\n});\n/** @nocollapse */\n\nQrScannerComponent.ctorParameters = function () {\n  return [{\n    type: Renderer2\n  }];\n};\n\nQrScannerComponent.propDecorators = {\n  \"canvasWidth\": [{\n    type: Input\n  }],\n  \"canvasHeight\": [{\n    type: Input\n  }],\n  \"debug\": [{\n    type: Input\n  }],\n  \"stopAfterScan\": [{\n    type: Input\n  }],\n  \"updateTime\": [{\n    type: Input\n  }],\n  \"capturedQr\": [{\n    type: Output\n  }],\n  \"foundCameras\": [{\n    type: Output\n  }],\n  \"videoWrapper\": [{\n    type: ViewChild,\n    args: ['videoWrapper']\n  }],\n  \"qrCanvas\": [{\n    type: ViewChild,\n    args: ['qrCanvas']\n  }],\n  \"chooseCamera\": [{\n    type: Input\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(QrScannerComponent, [{\n    type: Component,\n    args: [{\n      selector: 'qr-scanner',\n      styles: [':host video {height: auto; width: 100%;}', ':host .mirrored { transform: rotateY(180deg); -webkit-transform:rotateY(180deg); -moz-transform:rotateY(180deg); }', ':host {}'],\n      template: \"\\n        <ng-container [ngSwitch]=\\\"isCanvasSupported\\\">\\n            <ng-container *ngSwitchDefault>\\n                <canvas #qrCanvas [hidden]=\\\"canvasHidden\\\" [width]=\\\"canvasWidth\\\" [height]=\\\"canvasHeight\\\"></canvas>\\n                <div #videoWrapper [style.width]=\\\"canvasWidth\\\" [style.height]=\\\"canvasHeight\\\"></div>\\n            </ng-container>\\n            <ng-container *ngSwitchCase=\\\"false\\\">\\n                <p>\\n                    You are using an <strong>outdated</strong> browser.\\n                    Please <a href=\\\"http://browsehappy.com/\\\">upgrade your browser</a> to improve your experience.\\n                </p>\\n            </ng-container>\\n        </ng-container>\"\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.Renderer2\n    }];\n  }, {\n    canvasWidth: [{\n      type: Input\n    }],\n    canvasHeight: [{\n      type: Input\n    }],\n    debug: [{\n      type: Input\n    }],\n    stopAfterScan: [{\n      type: Input\n    }],\n    updateTime: [{\n      type: Input\n    }],\n    capturedQr: [{\n      type: Output\n    }],\n    foundCameras: [{\n      type: Output\n    }],\n    chooseCamera: [{\n      type: Input\n    }],\n    videoWrapper: [{\n      type: ViewChild,\n      args: ['videoWrapper']\n    }],\n    qrCanvas: [{\n      type: ViewChild,\n      args: ['qrCanvas']\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar NgQrScannerModule = /*#__PURE__*/function () {\n  function NgQrScannerModule() {\n    _classCallCheck(this, NgQrScannerModule);\n  }\n\n  _createClass(NgQrScannerModule, null, [{\n    key: \"forRoot\",\n    value:\n    /**\n     * @return {?}\n     */\n    function forRoot() {\n      return {\n        ngModule: NgQrScannerModule\n      };\n    }\n  }]);\n\n  return NgQrScannerModule;\n}();\n\nNgQrScannerModule.ɵfac = function NgQrScannerModule_Factory(t) {\n  return new (t || NgQrScannerModule)();\n};\n\nNgQrScannerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: NgQrScannerModule\n});\nNgQrScannerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n  imports: [[CommonModule]]\n});\n/** @nocollapse */\n\nNgQrScannerModule.ctorParameters = function () {\n  return [];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgQrScannerModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [QrScannerComponent],\n      exports: [QrScannerComponent]\n    }]\n  }], null, null);\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgQrScannerModule, {\n    declarations: function declarations() {\n      return [QrScannerComponent];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [QrScannerComponent];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NgQrScannerModule, QrScannerComponent }; //# sourceMappingURL=angular2-qrscanner.js.map","map":null,"metadata":{},"sourceType":"module"}