{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  var plugins = Chart.plugins;\n  var platform = Chart.platform; // Create a dictionary of chart types, to allow for extension of existing types\n\n  Chart.types = {}; // Store a reference to each instance - allowing us to globally resize chart instances on window resize.\n  // Destroy method on the chart will remove the instance of the chart from this reference.\n\n  Chart.instances = {}; // Controllers available for dataset visualization eg. bar, line, slice, etc.\n\n  Chart.controllers = {};\n  /**\n   * Initializes the given config with global and chart default values.\n   */\n\n  function initConfig(config) {\n    config = config || {}; // Do NOT use configMerge() for the data object because this method merges arrays\n    // and so would change references to labels and datasets, preventing data updates.\n\n    var data = config.data = config.data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    config.options = helpers.configMerge(Chart.defaults.global, Chart.defaults[config.type], config.options || {});\n    return config;\n  }\n  /**\n   * Updates the config of the chart\n   * @param chart {Chart.Controller} chart to update the options for\n   */\n\n\n  function updateConfig(chart) {\n    var newOptions = chart.options; // Update Scale(s) with options\n\n    if (newOptions.scale) {\n      chart.scale.options = newOptions.scale;\n    } else if (newOptions.scales) {\n      newOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function (scaleOptions) {\n        chart.scales[scaleOptions.id].options = scaleOptions;\n      });\n    } // Tooltip\n\n\n    chart.tooltip._options = newOptions.tooltips;\n  }\n  /**\n   * @class Chart.Controller\n   * The main controller of a chart.\n   */\n\n\n  Chart.Controller = function (item, config, instance) {\n    var me = this;\n    config = initConfig(config);\n    var context = platform.acquireContext(item, config);\n    var canvas = context && context.canvas;\n    var height = canvas && canvas.height;\n    var width = canvas && canvas.width;\n    instance.ctx = context;\n    instance.canvas = canvas;\n    instance.config = config;\n    instance.width = width;\n    instance.height = height;\n    instance.aspectRatio = height ? width / height : null;\n    me.id = helpers.uid();\n    me.chart = instance;\n    me.config = config;\n    me.options = config.options;\n    me._bufferedRender = false; // Add the chart instance to the global namespace\n\n    Chart.instances[me.id] = me;\n    Object.defineProperty(me, 'data', {\n      get: function get() {\n        return me.config.data;\n      }\n    });\n\n    if (!context || !canvas) {\n      // The given item is not a compatible context2d element, let's return before finalizing\n      // the chart initialization but after setting basic chart / controller properties that\n      // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n      // https://github.com/chartjs/Chart.js/issues/2807\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return me;\n    }\n\n    me.initialize();\n    me.update();\n    return me;\n  };\n\n  helpers.extend(Chart.Controller.prototype,\n  /** @lends Chart.Controller.prototype */\n  {\n    initialize: function initialize() {\n      var me = this; // Before init plugin notification\n\n      plugins.notify(me, 'beforeInit');\n      helpers.retinaScale(me.chart);\n      me.bindEvents();\n\n      if (me.options.responsive) {\n        // Initial resize before chart draws (must be silent to preserve initial animations).\n        me.resize(true);\n      } // Make sure scales have IDs and are built before we build any controllers.\n\n\n      me.ensureScalesHaveIDs();\n      me.buildScales();\n      me.initToolTip(); // After init plugin notification\n\n      plugins.notify(me, 'afterInit');\n      return me;\n    },\n    clear: function clear() {\n      helpers.clear(this.chart);\n      return this;\n    },\n    stop: function stop() {\n      // Stops any current animation loop occurring\n      Chart.animationService.cancelAnimation(this);\n      return this;\n    },\n    resize: function resize(silent) {\n      var me = this;\n      var chart = me.chart;\n      var options = me.options;\n      var canvas = chart.canvas;\n      var aspectRatio = options.maintainAspectRatio && chart.aspectRatio || null; // the canvas render width and height will be casted to integers so make sure that\n      // the canvas display style uses the same integer values to avoid blurring effect.\n\n      var newWidth = Math.floor(helpers.getMaximumWidth(canvas));\n      var newHeight = Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas));\n\n      if (chart.width === newWidth && chart.height === newHeight) {\n        return;\n      }\n\n      canvas.width = chart.width = newWidth;\n      canvas.height = chart.height = newHeight;\n      canvas.style.width = newWidth + 'px';\n      canvas.style.height = newHeight + 'px';\n      helpers.retinaScale(chart);\n\n      if (!silent) {\n        // Notify any plugins about the resize\n        var newSize = {\n          width: newWidth,\n          height: newHeight\n        };\n        plugins.notify(me, 'resize', [newSize]); // Notify of resize\n\n        if (me.options.onResize) {\n          me.options.onResize(me, newSize);\n        }\n\n        me.stop();\n        me.update(me.options.responsiveAnimationDuration);\n      }\n    },\n    ensureScalesHaveIDs: function ensureScalesHaveIDs() {\n      var options = this.options;\n      var scalesOptions = options.scales || {};\n      var scaleOptions = options.scale;\n      helpers.each(scalesOptions.xAxes, function (xAxisOptions, index) {\n        xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;\n      });\n      helpers.each(scalesOptions.yAxes, function (yAxisOptions, index) {\n        yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;\n      });\n\n      if (scaleOptions) {\n        scaleOptions.id = scaleOptions.id || 'scale';\n      }\n    },\n\n    /**\n     * Builds a map of scale ID to scale object for future lookup.\n     */\n    buildScales: function buildScales() {\n      var me = this;\n      var options = me.options;\n      var scales = me.scales = {};\n      var items = [];\n\n      if (options.scales) {\n        items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {\n          return {\n            options: xAxisOptions,\n            dtype: 'category'\n          };\n        }), (options.scales.yAxes || []).map(function (yAxisOptions) {\n          return {\n            options: yAxisOptions,\n            dtype: 'linear'\n          };\n        }));\n      }\n\n      if (options.scale) {\n        items.push({\n          options: options.scale,\n          dtype: 'radialLinear',\n          isDefault: true\n        });\n      }\n\n      helpers.each(items, function (item) {\n        var scaleOptions = item.options;\n        var scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);\n        var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);\n\n        if (!scaleClass) {\n          return;\n        }\n\n        var scale = new scaleClass({\n          id: scaleOptions.id,\n          options: scaleOptions,\n          ctx: me.chart.ctx,\n          chart: me\n        });\n        scales[scale.id] = scale; // TODO(SB): I think we should be able to remove this custom case (options.scale)\n        // and consider it as a regular scale part of the \"scales\"\" map only! This would\n        // make the logic easier and remove some useless? custom code.\n\n        if (item.isDefault) {\n          me.scale = scale;\n        }\n      });\n      Chart.scaleService.addScalesToLayout(this);\n    },\n    buildOrUpdateControllers: function buildOrUpdateControllers() {\n      var me = this;\n      var types = [];\n      var newControllers = [];\n      helpers.each(me.data.datasets, function (dataset, datasetIndex) {\n        var meta = me.getDatasetMeta(datasetIndex);\n\n        if (!meta.type) {\n          meta.type = dataset.type || me.config.type;\n        }\n\n        types.push(meta.type);\n\n        if (meta.controller) {\n          meta.controller.updateIndex(datasetIndex);\n        } else {\n          meta.controller = new Chart.controllers[meta.type](me, datasetIndex);\n          newControllers.push(meta.controller);\n        }\n      }, me);\n\n      if (types.length > 1) {\n        for (var i = 1; i < types.length; i++) {\n          if (types[i] !== types[i - 1]) {\n            me.isCombo = true;\n            break;\n          }\n        }\n      }\n\n      return newControllers;\n    },\n\n    /**\n     * Reset the elements of all datasets\n     * @private\n     */\n    resetElements: function resetElements() {\n      var me = this;\n      helpers.each(me.data.datasets, function (dataset, datasetIndex) {\n        me.getDatasetMeta(datasetIndex).controller.reset();\n      }, me);\n    },\n\n    /**\n    * Resets the chart back to it's state before the initial animation\n    */\n    reset: function reset() {\n      this.resetElements();\n      this.tooltip.initialize();\n    },\n    update: function update(animationDuration, lazy) {\n      var me = this;\n      updateConfig(me);\n\n      if (plugins.notify(me, 'beforeUpdate') === false) {\n        return;\n      } // In case the entire data object changed\n\n\n      me.tooltip._data = me.data; // Make sure dataset controllers are updated and new controllers are reset\n\n      var newControllers = me.buildOrUpdateControllers(); // Make sure all dataset controllers have correct meta data counts\n\n      helpers.each(me.data.datasets, function (dataset, datasetIndex) {\n        me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\n      }, me);\n      me.updateLayout(); // Can only reset the new controllers after the scales have been updated\n\n      helpers.each(newControllers, function (controller) {\n        controller.reset();\n      });\n      me.updateDatasets(); // Do this before render so that any plugins that need final scale updates can use it\n\n      plugins.notify(me, 'afterUpdate');\n\n      if (me._bufferedRender) {\n        me._bufferedRequest = {\n          lazy: lazy,\n          duration: animationDuration\n        };\n      } else {\n        me.render(animationDuration, lazy);\n      }\n    },\n\n    /**\n     * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n     * hook, in which case, plugins will not be called on `afterLayout`.\n     * @private\n     */\n    updateLayout: function updateLayout() {\n      var me = this;\n\n      if (plugins.notify(me, 'beforeLayout') === false) {\n        return;\n      }\n\n      Chart.layoutService.update(this, this.chart.width, this.chart.height);\n      /**\n       * Provided for backward compatibility, use `afterLayout` instead.\n       * @method IPlugin#afterScaleUpdate\n       * @deprecated since version 2.5.0\n       * @todo remove at version 3\n       */\n\n      plugins.notify(me, 'afterScaleUpdate');\n      plugins.notify(me, 'afterLayout');\n    },\n\n    /**\n     * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n     * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n     * @private\n     */\n    updateDatasets: function updateDatasets() {\n      var me = this;\n\n      if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n        return;\n      }\n\n      for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n        me.getDatasetMeta(i).controller.update();\n      }\n\n      plugins.notify(me, 'afterDatasetsUpdate');\n    },\n    render: function render(duration, lazy) {\n      var me = this;\n\n      if (plugins.notify(me, 'beforeRender') === false) {\n        return;\n      }\n\n      var animationOptions = me.options.animation;\n\n      var onComplete = function onComplete() {\n        plugins.notify(me, 'afterRender');\n        var callback = animationOptions && animationOptions.onComplete;\n\n        if (callback && callback.call) {\n          callback.call(me);\n        }\n      };\n\n      if (animationOptions && (typeof duration !== 'undefined' && duration !== 0 || typeof duration === 'undefined' && animationOptions.duration !== 0)) {\n        var animation = new Chart.Animation();\n        animation.numSteps = (duration || animationOptions.duration) / 16.66; // 60 fps\n\n        animation.easing = animationOptions.easing; // render function\n\n        animation.render = function (chartInstance, animationObject) {\n          var easingFunction = helpers.easingEffects[animationObject.easing];\n          var stepDecimal = animationObject.currentStep / animationObject.numSteps;\n          var easeDecimal = easingFunction(stepDecimal);\n          chartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep);\n        }; // user events\n\n\n        animation.onAnimationProgress = animationOptions.onProgress;\n        animation.onAnimationComplete = onComplete;\n        Chart.animationService.addAnimation(me, animation, duration, lazy);\n      } else {\n        me.draw();\n        onComplete();\n      }\n\n      return me;\n    },\n    draw: function draw(easingValue) {\n      var me = this;\n      me.clear();\n\n      if (easingValue === undefined || easingValue === null) {\n        easingValue = 1;\n      }\n\n      if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n        return;\n      } // Draw all the scales\n\n\n      helpers.each(me.boxes, function (box) {\n        box.draw(me.chartArea);\n      }, me);\n\n      if (me.scale) {\n        me.scale.draw();\n      }\n\n      me.drawDatasets(easingValue); // Finally draw the tooltip\n\n      me.tooltip.transition(easingValue).draw();\n      plugins.notify(me, 'afterDraw', [easingValue]);\n    },\n\n    /**\n     * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n     * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n     * @private\n     */\n    drawDatasets: function drawDatasets(easingValue) {\n      var me = this;\n\n      if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n        return;\n      } // Draw each dataset via its respective controller (reversed to support proper line stacking)\n\n\n      helpers.each(me.data.datasets, function (dataset, datasetIndex) {\n        if (me.isDatasetVisible(datasetIndex)) {\n          me.getDatasetMeta(datasetIndex).controller.draw(easingValue);\n        }\n      }, me, true);\n      plugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n    },\n    // Get the single element that was clicked on\n    // @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\n    getElementAtEvent: function getElementAtEvent(e) {\n      return Chart.Interaction.modes.single(this, e);\n    },\n    getElementsAtEvent: function getElementsAtEvent(e) {\n      return Chart.Interaction.modes.label(this, e, {\n        intersect: true\n      });\n    },\n    getElementsAtXAxis: function getElementsAtXAxis(e) {\n      return Chart.Interaction.modes['x-axis'](this, e, {\n        intersect: true\n      });\n    },\n    getElementsAtEventForMode: function getElementsAtEventForMode(e, mode, options) {\n      var method = Chart.Interaction.modes[mode];\n\n      if (typeof method === 'function') {\n        return method(this, e, options);\n      }\n\n      return [];\n    },\n    getDatasetAtEvent: function getDatasetAtEvent(e) {\n      return Chart.Interaction.modes.dataset(this, e, {\n        intersect: true\n      });\n    },\n    getDatasetMeta: function getDatasetMeta(datasetIndex) {\n      var me = this;\n      var dataset = me.data.datasets[datasetIndex];\n\n      if (!dataset._meta) {\n        dataset._meta = {};\n      }\n\n      var meta = dataset._meta[me.id];\n\n      if (!meta) {\n        meta = dataset._meta[me.id] = {\n          type: null,\n          data: [],\n          dataset: null,\n          controller: null,\n          hidden: null,\n          // See isDatasetVisible() comment\n          xAxisID: null,\n          yAxisID: null\n        };\n      }\n\n      return meta;\n    },\n    getVisibleDatasetCount: function getVisibleDatasetCount() {\n      var count = 0;\n\n      for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n        if (this.isDatasetVisible(i)) {\n          count++;\n        }\n      }\n\n      return count;\n    },\n    isDatasetVisible: function isDatasetVisible(datasetIndex) {\n      var meta = this.getDatasetMeta(datasetIndex); // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n      // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n\n      return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n    },\n    generateLegend: function generateLegend() {\n      return this.options.legendCallback(this);\n    },\n    destroy: function destroy() {\n      var me = this;\n      var canvas = me.chart.canvas;\n      var meta, i, ilen;\n      me.stop(); // dataset controllers need to cleanup associated data\n\n      for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n        meta = me.getDatasetMeta(i);\n\n        if (meta.controller) {\n          meta.controller.destroy();\n          meta.controller = null;\n        }\n      }\n\n      if (canvas) {\n        me.unbindEvents();\n        helpers.clear(me.chart);\n        platform.releaseContext(me.chart.ctx);\n        me.chart.canvas = null;\n        me.chart.ctx = null;\n      }\n\n      plugins.notify(me, 'destroy');\n      delete Chart.instances[me.id];\n    },\n    toBase64Image: function toBase64Image() {\n      return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);\n    },\n    initToolTip: function initToolTip() {\n      var me = this;\n      me.tooltip = new Chart.Tooltip({\n        _chart: me.chart,\n        _chartInstance: me,\n        _data: me.data,\n        _options: me.options.tooltips\n      }, me);\n      me.tooltip.initialize();\n    },\n\n    /**\n     * @private\n     */\n    bindEvents: function bindEvents() {\n      var me = this;\n      var listeners = me._listeners = {};\n\n      var listener = function listener() {\n        me.eventHandler.apply(me, arguments);\n      };\n\n      helpers.each(me.options.events, function (type) {\n        platform.addEventListener(me, type, listener);\n        listeners[type] = listener;\n      }); // Responsiveness is currently based on the use of an iframe, however this method causes\n      // performance issues and could be troublesome when used with ad blockers. So make sure\n      // that the user is still able to create a chart without iframe when responsive is false.\n      // See https://github.com/chartjs/Chart.js/issues/2210\n\n      if (me.options.responsive) {\n        listener = function listener() {\n          me.resize();\n        };\n\n        platform.addEventListener(me, 'resize', listener);\n        listeners.resize = listener;\n      }\n    },\n\n    /**\n     * @private\n     */\n    unbindEvents: function unbindEvents() {\n      var me = this;\n      var listeners = me._listeners;\n\n      if (!listeners) {\n        return;\n      }\n\n      delete me._listeners;\n      helpers.each(listeners, function (listener, type) {\n        platform.removeEventListener(me, type, listener);\n      });\n    },\n    updateHoverStyle: function updateHoverStyle(elements, mode, enabled) {\n      var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';\n      var element, i, ilen;\n\n      for (i = 0, ilen = elements.length; i < ilen; ++i) {\n        element = elements[i];\n\n        if (element) {\n          this.getDatasetMeta(element._datasetIndex).controller[method](element);\n        }\n      }\n    },\n\n    /**\n     * @private\n     */\n    eventHandler: function eventHandler(e) {\n      var me = this;\n      var tooltip = me.tooltip;\n\n      if (plugins.notify(me, 'beforeEvent', [e]) === false) {\n        return;\n      } // Buffer any update calls so that renders do not occur\n\n\n      me._bufferedRender = true;\n      me._bufferedRequest = null;\n      var changed = me.handleEvent(e);\n      changed |= tooltip && tooltip.handleEvent(e);\n      plugins.notify(me, 'afterEvent', [e]);\n      var bufferedRequest = me._bufferedRequest;\n\n      if (bufferedRequest) {\n        // If we have an update that was triggered, we need to do a normal render\n        me.render(bufferedRequest.duration, bufferedRequest.lazy);\n      } else if (changed && !me.animating) {\n        // If entering, leaving, or changing elements, animate the change via pivot\n        me.stop(); // We only need to render at this point. Updating will cause scales to be\n        // recomputed generating flicker & using more memory than necessary.\n\n        me.render(me.options.hover.animationDuration, true);\n      }\n\n      me._bufferedRender = false;\n      me._bufferedRequest = null;\n      return me;\n    },\n\n    /**\n     * Handle an event\n     * @private\n     * @param {IEvent} event the event to handle\n     * @return {Boolean} true if the chart needs to re-render\n     */\n    handleEvent: function handleEvent(e) {\n      var me = this;\n      var options = me.options || {};\n      var hoverOptions = options.hover;\n      var changed = false;\n      me.lastActive = me.lastActive || []; // Find Active Elements for hover and tooltips\n\n      if (e.type === 'mouseout') {\n        me.active = [];\n      } else {\n        me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n      } // On Hover hook\n\n\n      if (hoverOptions.onHover) {\n        // Need to call with native event here to not break backwards compatibility\n        hoverOptions.onHover.call(me, e.native, me.active);\n      }\n\n      if (e.type === 'mouseup' || e.type === 'click') {\n        if (options.onClick) {\n          // Use e.native here for backwards compatibility\n          options.onClick.call(me, e.native, me.active);\n        }\n      } // Remove styling for last active (even if it may still be active)\n\n\n      if (me.lastActive.length) {\n        me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n      } // Built in hover styling\n\n\n      if (me.active.length && hoverOptions.mode) {\n        me.updateHoverStyle(me.active, hoverOptions.mode, true);\n      }\n\n      changed = !helpers.arrayEquals(me.active, me.lastActive); // Remember Last Actives\n\n      me.lastActive = me.active;\n      return changed;\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}