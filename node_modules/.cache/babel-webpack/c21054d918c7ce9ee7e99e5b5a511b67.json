{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  var globalDefaults = Chart.defaults.global;\n  Chart.defaults.global.elements.line = {\n    tension: 0.4,\n    backgroundColor: globalDefaults.defaultColor,\n    borderWidth: 3,\n    borderColor: globalDefaults.defaultColor,\n    borderCapStyle: 'butt',\n    borderDash: [],\n    borderDashOffset: 0.0,\n    borderJoinStyle: 'miter',\n    capBezierPoints: true,\n    fill: true // do we fill in the area between the line and its base axis\n\n  };\n  Chart.elements.Line = Chart.Element.extend({\n    draw: function draw() {\n      var me = this;\n      var vm = me._view;\n      var spanGaps = vm.spanGaps;\n      var fillPoint = vm.scaleZero;\n      var loop = me._loop; // Handle different fill modes for cartesian lines\n\n      if (!loop) {\n        if (vm.fill === 'top') {\n          fillPoint = vm.scaleTop;\n        } else if (vm.fill === 'bottom') {\n          fillPoint = vm.scaleBottom;\n        }\n      }\n\n      var ctx = me._chart.ctx;\n      ctx.save(); // Helper function to draw a line to a point\n\n      function lineToPoint(previousPoint, point) {\n        var pointVM = point._view;\n\n        if (point._view.steppedLine === true) {\n          ctx.lineTo(pointVM.x, previousPoint._view.y);\n          ctx.lineTo(pointVM.x, pointVM.y);\n        } else if (point._view.tension === 0) {\n          ctx.lineTo(pointVM.x, pointVM.y);\n        } else {\n          ctx.bezierCurveTo(previousPoint._view.controlPointNextX, previousPoint._view.controlPointNextY, pointVM.controlPointPreviousX, pointVM.controlPointPreviousY, pointVM.x, pointVM.y);\n        }\n      }\n\n      var points = me._children.slice(); // clone array\n\n\n      var lastDrawnIndex = -1; // If we are looping, adding the first point again\n\n      if (loop && points.length) {\n        points.push(points[0]);\n      }\n\n      var index, current, previous, currentVM; // Fill Line\n\n      if (points.length && vm.fill) {\n        ctx.beginPath();\n\n        for (index = 0; index < points.length; ++index) {\n          current = points[index];\n          previous = helpers.previousItem(points, index);\n          currentVM = current._view; // First point moves to it's starting position no matter what\n\n          if (index === 0) {\n            if (loop) {\n              ctx.moveTo(fillPoint.x, fillPoint.y);\n            } else {\n              ctx.moveTo(currentVM.x, fillPoint);\n            }\n\n            if (!currentVM.skip) {\n              lastDrawnIndex = index;\n              ctx.lineTo(currentVM.x, currentVM.y);\n            }\n          } else {\n            previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n            if (currentVM.skip) {\n              // Only do this if this is the first point that is skipped\n              if (!spanGaps && lastDrawnIndex === index - 1) {\n                if (loop) {\n                  ctx.lineTo(fillPoint.x, fillPoint.y);\n                } else {\n                  ctx.lineTo(previous._view.x, fillPoint);\n                }\n              }\n            } else {\n              if (lastDrawnIndex !== index - 1) {\n                // There was a gap and this is the first point after the gap. If we've never drawn a point, this is a special case.\n                // If the first data point is NaN, then there is no real gap to skip\n                if (spanGaps && lastDrawnIndex !== -1) {\n                  // We are spanning the gap, so simple draw a line to this point\n                  lineToPoint(previous, current);\n                } else if (loop) {\n                  ctx.lineTo(currentVM.x, currentVM.y);\n                } else {\n                  ctx.lineTo(currentVM.x, fillPoint);\n                  ctx.lineTo(currentVM.x, currentVM.y);\n                }\n              } else {\n                // Line to next point\n                lineToPoint(previous, current);\n              }\n\n              lastDrawnIndex = index;\n            }\n          }\n        }\n\n        if (!loop && lastDrawnIndex !== -1) {\n          ctx.lineTo(points[lastDrawnIndex]._view.x, fillPoint);\n        }\n\n        ctx.fillStyle = vm.backgroundColor || globalDefaults.defaultColor;\n        ctx.closePath();\n        ctx.fill();\n      } // Stroke Line Options\n\n\n      var globalOptionLineElements = globalDefaults.elements.line;\n      ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash\n\n      if (ctx.setLineDash) {\n        ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n      }\n\n      ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n      ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n      ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n      ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line\n\n      ctx.beginPath();\n      lastDrawnIndex = -1;\n\n      for (index = 0; index < points.length; ++index) {\n        current = points[index];\n        previous = helpers.previousItem(points, index);\n        currentVM = current._view; // First point moves to it's starting position no matter what\n\n        if (index === 0) {\n          if (!currentVM.skip) {\n            ctx.moveTo(currentVM.x, currentVM.y);\n            lastDrawnIndex = index;\n          }\n        } else {\n          previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n          if (!currentVM.skip) {\n            if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {\n              // There was a gap and this is the first point after the gap\n              ctx.moveTo(currentVM.x, currentVM.y);\n            } else {\n              // Line to next point\n              lineToPoint(previous, current);\n            }\n\n            lastDrawnIndex = index;\n          }\n        }\n      }\n\n      ctx.stroke();\n      ctx.restore();\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}