{"ast":null,"code":"'use strict'; // Chart.Platform implementation for targeting a web browser\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers; // DOM event types -> Chart.js event types.\n  // Note: only events with different types are mapped.\n  // https://developer.mozilla.org/en-US/docs/Web/Events\n\n  var eventTypeMap = {\n    // Touch events\n    touchstart: 'mousedown',\n    touchmove: 'mousemove',\n    touchend: 'mouseup',\n    // Pointer events\n    pointerenter: 'mouseenter',\n    pointerdown: 'mousedown',\n    pointermove: 'mousemove',\n    pointerup: 'mouseup',\n    pointerleave: 'mouseout',\n    pointerout: 'mouseout'\n  };\n  /**\n   * The \"used\" size is the final value of a dimension property after all calculations have\n   * been performed. This method uses the computed style of `element` but returns undefined\n   * if the computed style is not expressed in pixels. That can happen in some cases where\n   * `element` has a size relative to its parent and this last one is not yet displayed,\n   * for example because of `display: none` on a parent node.\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n   * @returns {Number} Size in pixels or undefined if unknown.\n   */\n\n  function readUsedSize(element, property) {\n    var value = helpers.getStyle(element, property);\n    var matches = value && value.match(/(\\d+)px/);\n    return matches ? Number(matches[1]) : undefined;\n  }\n  /**\n   * Initializes the canvas style and render size without modifying the canvas display size,\n   * since responsiveness is handled by the controller.resize() method. The config is used\n   * to determine the aspect ratio to apply in case no explicit height has been specified.\n   */\n\n\n  function initCanvas(canvas, config) {\n    var style = canvas.style; // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n    // returns null or '' if no explicit value has been set to the canvas attribute.\n\n    var renderHeight = canvas.getAttribute('height');\n    var renderWidth = canvas.getAttribute('width'); // Chart.js modifies some canvas values that we want to restore on destroy\n\n    canvas._chartjs = {\n      initial: {\n        height: renderHeight,\n        width: renderWidth,\n        style: {\n          display: style.display,\n          height: style.height,\n          width: style.width\n        }\n      }\n    }; // Force canvas to display as block to avoid extra space caused by inline\n    // elements, which would interfere with the responsive resize process.\n    // https://github.com/chartjs/Chart.js/issues/2538\n\n    style.display = style.display || 'block';\n\n    if (renderWidth === null || renderWidth === '') {\n      var displayWidth = readUsedSize(canvas, 'width');\n\n      if (displayWidth !== undefined) {\n        canvas.width = displayWidth;\n      }\n    }\n\n    if (renderHeight === null || renderHeight === '') {\n      if (canvas.style.height === '') {\n        // If no explicit render height and style height, let's apply the aspect ratio,\n        // which one can be specified by the user but also by charts as default option\n        // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n        canvas.height = canvas.width / (config.options.aspectRatio || 2);\n      } else {\n        var displayHeight = readUsedSize(canvas, 'height');\n\n        if (displayWidth !== undefined) {\n          canvas.height = displayHeight;\n        }\n      }\n    }\n\n    return canvas;\n  }\n\n  function createEvent(type, chart, x, y, native) {\n    return {\n      type: type,\n      chart: chart,\n      native: native || null,\n      x: x !== undefined ? x : null,\n      y: y !== undefined ? y : null\n    };\n  }\n\n  function fromNativeEvent(event, chart) {\n    var type = eventTypeMap[event.type] || event.type;\n    var pos = helpers.getRelativePosition(event, chart);\n    return createEvent(type, chart, pos.x, pos.y, event);\n  }\n\n  function createResizer(handler) {\n    var iframe = document.createElement('iframe');\n    iframe.className = 'chartjs-hidden-iframe';\n    iframe.style.cssText = 'display:block;' + 'overflow:hidden;' + 'border:0;' + 'margin:0;' + 'top:0;' + 'left:0;' + 'bottom:0;' + 'right:0;' + 'height:100%;' + 'width:100%;' + 'position:absolute;' + 'pointer-events:none;' + 'z-index:-1;'; // Prevent the iframe to gain focus on tab.\n    // https://github.com/chartjs/Chart.js/issues/3090\n\n    iframe.tabIndex = -1; // If the iframe is re-attached to the DOM, the resize listener is removed because the\n    // content is reloaded, so make sure to install the handler after the iframe is loaded.\n    // https://github.com/chartjs/Chart.js/issues/3521\n\n    helpers.addEvent(iframe, 'load', function () {\n      helpers.addEvent(iframe.contentWindow || iframe, 'resize', handler); // The iframe size might have changed while loading, which can also\n      // happen if the size has been changed while detached from the DOM.\n\n      handler();\n    });\n    return iframe;\n  }\n\n  function addResizeListener(node, listener, chart) {\n    var stub = node._chartjs = {\n      ticking: false\n    }; // Throttle the callback notification until the next animation frame.\n\n    var notify = function notify() {\n      if (!stub.ticking) {\n        stub.ticking = true;\n        helpers.requestAnimFrame.call(window, function () {\n          if (stub.resizer) {\n            stub.ticking = false;\n            return listener(createEvent('resize', chart));\n          }\n        });\n      }\n    }; // Let's keep track of this added iframe and thus avoid DOM query when removing it.\n\n\n    stub.resizer = createResizer(notify);\n    node.insertBefore(stub.resizer, node.firstChild);\n  }\n\n  function removeResizeListener(node) {\n    if (!node || !node._chartjs) {\n      return;\n    }\n\n    var resizer = node._chartjs.resizer;\n\n    if (resizer) {\n      resizer.parentNode.removeChild(resizer);\n      node._chartjs.resizer = null;\n    }\n\n    delete node._chartjs;\n  }\n\n  return {\n    acquireContext: function acquireContext(item, config) {\n      if (typeof item === 'string') {\n        item = document.getElementById(item);\n      } else if (item.length) {\n        // Support for array based queries (such as jQuery)\n        item = item[0];\n      }\n\n      if (item && item.canvas) {\n        // Support for any object associated to a canvas (including a context2d)\n        item = item.canvas;\n      }\n\n      if (item instanceof HTMLCanvasElement) {\n        // To prevent canvas fingerprinting, some add-ons undefine the getContext\n        // method, for example: https://github.com/kkapsner/CanvasBlocker\n        // https://github.com/chartjs/Chart.js/issues/2807\n        var context = item.getContext && item.getContext('2d');\n\n        if (context instanceof CanvasRenderingContext2D) {\n          initCanvas(item, config);\n          return context;\n        }\n      }\n\n      return null;\n    },\n    releaseContext: function releaseContext(context) {\n      var canvas = context.canvas;\n\n      if (!canvas._chartjs) {\n        return;\n      }\n\n      var initial = canvas._chartjs.initial;\n      ['height', 'width'].forEach(function (prop) {\n        var value = initial[prop];\n\n        if (value === undefined || value === null) {\n          canvas.removeAttribute(prop);\n        } else {\n          canvas.setAttribute(prop, value);\n        }\n      });\n      helpers.each(initial.style || {}, function (value, key) {\n        canvas.style[key] = value;\n      }); // The canvas render size might have been changed (and thus the state stack discarded),\n      // we can't use save() and restore() to restore the initial state. So make sure that at\n      // least the canvas context is reset to the default state by setting the canvas width.\n      // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n\n      canvas.width = canvas.width;\n      delete canvas._chartjs;\n    },\n    addEventListener: function addEventListener(chart, type, listener) {\n      var canvas = chart.chart.canvas;\n\n      if (type === 'resize') {\n        // Note: the resize event is not supported on all browsers.\n        addResizeListener(canvas.parentNode, listener, chart.chart);\n        return;\n      }\n\n      var stub = listener._chartjs || (listener._chartjs = {});\n      var proxies = stub.proxies || (stub.proxies = {});\n\n      var proxy = proxies[chart.id + '_' + type] = function (event) {\n        listener(fromNativeEvent(event, chart.chart));\n      };\n\n      helpers.addEvent(canvas, type, proxy);\n    },\n    removeEventListener: function removeEventListener(chart, type, listener) {\n      var canvas = chart.chart.canvas;\n\n      if (type === 'resize') {\n        // Note: the resize event is not supported on all browsers.\n        removeResizeListener(canvas.parentNode, listener);\n        return;\n      }\n\n      var stub = listener._chartjs || {};\n      var proxies = stub.proxies || {};\n      var proxy = proxies[chart.id + '_' + type];\n\n      if (!proxy) {\n        return;\n      }\n\n      helpers.removeEvent(canvas, type, proxy);\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}