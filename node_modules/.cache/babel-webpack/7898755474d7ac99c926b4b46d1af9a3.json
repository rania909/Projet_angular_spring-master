{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  var noop = helpers.noop;\n  Chart.defaults.global.legend = {\n    display: true,\n    position: 'top',\n    fullWidth: true,\n    // marks that this box should take the full width of the canvas (pushing down other boxes)\n    reverse: false,\n    // a callback that will handle\n    onClick: function onClick(e, legendItem) {\n      var index = legendItem.datasetIndex;\n      var ci = this.chart;\n      var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment\n\n      meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart\n\n      ci.update();\n    },\n    onHover: null,\n    labels: {\n      boxWidth: 40,\n      padding: 10,\n      // Generates labels shown in the legend\n      // Valid properties to return:\n      // text : text to display\n      // fillStyle : fill of coloured box\n      // strokeStyle: stroke of coloured box\n      // hidden : if this legend item refers to a hidden item\n      // lineCap : cap style for line\n      // lineDash\n      // lineDashOffset :\n      // lineJoin :\n      // lineWidth :\n      generateLabels: function generateLabels(chart) {\n        var data = chart.data;\n        return helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {\n          return {\n            text: dataset.label,\n            fillStyle: !helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],\n            hidden: !chart.isDatasetVisible(i),\n            lineCap: dataset.borderCapStyle,\n            lineDash: dataset.borderDash,\n            lineDashOffset: dataset.borderDashOffset,\n            lineJoin: dataset.borderJoinStyle,\n            lineWidth: dataset.borderWidth,\n            strokeStyle: dataset.borderColor,\n            pointStyle: dataset.pointStyle,\n            // Below is extra data used for toggling the datasets\n            datasetIndex: i\n          };\n        }, this) : [];\n      }\n    }\n  };\n  /**\n   * Helper function to get the box width based on the usePointStyle option\n   * @param labelopts {Object} the label options on the legend\n   * @param fontSize {Number} the label font size\n   * @return {Number} width of the color box area\n   */\n\n  function getBoxWidth(labelOpts, fontSize) {\n    return labelOpts.usePointStyle ? fontSize * Math.SQRT2 : labelOpts.boxWidth;\n  }\n\n  Chart.Legend = Chart.Element.extend({\n    initialize: function initialize(config) {\n      helpers.extend(this, config); // Contains hit boxes for each dataset (in dataset order)\n\n      this.legendHitBoxes = []; // Are we in doughnut mode which has a different data type\n\n      this.doughnutMode = false;\n    },\n    // These methods are ordered by lifecycle. Utilities then follow.\n    // Any function defined here is inherited by all legend types.\n    // Any function can be extended by the legend type\n    beforeUpdate: noop,\n    update: function update(maxWidth, maxHeight, margins) {\n      var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\n      me.beforeUpdate(); // Absorb the master measurements\n\n      me.maxWidth = maxWidth;\n      me.maxHeight = maxHeight;\n      me.margins = margins; // Dimensions\n\n      me.beforeSetDimensions();\n      me.setDimensions();\n      me.afterSetDimensions(); // Labels\n\n      me.beforeBuildLabels();\n      me.buildLabels();\n      me.afterBuildLabels(); // Fit\n\n      me.beforeFit();\n      me.fit();\n      me.afterFit(); //\n\n      me.afterUpdate();\n      return me.minSize;\n    },\n    afterUpdate: noop,\n    //\n    beforeSetDimensions: noop,\n    setDimensions: function setDimensions() {\n      var me = this; // Set the unconstrained dimension before label rotation\n\n      if (me.isHorizontal()) {\n        // Reset position before calculating rotation\n        me.width = me.maxWidth;\n        me.left = 0;\n        me.right = me.width;\n      } else {\n        me.height = me.maxHeight; // Reset position before calculating rotation\n\n        me.top = 0;\n        me.bottom = me.height;\n      } // Reset padding\n\n\n      me.paddingLeft = 0;\n      me.paddingTop = 0;\n      me.paddingRight = 0;\n      me.paddingBottom = 0; // Reset minSize\n\n      me.minSize = {\n        width: 0,\n        height: 0\n      };\n    },\n    afterSetDimensions: noop,\n    //\n    beforeBuildLabels: noop,\n    buildLabels: function buildLabels() {\n      var me = this;\n      var labelOpts = me.options.labels;\n      var legendItems = labelOpts.generateLabels.call(me, me.chart);\n\n      if (labelOpts.filter) {\n        legendItems = legendItems.filter(function (item) {\n          return labelOpts.filter(item, me.chart.data);\n        });\n      }\n\n      if (me.options.reverse) {\n        legendItems.reverse();\n      }\n\n      me.legendItems = legendItems;\n    },\n    afterBuildLabels: noop,\n    //\n    beforeFit: noop,\n    fit: function fit() {\n      var me = this;\n      var opts = me.options;\n      var labelOpts = opts.labels;\n      var display = opts.display;\n      var ctx = me.ctx;\n      var globalDefault = Chart.defaults.global,\n          itemOrDefault = helpers.getValueOrDefault,\n          fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n          fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n          fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n          labelFont = helpers.fontString(fontSize, fontStyle, fontFamily); // Reset hit boxes\n\n      var hitboxes = me.legendHitBoxes = [];\n      var minSize = me.minSize;\n      var isHorizontal = me.isHorizontal();\n\n      if (isHorizontal) {\n        minSize.width = me.maxWidth; // fill all the width\n\n        minSize.height = display ? 10 : 0;\n      } else {\n        minSize.width = display ? 10 : 0;\n        minSize.height = me.maxHeight; // fill all the height\n      } // Increase sizes here\n\n\n      if (display) {\n        ctx.font = labelFont;\n\n        if (isHorizontal) {\n          // Labels\n          // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n          var lineWidths = me.lineWidths = [0];\n          var totalHeight = me.legendItems.length ? fontSize + labelOpts.padding : 0;\n          ctx.textAlign = 'left';\n          ctx.textBaseline = 'top';\n          helpers.each(me.legendItems, function (legendItem, i) {\n            var boxWidth = getBoxWidth(labelOpts, fontSize);\n            var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n\n            if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n              totalHeight += fontSize + labelOpts.padding;\n              lineWidths[lineWidths.length] = me.left;\n            } // Store the hitbox width and height here. Final position will be updated in `draw`\n\n\n            hitboxes[i] = {\n              left: 0,\n              top: 0,\n              width: width,\n              height: fontSize\n            };\n            lineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n          });\n          minSize.height += totalHeight;\n        } else {\n          var vPadding = labelOpts.padding;\n          var columnWidths = me.columnWidths = [];\n          var totalWidth = labelOpts.padding;\n          var currentColWidth = 0;\n          var currentColHeight = 0;\n          var itemHeight = fontSize + vPadding;\n          helpers.each(me.legendItems, function (legendItem, i) {\n            var boxWidth = getBoxWidth(labelOpts, fontSize);\n            var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column\n\n            if (currentColHeight + itemHeight > minSize.height) {\n              totalWidth += currentColWidth + labelOpts.padding;\n              columnWidths.push(currentColWidth); // previous column width\n\n              currentColWidth = 0;\n              currentColHeight = 0;\n            } // Get max width\n\n\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight; // Store the hitbox width and height here. Final position will be updated in `draw`\n\n            hitboxes[i] = {\n              left: 0,\n              top: 0,\n              width: itemWidth,\n              height: fontSize\n            };\n          });\n          totalWidth += currentColWidth;\n          columnWidths.push(currentColWidth);\n          minSize.width += totalWidth;\n        }\n      }\n\n      me.width = minSize.width;\n      me.height = minSize.height;\n    },\n    afterFit: noop,\n    // Shared Methods\n    isHorizontal: function isHorizontal() {\n      return this.options.position === 'top' || this.options.position === 'bottom';\n    },\n    // Actually draw the legend on the canvas\n    draw: function draw() {\n      var me = this;\n      var opts = me.options;\n      var labelOpts = opts.labels;\n      var globalDefault = Chart.defaults.global,\n          lineDefault = globalDefault.elements.line,\n          legendWidth = me.width,\n          lineWidths = me.lineWidths;\n\n      if (opts.display) {\n        var ctx = me.ctx,\n            cursor,\n            itemOrDefault = helpers.getValueOrDefault,\n            fontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),\n            fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n            fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n            fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n            labelFont = helpers.fontString(fontSize, fontStyle, fontFamily); // Canvas setup\n\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'top';\n        ctx.lineWidth = 0.5;\n        ctx.strokeStyle = fontColor; // for strikethrough effect\n\n        ctx.fillStyle = fontColor; // render in correct colour\n\n        ctx.font = labelFont;\n        var boxWidth = getBoxWidth(labelOpts, fontSize),\n            hitboxes = me.legendHitBoxes; // current position\n\n        var drawLegendBox = function drawLegendBox(x, y, legendItem) {\n          if (isNaN(boxWidth) || boxWidth <= 0) {\n            return;\n          } // Set the ctx for the box\n\n\n          ctx.save();\n          ctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n          ctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n          ctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n          ctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n          ctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n          ctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n          var isLineWidthZero = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0;\n\n          if (ctx.setLineDash) {\n            // IE 9 and 10 do not support line dash\n            ctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));\n          }\n\n          if (opts.labels && opts.labels.usePointStyle) {\n            // Recalculate x and y for drawPoint() because its expecting\n            // x and y to be center of figure (instead of top left)\n            var radius = fontSize * Math.SQRT2 / 2;\n            var offSet = radius / Math.SQRT2;\n            var centerX = x + offSet;\n            var centerY = y + offSet; // Draw pointStyle as legend symbol\n\n            Chart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n          } else {\n            // Draw box as legend symbol\n            if (!isLineWidthZero) {\n              ctx.strokeRect(x, y, boxWidth, fontSize);\n            }\n\n            ctx.fillRect(x, y, boxWidth, fontSize);\n          }\n\n          ctx.restore();\n        };\n\n        var fillText = function fillText(x, y, legendItem, textWidth) {\n          ctx.fillText(legendItem.text, boxWidth + fontSize / 2 + x, y);\n\n          if (legendItem.hidden) {\n            // Strikethrough the text if hidden\n            ctx.beginPath();\n            ctx.lineWidth = 2;\n            ctx.moveTo(boxWidth + fontSize / 2 + x, y + fontSize / 2);\n            ctx.lineTo(boxWidth + fontSize / 2 + x + textWidth, y + fontSize / 2);\n            ctx.stroke();\n          }\n        }; // Horizontal\n\n\n        var isHorizontal = me.isHorizontal();\n\n        if (isHorizontal) {\n          cursor = {\n            x: me.left + (legendWidth - lineWidths[0]) / 2,\n            y: me.top + labelOpts.padding,\n            line: 0\n          };\n        } else {\n          cursor = {\n            x: me.left + labelOpts.padding,\n            y: me.top + labelOpts.padding,\n            line: 0\n          };\n        }\n\n        var itemHeight = fontSize + labelOpts.padding;\n        helpers.each(me.legendItems, function (legendItem, i) {\n          var textWidth = ctx.measureText(legendItem.text).width,\n              width = boxWidth + fontSize / 2 + textWidth,\n              x = cursor.x,\n              y = cursor.y;\n\n          if (isHorizontal) {\n            if (x + width >= legendWidth) {\n              y = cursor.y += itemHeight;\n              cursor.line++;\n              x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2;\n            }\n          } else if (y + itemHeight > me.bottom) {\n            x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n            y = cursor.y = me.top + labelOpts.padding;\n            cursor.line++;\n          }\n\n          drawLegendBox(x, y, legendItem);\n          hitboxes[i].left = x;\n          hitboxes[i].top = y; // Fill the actual label\n\n          fillText(x, y, legendItem, textWidth);\n\n          if (isHorizontal) {\n            cursor.x += width + labelOpts.padding;\n          } else {\n            cursor.y += itemHeight;\n          }\n        });\n      }\n    },\n\n    /**\n     * Handle an event\n     * @private\n     * @param {IEvent} event - The event to handle\n     * @return {Boolean} true if a change occured\n     */\n    handleEvent: function handleEvent(e) {\n      var me = this;\n      var opts = me.options;\n      var type = e.type === 'mouseup' ? 'click' : e.type;\n      var changed = false;\n\n      if (type === 'mousemove') {\n        if (!opts.onHover) {\n          return;\n        }\n      } else if (type === 'click') {\n        if (!opts.onClick) {\n          return;\n        }\n      } else {\n        return;\n      } // Chart event already has relative position in it\n\n\n      var x = e.x,\n          y = e.y;\n\n      if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n        // See if we are touching one of the dataset boxes\n        var lh = me.legendHitBoxes;\n\n        for (var i = 0; i < lh.length; ++i) {\n          var hitBox = lh[i];\n\n          if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n            // Touching an element\n            if (type === 'click') {\n              // use e.native for backwards compatibility\n              opts.onClick.call(me, e.native, me.legendItems[i]);\n              changed = true;\n              break;\n            } else if (type === 'mousemove') {\n              // use e.native for backwards compatibility\n              opts.onHover.call(me, e.native, me.legendItems[i]);\n              changed = true;\n              break;\n            }\n          }\n        }\n      }\n\n      return changed;\n    }\n  });\n\n  function createNewLegendAndAttach(chartInstance, legendOpts) {\n    var legend = new Chart.Legend({\n      ctx: chartInstance.chart.ctx,\n      options: legendOpts,\n      chart: chartInstance\n    });\n    chartInstance.legend = legend;\n    Chart.layoutService.addBox(chartInstance, legend);\n  } // Register the legend plugin\n\n\n  Chart.plugins.register({\n    beforeInit: function beforeInit(chartInstance) {\n      var legendOpts = chartInstance.options.legend;\n\n      if (legendOpts) {\n        createNewLegendAndAttach(chartInstance, legendOpts);\n      }\n    },\n    beforeUpdate: function beforeUpdate(chartInstance) {\n      var legendOpts = chartInstance.options.legend;\n\n      if (legendOpts) {\n        legendOpts = helpers.configMerge(Chart.defaults.global.legend, legendOpts);\n\n        if (chartInstance.legend) {\n          chartInstance.legend.options = legendOpts;\n        } else {\n          createNewLegendAndAttach(chartInstance, legendOpts);\n        }\n      } else {\n        Chart.layoutService.removeBox(chartInstance, chartInstance.legend);\n        delete chartInstance.legend;\n      }\n    },\n    afterEvent: function afterEvent(chartInstance, e) {\n      var legend = chartInstance.legend;\n\n      if (legend) {\n        legend.handleEvent(e);\n      }\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}