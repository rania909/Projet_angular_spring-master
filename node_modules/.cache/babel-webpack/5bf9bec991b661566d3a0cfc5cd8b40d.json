{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  var defaultConfig = {\n    position: 'left',\n    // label settings\n    ticks: {\n      callback: Chart.Ticks.formatters.logarithmic\n    }\n  };\n  var LogarithmicScale = Chart.Scale.extend({\n    determineDataLimits: function determineDataLimits() {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var chart = me.chart;\n      var data = chart.data;\n      var datasets = data.datasets;\n      var getValueOrDefault = helpers.getValueOrDefault;\n      var isHorizontal = me.isHorizontal();\n\n      function IDMatches(meta) {\n        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n      } // Calculate Range\n\n\n      me.min = null;\n      me.max = null;\n      me.minNotZero = null;\n      var hasStacks = opts.stacked;\n\n      if (hasStacks === undefined) {\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          if (hasStacks) {\n            return;\n          }\n\n          var meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {\n            hasStacks = true;\n          }\n        });\n      }\n\n      if (opts.stacked || hasStacks) {\n        var valuesPerStack = {};\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n          var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n          opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            if (valuesPerStack[key] === undefined) {\n              valuesPerStack[key] = [];\n            }\n\n            helpers.each(dataset.data, function (rawValue, index) {\n              var values = valuesPerStack[key];\n              var value = +me.getRightValue(rawValue);\n\n              if (isNaN(value) || meta.data[index].hidden) {\n                return;\n              }\n\n              values[index] = values[index] || 0;\n\n              if (opts.relativePoints) {\n                values[index] = 100;\n              } else {\n                // Don't need to split positive and negative since the log scale can't handle a 0 crossing\n                values[index] += value;\n              }\n            });\n          }\n        });\n        helpers.each(valuesPerStack, function (valuesForType) {\n          var minVal = helpers.min(valuesForType);\n          var maxVal = helpers.max(valuesForType);\n          me.min = me.min === null ? minVal : Math.min(me.min, minVal);\n          me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n        });\n      } else {\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            helpers.each(dataset.data, function (rawValue, index) {\n              var value = +me.getRightValue(rawValue);\n\n              if (isNaN(value) || meta.data[index].hidden) {\n                return;\n              }\n\n              if (me.min === null) {\n                me.min = value;\n              } else if (value < me.min) {\n                me.min = value;\n              }\n\n              if (me.max === null) {\n                me.max = value;\n              } else if (value > me.max) {\n                me.max = value;\n              }\n\n              if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n                me.minNotZero = value;\n              }\n            });\n          }\n        });\n      }\n\n      me.min = getValueOrDefault(tickOpts.min, me.min);\n      me.max = getValueOrDefault(tickOpts.max, me.max);\n\n      if (me.min === me.max) {\n        if (me.min !== 0 && me.min !== null) {\n          me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n          me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n        } else {\n          me.min = 1;\n          me.max = 10;\n        }\n      }\n    },\n    buildTicks: function buildTicks() {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var generationOptions = {\n        min: tickOpts.min,\n        max: tickOpts.max\n      };\n      var ticks = me.ticks = Chart.Ticks.generators.logarithmic(generationOptions, me);\n\n      if (!me.isHorizontal()) {\n        // We are in a vertical orientation. The top value is the highest. So reverse the array\n        ticks.reverse();\n      } // At this point, we need to update our max and min given the tick values since we have expanded the\n      // range of the scale\n\n\n      me.max = helpers.max(ticks);\n      me.min = helpers.min(ticks);\n\n      if (tickOpts.reverse) {\n        ticks.reverse();\n        me.start = me.max;\n        me.end = me.min;\n      } else {\n        me.start = me.min;\n        me.end = me.max;\n      }\n    },\n    convertTicksToLabels: function convertTicksToLabels() {\n      this.tickValues = this.ticks.slice();\n      Chart.Scale.prototype.convertTicksToLabels.call(this);\n    },\n    // Get the correct tooltip label\n    getLabelForIndex: function getLabelForIndex(index, datasetIndex) {\n      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    getPixelForTick: function getPixelForTick(index) {\n      return this.getPixelForValue(this.tickValues[index]);\n    },\n    getPixelForValue: function getPixelForValue(value) {\n      var me = this;\n      var innerDimension;\n      var pixel;\n      var start = me.start;\n      var newVal = +me.getRightValue(value);\n      var range;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n\n      if (me.isHorizontal()) {\n        range = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0\n\n        if (newVal === 0) {\n          pixel = me.left;\n        } else {\n          innerDimension = me.width;\n          pixel = me.left + innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));\n        }\n      } else {\n        // Bottom - top since pixels increase downward on a screen\n        innerDimension = me.height;\n\n        if (start === 0 && !tickOpts.reverse) {\n          range = helpers.log10(me.end) - helpers.log10(me.minNotZero);\n\n          if (newVal === start) {\n            pixel = me.bottom;\n          } else if (newVal === me.minNotZero) {\n            pixel = me.bottom - innerDimension * 0.02;\n          } else {\n            pixel = me.bottom - innerDimension * 0.02 - innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));\n          }\n        } else if (me.end === 0 && tickOpts.reverse) {\n          range = helpers.log10(me.start) - helpers.log10(me.minNotZero);\n\n          if (newVal === me.end) {\n            pixel = me.top;\n          } else if (newVal === me.minNotZero) {\n            pixel = me.top + innerDimension * 0.02;\n          } else {\n            pixel = me.top + innerDimension * 0.02 + innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));\n          }\n        } else {\n          range = helpers.log10(me.end) - helpers.log10(start);\n          innerDimension = me.height;\n          pixel = me.bottom - innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));\n        }\n      }\n\n      return pixel;\n    },\n    getValueForPixel: function getValueForPixel(pixel) {\n      var me = this;\n      var range = helpers.log10(me.end) - helpers.log10(me.start);\n      var value, innerDimension;\n\n      if (me.isHorizontal()) {\n        innerDimension = me.width;\n        value = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);\n      } else {\n        // todo: if start === 0\n        innerDimension = me.height;\n        value = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;\n      }\n\n      return value;\n    }\n  });\n  Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n};","map":null,"metadata":{},"sourceType":"script"}