{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  Chart.defaults.bar = {\n    hover: {\n      mode: 'label'\n    },\n    scales: {\n      xAxes: [{\n        type: 'category',\n        // Specific to Bar Controller\n        categoryPercentage: 0.8,\n        barPercentage: 0.9,\n        // grid line settings\n        gridLines: {\n          offsetGridLines: true\n        }\n      }],\n      yAxes: [{\n        type: 'linear'\n      }]\n    }\n  };\n  Chart.controllers.bar = Chart.DatasetController.extend({\n    dataElementType: Chart.elements.Rectangle,\n    initialize: function initialize(chart, datasetIndex) {\n      Chart.DatasetController.prototype.initialize.call(this, chart, datasetIndex);\n      var me = this;\n      var meta = me.getMeta();\n      var dataset = me.getDataset();\n      meta.stack = dataset.stack; // Use this to indicate that this is a bar dataset.\n\n      meta.bar = true;\n    },\n    // Correctly calculate the bar width accounting for stacks and the fact that not all bars are visible\n    getStackCount: function getStackCount() {\n      var me = this;\n      var meta = me.getMeta();\n      var yScale = me.getScaleForId(meta.yAxisID);\n      var stacks = [];\n      helpers.each(me.chart.data.datasets, function (dataset, datasetIndex) {\n        var dsMeta = me.chart.getDatasetMeta(datasetIndex);\n\n        if (dsMeta.bar && me.chart.isDatasetVisible(datasetIndex) && (yScale.options.stacked === false || yScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1 || yScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1))) {\n          stacks.push(dsMeta.stack);\n        }\n      }, me);\n      return stacks.length;\n    },\n    update: function update(reset) {\n      var me = this;\n      helpers.each(me.getMeta().data, function (rectangle, index) {\n        me.updateElement(rectangle, index, reset);\n      }, me);\n    },\n    updateElement: function updateElement(rectangle, index, reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var xScale = me.getScaleForId(meta.xAxisID);\n      var yScale = me.getScaleForId(meta.yAxisID);\n      var scaleBase = yScale.getBasePixel();\n      var rectangleElementOptions = me.chart.options.elements.rectangle;\n      var custom = rectangle.custom || {};\n      var dataset = me.getDataset();\n      rectangle._xScale = xScale;\n      rectangle._yScale = yScale;\n      rectangle._datasetIndex = me.index;\n      rectangle._index = index;\n      var ruler = me.getRuler(index); // The index argument for compatible\n\n      rectangle._model = {\n        x: me.calculateBarX(index, me.index, ruler),\n        y: reset ? scaleBase : me.calculateBarY(index, me.index),\n        // Tooltip\n        label: me.chart.data.labels[index],\n        datasetLabel: dataset.label,\n        // Appearance\n        horizontal: false,\n        base: reset ? scaleBase : me.calculateBarBase(me.index, index),\n        width: me.calculateBarWidth(ruler),\n        backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),\n        borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\n        borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\n        borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)\n      };\n      rectangle.pivot();\n    },\n    calculateBarBase: function calculateBarBase(datasetIndex, index) {\n      var me = this;\n      var meta = me.getMeta();\n      var yScale = me.getScaleForId(meta.yAxisID);\n      var base = yScale.getBaseValue();\n      var original = base;\n\n      if (yScale.options.stacked === true || yScale.options.stacked === undefined && meta.stack !== undefined) {\n        var chart = me.chart;\n        var datasets = chart.data.datasets;\n        var value = Number(datasets[datasetIndex].data[index]);\n\n        for (var i = 0; i < datasetIndex; i++) {\n          var currentDs = datasets[i];\n          var currentDsMeta = chart.getDatasetMeta(i);\n\n          if (currentDsMeta.bar && currentDsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i) && meta.stack === currentDsMeta.stack) {\n            var currentVal = Number(currentDs.data[index]);\n            base += value < 0 ? Math.min(currentVal, original) : Math.max(currentVal, original);\n          }\n        }\n\n        return yScale.getPixelForValue(base);\n      }\n\n      return yScale.getBasePixel();\n    },\n    getRuler: function getRuler() {\n      var me = this;\n      var meta = me.getMeta();\n      var xScale = me.getScaleForId(meta.xAxisID);\n      var stackCount = me.getStackCount();\n      var tickWidth = xScale.width / xScale.ticks.length;\n      var categoryWidth = tickWidth * xScale.options.categoryPercentage;\n      var categorySpacing = (tickWidth - tickWidth * xScale.options.categoryPercentage) / 2;\n      var fullBarWidth = categoryWidth / stackCount;\n      var barWidth = fullBarWidth * xScale.options.barPercentage;\n      var barSpacing = fullBarWidth - fullBarWidth * xScale.options.barPercentage;\n      return {\n        stackCount: stackCount,\n        tickWidth: tickWidth,\n        categoryWidth: categoryWidth,\n        categorySpacing: categorySpacing,\n        fullBarWidth: fullBarWidth,\n        barWidth: barWidth,\n        barSpacing: barSpacing\n      };\n    },\n    calculateBarWidth: function calculateBarWidth(ruler) {\n      var me = this;\n      var meta = me.getMeta();\n      var xScale = me.getScaleForId(meta.xAxisID);\n\n      if (xScale.options.barThickness) {\n        return xScale.options.barThickness;\n      }\n\n      return ruler.barWidth;\n    },\n    // Get stack index from the given dataset index accounting for stacks and the fact that not all bars are visible\n    getStackIndex: function getStackIndex(datasetIndex) {\n      var me = this;\n      var meta = me.chart.getDatasetMeta(datasetIndex);\n      var yScale = me.getScaleForId(meta.yAxisID);\n      var dsMeta, j;\n      var stacks = [meta.stack];\n\n      for (j = 0; j < datasetIndex; ++j) {\n        dsMeta = this.chart.getDatasetMeta(j);\n\n        if (dsMeta.bar && this.chart.isDatasetVisible(j) && (yScale.options.stacked === false || yScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1 || yScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1))) {\n          stacks.push(dsMeta.stack);\n        }\n      }\n\n      return stacks.length - 1;\n    },\n    calculateBarX: function calculateBarX(index, datasetIndex, ruler) {\n      var me = this;\n      var meta = me.getMeta();\n      var xScale = me.getScaleForId(meta.xAxisID);\n      var stackIndex = me.getStackIndex(datasetIndex);\n      var leftTick = xScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);\n      leftTick -= me.chart.isCombo ? ruler.tickWidth / 2 : 0;\n      return leftTick + ruler.barWidth / 2 + ruler.categorySpacing + ruler.barWidth * stackIndex + ruler.barSpacing / 2 + ruler.barSpacing * stackIndex;\n    },\n    calculateBarY: function calculateBarY(index, datasetIndex) {\n      var me = this;\n      var meta = me.getMeta();\n      var yScale = me.getScaleForId(meta.yAxisID);\n      var value = Number(me.getDataset().data[index]);\n\n      if (yScale.options.stacked || yScale.options.stacked === undefined && meta.stack !== undefined) {\n        var base = yScale.getBaseValue();\n        var sumPos = base,\n            sumNeg = base;\n\n        for (var i = 0; i < datasetIndex; i++) {\n          var ds = me.chart.data.datasets[i];\n          var dsMeta = me.chart.getDatasetMeta(i);\n\n          if (dsMeta.bar && dsMeta.yAxisID === yScale.id && me.chart.isDatasetVisible(i) && meta.stack === dsMeta.stack) {\n            var stackedVal = Number(ds.data[index]);\n\n            if (stackedVal < 0) {\n              sumNeg += stackedVal || 0;\n            } else {\n              sumPos += stackedVal || 0;\n            }\n          }\n        }\n\n        if (value < 0) {\n          return yScale.getPixelForValue(sumNeg + value);\n        }\n\n        return yScale.getPixelForValue(sumPos + value);\n      }\n\n      return yScale.getPixelForValue(value);\n    },\n    draw: function draw(ease) {\n      var me = this;\n      var easingDecimal = ease || 1;\n      var metaData = me.getMeta().data;\n      var dataset = me.getDataset();\n      var i, len;\n      Chart.canvasHelpers.clipArea(me.chart.chart.ctx, me.chart.chartArea);\n\n      for (i = 0, len = metaData.length; i < len; ++i) {\n        var d = dataset.data[i];\n\n        if (d !== null && d !== undefined && !isNaN(d)) {\n          metaData[i].transition(easingDecimal).draw();\n        }\n      }\n\n      Chart.canvasHelpers.unclipArea(me.chart.chart.ctx);\n    },\n    setHoverStyle: function setHoverStyle(rectangle) {\n      var dataset = this.chart.data.datasets[rectangle._datasetIndex];\n      var index = rectangle._index;\n      var custom = rectangle.custom || {};\n      var model = rectangle._model;\n      model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n      model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n      model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n    },\n    removeHoverStyle: function removeHoverStyle(rectangle) {\n      var dataset = this.chart.data.datasets[rectangle._datasetIndex];\n      var index = rectangle._index;\n      var custom = rectangle.custom || {};\n      var model = rectangle._model;\n      var rectangleElementOptions = this.chart.options.elements.rectangle;\n      model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\n      model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\n      model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\n    }\n  }); // including horizontalBar in the bar file, instead of a file of its own\n  // it extends bar (like pie extends doughnut)\n\n  Chart.defaults.horizontalBar = {\n    hover: {\n      mode: 'label'\n    },\n    scales: {\n      xAxes: [{\n        type: 'linear',\n        position: 'bottom'\n      }],\n      yAxes: [{\n        position: 'left',\n        type: 'category',\n        // Specific to Horizontal Bar Controller\n        categoryPercentage: 0.8,\n        barPercentage: 0.9,\n        // grid line settings\n        gridLines: {\n          offsetGridLines: true\n        }\n      }]\n    },\n    elements: {\n      rectangle: {\n        borderSkipped: 'left'\n      }\n    },\n    tooltips: {\n      callbacks: {\n        title: function title(tooltipItems, data) {\n          // Pick first xLabel for now\n          var title = '';\n\n          if (tooltipItems.length > 0) {\n            if (tooltipItems[0].yLabel) {\n              title = tooltipItems[0].yLabel;\n            } else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {\n              title = data.labels[tooltipItems[0].index];\n            }\n          }\n\n          return title;\n        },\n        label: function label(tooltipItem, data) {\n          var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n          return datasetLabel + ': ' + tooltipItem.xLabel;\n        }\n      }\n    }\n  };\n  Chart.controllers.horizontalBar = Chart.controllers.bar.extend({\n    // Correctly calculate the bar width accounting for stacks and the fact that not all bars are visible\n    getStackCount: function getStackCount() {\n      var me = this;\n      var meta = me.getMeta();\n      var xScale = me.getScaleForId(meta.xAxisID);\n      var stacks = [];\n      helpers.each(me.chart.data.datasets, function (dataset, datasetIndex) {\n        var dsMeta = me.chart.getDatasetMeta(datasetIndex);\n\n        if (dsMeta.bar && me.chart.isDatasetVisible(datasetIndex) && (xScale.options.stacked === false || xScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1 || xScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1))) {\n          stacks.push(dsMeta.stack);\n        }\n      }, me);\n      return stacks.length;\n    },\n    updateElement: function updateElement(rectangle, index, reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var xScale = me.getScaleForId(meta.xAxisID);\n      var yScale = me.getScaleForId(meta.yAxisID);\n      var scaleBase = xScale.getBasePixel();\n      var custom = rectangle.custom || {};\n      var dataset = me.getDataset();\n      var rectangleElementOptions = me.chart.options.elements.rectangle;\n      rectangle._xScale = xScale;\n      rectangle._yScale = yScale;\n      rectangle._datasetIndex = me.index;\n      rectangle._index = index;\n      var ruler = me.getRuler(index); // The index argument for compatible\n\n      rectangle._model = {\n        x: reset ? scaleBase : me.calculateBarX(index, me.index),\n        y: me.calculateBarY(index, me.index, ruler),\n        // Tooltip\n        label: me.chart.data.labels[index],\n        datasetLabel: dataset.label,\n        // Appearance\n        horizontal: true,\n        base: reset ? scaleBase : me.calculateBarBase(me.index, index),\n        height: me.calculateBarHeight(ruler),\n        backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),\n        borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\n        borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\n        borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)\n      };\n      rectangle.pivot();\n    },\n    calculateBarBase: function calculateBarBase(datasetIndex, index) {\n      var me = this;\n      var meta = me.getMeta();\n      var xScale = me.getScaleForId(meta.xAxisID);\n      var base = xScale.getBaseValue();\n      var originalBase = base;\n\n      if (xScale.options.stacked || xScale.options.stacked === undefined && meta.stack !== undefined) {\n        var chart = me.chart;\n        var datasets = chart.data.datasets;\n        var value = Number(datasets[datasetIndex].data[index]);\n\n        for (var i = 0; i < datasetIndex; i++) {\n          var currentDs = datasets[i];\n          var currentDsMeta = chart.getDatasetMeta(i);\n\n          if (currentDsMeta.bar && currentDsMeta.xAxisID === xScale.id && chart.isDatasetVisible(i) && meta.stack === currentDsMeta.stack) {\n            var currentVal = Number(currentDs.data[index]);\n            base += value < 0 ? Math.min(currentVal, originalBase) : Math.max(currentVal, originalBase);\n          }\n        }\n\n        return xScale.getPixelForValue(base);\n      }\n\n      return xScale.getBasePixel();\n    },\n    getRuler: function getRuler() {\n      var me = this;\n      var meta = me.getMeta();\n      var yScale = me.getScaleForId(meta.yAxisID);\n      var stackCount = me.getStackCount();\n      var tickHeight = yScale.height / yScale.ticks.length;\n      var categoryHeight = tickHeight * yScale.options.categoryPercentage;\n      var categorySpacing = (tickHeight - tickHeight * yScale.options.categoryPercentage) / 2;\n      var fullBarHeight = categoryHeight / stackCount;\n      var barHeight = fullBarHeight * yScale.options.barPercentage;\n      var barSpacing = fullBarHeight - fullBarHeight * yScale.options.barPercentage;\n      return {\n        stackCount: stackCount,\n        tickHeight: tickHeight,\n        categoryHeight: categoryHeight,\n        categorySpacing: categorySpacing,\n        fullBarHeight: fullBarHeight,\n        barHeight: barHeight,\n        barSpacing: barSpacing\n      };\n    },\n    calculateBarHeight: function calculateBarHeight(ruler) {\n      var me = this;\n      var meta = me.getMeta();\n      var yScale = me.getScaleForId(meta.yAxisID);\n\n      if (yScale.options.barThickness) {\n        return yScale.options.barThickness;\n      }\n\n      return ruler.barHeight;\n    },\n    // Get stack index from the given dataset index accounting for stacks and the fact that not all bars are visible\n    getStackIndex: function getStackIndex(datasetIndex) {\n      var me = this;\n      var meta = me.chart.getDatasetMeta(datasetIndex);\n      var xScale = me.getScaleForId(meta.xAxisID);\n      var dsMeta, j;\n      var stacks = [meta.stack];\n\n      for (j = 0; j < datasetIndex; ++j) {\n        dsMeta = this.chart.getDatasetMeta(j);\n\n        if (dsMeta.bar && this.chart.isDatasetVisible(j) && (xScale.options.stacked === false || xScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1 || xScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1))) {\n          stacks.push(dsMeta.stack);\n        }\n      }\n\n      return stacks.length - 1;\n    },\n    calculateBarX: function calculateBarX(index, datasetIndex) {\n      var me = this;\n      var meta = me.getMeta();\n      var xScale = me.getScaleForId(meta.xAxisID);\n      var value = Number(me.getDataset().data[index]);\n\n      if (xScale.options.stacked || xScale.options.stacked === undefined && meta.stack !== undefined) {\n        var base = xScale.getBaseValue();\n        var sumPos = base,\n            sumNeg = base;\n\n        for (var i = 0; i < datasetIndex; i++) {\n          var ds = me.chart.data.datasets[i];\n          var dsMeta = me.chart.getDatasetMeta(i);\n\n          if (dsMeta.bar && dsMeta.xAxisID === xScale.id && me.chart.isDatasetVisible(i) && meta.stack === dsMeta.stack) {\n            var stackedVal = Number(ds.data[index]);\n\n            if (stackedVal < 0) {\n              sumNeg += stackedVal || 0;\n            } else {\n              sumPos += stackedVal || 0;\n            }\n          }\n        }\n\n        if (value < 0) {\n          return xScale.getPixelForValue(sumNeg + value);\n        }\n\n        return xScale.getPixelForValue(sumPos + value);\n      }\n\n      return xScale.getPixelForValue(value);\n    },\n    calculateBarY: function calculateBarY(index, datasetIndex, ruler) {\n      var me = this;\n      var meta = me.getMeta();\n      var yScale = me.getScaleForId(meta.yAxisID);\n      var stackIndex = me.getStackIndex(datasetIndex);\n      var topTick = yScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);\n      topTick -= me.chart.isCombo ? ruler.tickHeight / 2 : 0;\n      return topTick + ruler.barHeight / 2 + ruler.categorySpacing + ruler.barHeight * stackIndex + ruler.barSpacing / 2 + ruler.barSpacing * stackIndex;\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}