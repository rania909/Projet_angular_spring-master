{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers; // The layout service is very self explanatory.  It's responsible for the layout within a chart.\n  // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n  // It is this service's responsibility of carrying out that layout.\n\n  Chart.layoutService = {\n    defaults: {},\n    // Register a box to a chartInstance. A box is simply a reference to an object that requires layout. eg. Scales, Legend, Plugins.\n    addBox: function addBox(chartInstance, box) {\n      if (!chartInstance.boxes) {\n        chartInstance.boxes = [];\n      }\n\n      chartInstance.boxes.push(box);\n    },\n    removeBox: function removeBox(chartInstance, box) {\n      if (!chartInstance.boxes) {\n        return;\n      }\n\n      chartInstance.boxes.splice(chartInstance.boxes.indexOf(box), 1);\n    },\n    // The most important function\n    update: function update(chartInstance, width, height) {\n      if (!chartInstance) {\n        return;\n      }\n\n      var layoutOptions = chartInstance.options.layout;\n      var padding = layoutOptions ? layoutOptions.padding : null;\n      var leftPadding = 0;\n      var rightPadding = 0;\n      var topPadding = 0;\n      var bottomPadding = 0;\n\n      if (!isNaN(padding)) {\n        // options.layout.padding is a number. assign to all\n        leftPadding = padding;\n        rightPadding = padding;\n        topPadding = padding;\n        bottomPadding = padding;\n      } else {\n        leftPadding = padding.left || 0;\n        rightPadding = padding.right || 0;\n        topPadding = padding.top || 0;\n        bottomPadding = padding.bottom || 0;\n      }\n\n      var leftBoxes = helpers.where(chartInstance.boxes, function (box) {\n        return box.options.position === 'left';\n      });\n      var rightBoxes = helpers.where(chartInstance.boxes, function (box) {\n        return box.options.position === 'right';\n      });\n      var topBoxes = helpers.where(chartInstance.boxes, function (box) {\n        return box.options.position === 'top';\n      });\n      var bottomBoxes = helpers.where(chartInstance.boxes, function (box) {\n        return box.options.position === 'bottom';\n      }); // Boxes that overlay the chartarea such as the radialLinear scale\n\n      var chartAreaBoxes = helpers.where(chartInstance.boxes, function (box) {\n        return box.options.position === 'chartArea';\n      }); // Ensure that full width boxes are at the very top / bottom\n\n      topBoxes.sort(function (a, b) {\n        return (b.options.fullWidth ? 1 : 0) - (a.options.fullWidth ? 1 : 0);\n      });\n      bottomBoxes.sort(function (a, b) {\n        return (a.options.fullWidth ? 1 : 0) - (b.options.fullWidth ? 1 : 0);\n      }); // Essentially we now have any number of boxes on each of the 4 sides.\n      // Our canvas looks like the following.\n      // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n      // B1 is the bottom axis\n      // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n      // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n      // an error will be thrown.\n      //\n      // |----------------------------------------------------|\n      // |                  T1 (Full Width)                   |\n      // |----------------------------------------------------|\n      // |    |    |                 T2                  |    |\n      // |    |----|-------------------------------------|----|\n      // |    |    | C1 |                           | C2 |    |\n      // |    |    |----|                           |----|    |\n      // |    |    |                                     |    |\n      // | L1 | L2 |           ChartArea (C0)            | R1 |\n      // |    |    |                                     |    |\n      // |    |    |----|                           |----|    |\n      // |    |    | C3 |                           | C4 |    |\n      // |    |----|-------------------------------------|----|\n      // |    |    |                 B1                  |    |\n      // |----------------------------------------------------|\n      // |                  B2 (Full Width)                   |\n      // |----------------------------------------------------|\n      //\n      // What we do to find the best sizing, we do the following\n      // 1. Determine the minimum size of the chart area.\n      // 2. Split the remaining width equally between each vertical axis\n      // 3. Split the remaining height equally between each horizontal axis\n      // 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n      // 5. Adjust the sizes of each axis based on it's minimum reported size.\n      // 6. Refit each axis\n      // 7. Position each axis in the final location\n      // 8. Tell the chart the final location of the chart area\n      // 9. Tell any axes that overlay the chart area the positions of the chart area\n      // Step 1\n\n      var chartWidth = width - leftPadding - rightPadding;\n      var chartHeight = height - topPadding - bottomPadding;\n      var chartAreaWidth = chartWidth / 2; // min 50%\n\n      var chartAreaHeight = chartHeight / 2; // min 50%\n      // Step 2\n\n      var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length); // Step 3\n\n      var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length); // Step 4\n\n      var maxChartAreaWidth = chartWidth;\n      var maxChartAreaHeight = chartHeight;\n      var minBoxSizes = [];\n\n      function getMinimumBoxSize(box) {\n        var minSize;\n        var isHorizontal = box.isHorizontal();\n\n        if (isHorizontal) {\n          minSize = box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n          maxChartAreaHeight -= minSize.height;\n        } else {\n          minSize = box.update(verticalBoxWidth, chartAreaHeight);\n          maxChartAreaWidth -= minSize.width;\n        }\n\n        minBoxSizes.push({\n          horizontal: isHorizontal,\n          minSize: minSize,\n          box: box\n        });\n      }\n\n      helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize); // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\n      var maxHorizontalLeftPadding = 0;\n      var maxHorizontalRightPadding = 0;\n      var maxVerticalTopPadding = 0;\n      var maxVerticalBottomPadding = 0;\n      helpers.each(topBoxes.concat(bottomBoxes), function (horizontalBox) {\n        if (horizontalBox.getPadding) {\n          var boxPadding = horizontalBox.getPadding();\n          maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\n          maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\n        }\n      });\n      helpers.each(leftBoxes.concat(rightBoxes), function (verticalBox) {\n        if (verticalBox.getPadding) {\n          var boxPadding = verticalBox.getPadding();\n          maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\n          maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\n        }\n      }); // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n      // be if the axes are drawn at their minimum sizes.\n      // Steps 5 & 6\n\n      var totalLeftBoxesWidth = leftPadding;\n      var totalRightBoxesWidth = rightPadding;\n      var totalTopBoxesHeight = topPadding;\n      var totalBottomBoxesHeight = bottomPadding; // Function to fit a box\n\n      function fitBox(box) {\n        var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBox) {\n          return minBox.box === box;\n        });\n\n        if (minBoxSize) {\n          if (box.isHorizontal()) {\n            var scaleMargin = {\n              left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\n              right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\n              top: 0,\n              bottom: 0\n            }; // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n            // on the margin. Sometimes they need to increase in size slightly\n\n            box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n          } else {\n            box.update(minBoxSize.minSize.width, maxChartAreaHeight);\n          }\n        }\n      } // Update, and calculate the left and right margins for the horizontal boxes\n\n\n      helpers.each(leftBoxes.concat(rightBoxes), fitBox);\n      helpers.each(leftBoxes, function (box) {\n        totalLeftBoxesWidth += box.width;\n      });\n      helpers.each(rightBoxes, function (box) {\n        totalRightBoxesWidth += box.width;\n      }); // Set the Left and Right margins for the horizontal boxes\n\n      helpers.each(topBoxes.concat(bottomBoxes), fitBox); // Figure out how much margin is on the top and bottom of the vertical boxes\n\n      helpers.each(topBoxes, function (box) {\n        totalTopBoxesHeight += box.height;\n      });\n      helpers.each(bottomBoxes, function (box) {\n        totalBottomBoxesHeight += box.height;\n      });\n\n      function finalFitVerticalBox(box) {\n        var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minSize) {\n          return minSize.box === box;\n        });\n        var scaleMargin = {\n          left: 0,\n          right: 0,\n          top: totalTopBoxesHeight,\n          bottom: totalBottomBoxesHeight\n        };\n\n        if (minBoxSize) {\n          box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n        }\n      } // Let the left layout know the final margin\n\n\n      helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox); // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\n      totalLeftBoxesWidth = leftPadding;\n      totalRightBoxesWidth = rightPadding;\n      totalTopBoxesHeight = topPadding;\n      totalBottomBoxesHeight = bottomPadding;\n      helpers.each(leftBoxes, function (box) {\n        totalLeftBoxesWidth += box.width;\n      });\n      helpers.each(rightBoxes, function (box) {\n        totalRightBoxesWidth += box.width;\n      });\n      helpers.each(topBoxes, function (box) {\n        totalTopBoxesHeight += box.height;\n      });\n      helpers.each(bottomBoxes, function (box) {\n        totalBottomBoxesHeight += box.height;\n      }); // We may be adding some padding to account for rotated x axis labels\n\n      var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\n      totalLeftBoxesWidth += leftPaddingAddition;\n      totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\n      var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\n      totalTopBoxesHeight += topPaddingAddition;\n      totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0); // Figure out if our chart area changed. This would occur if the dataset layout label rotation\n      // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n      // without calling `fit` again\n\n      var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n      var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n\n      if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n        helpers.each(leftBoxes, function (box) {\n          box.height = newMaxChartAreaHeight;\n        });\n        helpers.each(rightBoxes, function (box) {\n          box.height = newMaxChartAreaHeight;\n        });\n        helpers.each(topBoxes, function (box) {\n          if (!box.options.fullWidth) {\n            box.width = newMaxChartAreaWidth;\n          }\n        });\n        helpers.each(bottomBoxes, function (box) {\n          if (!box.options.fullWidth) {\n            box.width = newMaxChartAreaWidth;\n          }\n        });\n        maxChartAreaHeight = newMaxChartAreaHeight;\n        maxChartAreaWidth = newMaxChartAreaWidth;\n      } // Step 7 - Position the boxes\n\n\n      var left = leftPadding + leftPaddingAddition;\n      var top = topPadding + topPaddingAddition;\n\n      function placeBox(box) {\n        if (box.isHorizontal()) {\n          box.left = box.options.fullWidth ? leftPadding : totalLeftBoxesWidth;\n          box.right = box.options.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n          box.top = top;\n          box.bottom = top + box.height; // Move to next point\n\n          top = box.bottom;\n        } else {\n          box.left = left;\n          box.right = left + box.width;\n          box.top = totalTopBoxesHeight;\n          box.bottom = totalTopBoxesHeight + maxChartAreaHeight; // Move to next point\n\n          left = box.right;\n        }\n      }\n\n      helpers.each(leftBoxes.concat(topBoxes), placeBox); // Account for chart width and height\n\n      left += maxChartAreaWidth;\n      top += maxChartAreaHeight;\n      helpers.each(rightBoxes, placeBox);\n      helpers.each(bottomBoxes, placeBox); // Step 8\n\n      chartInstance.chartArea = {\n        left: totalLeftBoxesWidth,\n        top: totalTopBoxesHeight,\n        right: totalLeftBoxesWidth + maxChartAreaWidth,\n        bottom: totalTopBoxesHeight + maxChartAreaHeight\n      }; // Step 9\n\n      helpers.each(chartAreaBoxes, function (box) {\n        box.left = chartInstance.chartArea.left;\n        box.top = chartInstance.chartArea.top;\n        box.right = chartInstance.chartArea.right;\n        box.bottom = chartInstance.chartArea.bottom;\n        box.update(maxChartAreaWidth, maxChartAreaHeight);\n      });\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}