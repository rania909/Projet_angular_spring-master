{"ast":null,"code":"import _createClass from \"A:/machine learning/test/Projet_angular_spring/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"A:/machine learning/test/Projet_angular_spring/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\r\n * Jdenticon 3.1.1\r\n * http://jdenticon.com\r\n *\r\n * Built: 2021-08-14T17:50:52.207Z\r\n * \r\n * MIT License\r\n * \r\n * Copyright (c) 2014-2020 Daniel Mester Pirttijärvi\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\n\n/**\r\n * Parses a substring of the hash as a number.\r\n * @param {number} startPosition \r\n * @param {number=} octets\r\n */\nfunction parseHex(hash, startPosition, octets) {\n  return parseInt(hash.substr(startPosition, octets), 16);\n}\n\nfunction decToHex(v) {\n  v |= 0; // Ensure integer value\n\n  return v < 0 ? \"00\" : v < 16 ? \"0\" + v.toString(16) : v < 256 ? v.toString(16) : \"ff\";\n}\n\nfunction hueToRgb(m1, m2, h) {\n  h = h < 0 ? h + 6 : h > 6 ? h - 6 : h;\n  return decToHex(255 * (h < 1 ? m1 + (m2 - m1) * h : h < 3 ? m2 : h < 4 ? m1 + (m2 - m1) * (4 - h) : m1));\n}\n/**\r\n * @param {string} color  Color value to parse. Currently hexadecimal strings on the format #rgb[a] and #rrggbb[aa] are supported.\r\n * @returns {string}\r\n */\n\n\nfunction parseColor(color) {\n  if (/^#[0-9a-f]{3,8}$/i.test(color)) {\n    var result;\n    var colorLength = color.length;\n\n    if (colorLength < 6) {\n      var r = color[1],\n          g = color[2],\n          b = color[3],\n          a = color[4] || \"\";\n      result = \"#\" + r + r + g + g + b + b + a + a;\n    }\n\n    if (colorLength == 7 || colorLength > 8) {\n      result = color;\n    }\n\n    return result;\n  }\n}\n/**\r\n * Converts a hexadecimal color to a CSS3 compatible color.\r\n * @param {string} hexColor  Color on the format \"#RRGGBB\" or \"#RRGGBBAA\"\r\n * @returns {string}\r\n */\n\n\nfunction toCss3Color(hexColor) {\n  var a = parseHex(hexColor, 7, 2);\n  var result;\n\n  if (isNaN(a)) {\n    result = hexColor;\n  } else {\n    var r = parseHex(hexColor, 1, 2),\n        g = parseHex(hexColor, 3, 2),\n        b = parseHex(hexColor, 5, 2);\n    result = \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + (a / 255).toFixed(2) + \")\";\n  }\n\n  return result;\n}\n/**\r\n * Converts an HSL color to a hexadecimal RGB color.\r\n * @param {number} hue  Hue in range [0, 1]\r\n * @param {number} saturation  Saturation in range [0, 1]\r\n * @param {number} lightness  Lightness in range [0, 1]\r\n * @returns {string}\r\n */\n\n\nfunction hsl(hue, saturation, lightness) {\n  // Based on http://www.w3.org/TR/2011/REC-css3-color-20110607/#hsl-color\n  var result;\n\n  if (saturation == 0) {\n    var partialHex = decToHex(lightness * 255);\n    result = partialHex + partialHex + partialHex;\n  } else {\n    var m2 = lightness <= 0.5 ? lightness * (saturation + 1) : lightness + saturation - lightness * saturation,\n        m1 = lightness * 2 - m2;\n    result = hueToRgb(m1, m2, hue * 6 + 2) + hueToRgb(m1, m2, hue * 6) + hueToRgb(m1, m2, hue * 6 - 2);\n  }\n\n  return \"#\" + result;\n}\n/**\r\n * Converts an HSL color to a hexadecimal RGB color. This function will correct the lightness for the \"dark\" hues\r\n * @param {number} hue  Hue in range [0, 1]\r\n * @param {number} saturation  Saturation in range [0, 1]\r\n * @param {number} lightness  Lightness in range [0, 1]\r\n * @returns {string}\r\n */\n\n\nfunction correctedHsl(hue, saturation, lightness) {\n  // The corrector specifies the perceived middle lightness for each hue\n  var correctors = [0.55, 0.5, 0.5, 0.46, 0.6, 0.55, 0.55],\n      corrector = correctors[hue * 6 + 0.5 | 0]; // Adjust the input lightness relative to the corrector\n\n  lightness = lightness < 0.5 ? lightness * corrector * 2 : corrector + (lightness - 0.5) * (1 - corrector) * 2;\n  return hsl(hue, saturation, lightness);\n} // In the future we can replace `GLOBAL` with `globalThis`, but for now use the old school global detection for\n// backward compatibility.\n\n\nvar GLOBAL = typeof window !== \"undefined\" ? window : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : {};\n/**\r\n * @typedef {Object} ParsedConfiguration\r\n * @property {number} colorSaturation\r\n * @property {number} grayscaleSaturation\r\n * @property {string} backColor\r\n * @property {number} iconPadding\r\n * @property {function(number):number} hue\r\n * @property {function(number):number} colorLightness\r\n * @property {function(number):number} grayscaleLightness\r\n */\n\nvar CONFIG_PROPERTIES = {\n  V\n  /*GLOBAL*/\n  : \"jdenticon_config\",\n  n\n  /*MODULE*/\n  : \"config\"\n};\nvar rootConfigurationHolder = {};\n/**\r\n * Sets a new icon style configuration. The new configuration is not merged with the previous one. * \r\n * @param {Object} newConfiguration - New configuration object.\r\n */\n\nfunction configure(newConfiguration) {\n  if (arguments.length) {\n    rootConfigurationHolder[CONFIG_PROPERTIES.n\n    /*MODULE*/\n    ] = newConfiguration;\n  }\n\n  return rootConfigurationHolder[CONFIG_PROPERTIES.n\n  /*MODULE*/\n  ];\n}\n/**\r\n * Gets the normalized current Jdenticon color configuration. Missing fields have default values.\r\n * @param {Object|number|undefined} paddingOrLocalConfig - Configuration passed to the called API method. A\r\n *    local configuration overrides the global configuration in it entirety. This parameter can for backward\r\n *    compatibility also contain a padding value. A padding value only overrides the global padding, not the\r\n *    entire global configuration.\r\n * @param {number} defaultPadding - Padding used if no padding is specified in neither the configuration nor\r\n *    explicitly to the API method.\r\n * @returns {ParsedConfiguration}\r\n */\n\n\nfunction getConfiguration(paddingOrLocalConfig, defaultPadding) {\n  var configObject = typeof paddingOrLocalConfig == \"object\" && paddingOrLocalConfig || rootConfigurationHolder[CONFIG_PROPERTIES.n\n  /*MODULE*/\n  ] || GLOBAL[CONFIG_PROPERTIES.V\n  /*GLOBAL*/\n  ] || {},\n      lightnessConfig = configObject[\"lightness\"] || {},\n      // In versions < 2.1.0 there was no grayscale saturation -\n  // saturation was the color saturation.\n  saturation = configObject[\"saturation\"] || {},\n      colorSaturation = \"color\" in saturation ? saturation[\"color\"] : saturation,\n      grayscaleSaturation = saturation[\"grayscale\"],\n      backColor = configObject[\"backColor\"],\n      padding = configObject[\"padding\"];\n  /**\r\n   * Creates a lightness range.\r\n   */\n\n  function lightness(configName, defaultRange) {\n    var range = lightnessConfig[configName]; // Check if the lightness range is an array-like object. This way we ensure the\n    // array contain two values at the same time.\n\n    if (!(range && range.length > 1)) {\n      range = defaultRange;\n    }\n    /**\r\n     * Gets a lightness relative the specified value in the specified lightness range.\r\n     */\n\n\n    return function (value) {\n      value = range[0] + value * (range[1] - range[0]);\n      return value < 0 ? 0 : value > 1 ? 1 : value;\n    };\n  }\n  /**\r\n   * Gets a hue allowed by the configured hue restriction,\r\n   * provided the originally computed hue.\r\n   */\n\n\n  function hueFunction(originalHue) {\n    var hueConfig = configObject[\"hues\"];\n    var hue; // Check if 'hues' is an array-like object. This way we also ensure that\n    // the array is not empty, which would mean no hue restriction.\n\n    if (hueConfig && hueConfig.length > 0) {\n      // originalHue is in the range [0, 1]\n      // Multiply with 0.999 to change the range to [0, 1) and then truncate the index.\n      hue = hueConfig[0 | 0.999 * originalHue * hueConfig.length];\n    }\n\n    return typeof hue == \"number\" ? // A hue was specified. We need to convert the hue from\n    // degrees on any turn - e.g. 746° is a perfectly valid hue -\n    // to turns in the range [0, 1).\n    (hue / 360 % 1 + 1) % 1 : // No hue configured => use original hue\n    originalHue;\n  }\n\n  return {\n    W\n    /*hue*/\n    : hueFunction,\n    o\n    /*colorSaturation*/\n    : typeof colorSaturation == \"number\" ? colorSaturation : 0.5,\n    D\n    /*grayscaleSaturation*/\n    : typeof grayscaleSaturation == \"number\" ? grayscaleSaturation : 0,\n    p\n    /*colorLightness*/\n    : lightness(\"color\", [0.4, 0.8]),\n    F\n    /*grayscaleLightness*/\n    : lightness(\"grayscale\", [0.3, 0.9]),\n    G\n    /*backColor*/\n    : parseColor(backColor),\n    X\n    /*iconPadding*/\n    : typeof paddingOrLocalConfig == \"number\" ? paddingOrLocalConfig : typeof padding == \"number\" ? padding : defaultPadding\n  };\n}\n/**\r\n * Represents a point.\r\n */\n\n\nvar Point =\n/**\r\n * @param {number} x \r\n * @param {number} y \r\n */\nfunction Point(x, y) {\n  _classCallCheck(this, Point);\n\n  this.x = x;\n  this.y = y;\n};\n/**\r\n * Translates and rotates a point before being passed on to the canvas context. This was previously done by the canvas context itself, \r\n * but this caused a rendering issue in Chrome on sizes > 256 where the rotation transformation of inverted paths was not done properly.\r\n */\n\n\nvar Transform = /*#__PURE__*/function () {\n  /**\r\n   * @param {number} x The x-coordinate of the upper left corner of the transformed rectangle.\r\n   * @param {number} y The y-coordinate of the upper left corner of the transformed rectangle.\r\n   * @param {number} size The size of the transformed rectangle.\r\n   * @param {number} rotation Rotation specified as 0 = 0 rad, 1 = 0.5π rad, 2 = π rad, 3 = 1.5π rad\r\n   */\n  function Transform(x, y, size, rotation) {\n    _classCallCheck(this, Transform);\n\n    this.q\n    /*_x*/\n    = x;\n    this.t\n    /*_y*/\n    = y;\n    this.H\n    /*_size*/\n    = size;\n    this.Y\n    /*_rotation*/\n    = rotation;\n  }\n  /**\r\n   * Transforms the specified point based on the translation and rotation specification for this Transform.\r\n   * @param {number} x x-coordinate\r\n   * @param {number} y y-coordinate\r\n   * @param {number=} w The width of the transformed rectangle. If greater than 0, this will ensure the returned point is of the upper left corner of the transformed rectangle.\r\n   * @param {number=} h The height of the transformed rectangle. If greater than 0, this will ensure the returned point is of the upper left corner of the transformed rectangle.\r\n   */\n\n\n  _createClass(Transform, [{\n    key: \"I\",\n    value: function I(x, y, w, h) {\n      var right = this.q\n      /*_x*/\n      + this.H\n      /*_size*/\n      ,\n          bottom = this.t\n      /*_y*/\n      + this.H\n      /*_size*/\n      ,\n          rotation = this.Y\n      /*_rotation*/\n      ;\n      return rotation === 1 ? new Point(right - y - (h || 0), this.t\n      /*_y*/\n      + x) : rotation === 2 ? new Point(right - x - (w || 0), bottom - y - (h || 0)) : rotation === 3 ? new Point(this.q\n      /*_x*/\n      + y, bottom - x - (w || 0)) : new Point(this.q\n      /*_x*/\n      + x, this.t\n      /*_y*/\n      + y);\n    }\n  }]);\n\n  return Transform;\n}();\n\nvar NO_TRANSFORM = new Transform(0, 0, 0, 0);\n/**\r\n * Provides helper functions for rendering common basic shapes.\r\n */\n\nvar Graphics = /*#__PURE__*/function () {\n  /**\r\n   * @param {Renderer} renderer \r\n   */\n  function Graphics(renderer) {\n    _classCallCheck(this, Graphics);\n\n    /**\r\n     * @type {Renderer}\r\n     * @private\r\n     */\n    this.J\n    /*_renderer*/\n    = renderer;\n    /**\r\n     * @type {Transform}\r\n     */\n\n    this.u\n    /*currentTransform*/\n    = NO_TRANSFORM;\n  }\n  /**\r\n   * Adds a polygon to the underlying renderer.\r\n   * @param {Array<number>} points The points of the polygon clockwise on the format [ x0, y0, x1, y1, ..., xn, yn ]\r\n   * @param {boolean=} invert Specifies if the polygon will be inverted.\r\n   */\n\n\n  _createClass(Graphics, [{\n    key: \"g\",\n    value: function g(points, invert) {\n      var di = invert ? -2 : 2,\n          transformedPoints = [];\n\n      for (var i = invert ? points.length - 2 : 0; i < points.length && i >= 0; i += di) {\n        transformedPoints.push(this.u\n        /*currentTransform*/\n        .I\n        /*transformIconPoint*/\n        (points[i], points[i + 1]));\n      }\n\n      this.J\n      /*_renderer*/\n      .g\n      /*addPolygon*/\n      (transformedPoints);\n    }\n    /**\r\n     * Adds a polygon to the underlying renderer.\r\n     * Source: http://stackoverflow.com/a/2173084\r\n     * @param {number} x The x-coordinate of the upper left corner of the rectangle holding the entire ellipse.\r\n     * @param {number} y The y-coordinate of the upper left corner of the rectangle holding the entire ellipse.\r\n     * @param {number} size The size of the ellipse.\r\n     * @param {boolean=} invert Specifies if the ellipse will be inverted.\r\n     */\n\n  }, {\n    key: \"h\",\n    value: function h(x, y, size, invert) {\n      var p = this.u\n      /*currentTransform*/\n      .I\n      /*transformIconPoint*/\n      (x, y, size, size);\n      this.J\n      /*_renderer*/\n      .h\n      /*addCircle*/\n      (p, size, invert);\n    }\n    /**\r\n     * Adds a rectangle to the underlying renderer.\r\n     * @param {number} x The x-coordinate of the upper left corner of the rectangle.\r\n     * @param {number} y The y-coordinate of the upper left corner of the rectangle.\r\n     * @param {number} w The width of the rectangle.\r\n     * @param {number} h The height of the rectangle.\r\n     * @param {boolean=} invert Specifies if the rectangle will be inverted.\r\n     */\n\n  }, {\n    key: \"i\",\n    value: function i(x, y, w, h, invert) {\n      this.g\n      /*addPolygon*/\n      ([x, y, x + w, y, x + w, y + h, x, y + h], invert);\n    }\n    /**\r\n     * Adds a right triangle to the underlying renderer.\r\n     * @param {number} x The x-coordinate of the upper left corner of the rectangle holding the triangle.\r\n     * @param {number} y The y-coordinate of the upper left corner of the rectangle holding the triangle.\r\n     * @param {number} w The width of the triangle.\r\n     * @param {number} h The height of the triangle.\r\n     * @param {number} r The rotation of the triangle (clockwise). 0 = right corner of the triangle in the lower left corner of the bounding rectangle.\r\n     * @param {boolean=} invert Specifies if the triangle will be inverted.\r\n     */\n\n  }, {\n    key: \"j\",\n    value: function j(x, y, w, h, r, invert) {\n      var points = [x + w, y, x + w, y + h, x, y + h, x, y];\n      points.splice((r || 0) % 4 * 2, 2);\n      this.g\n      /*addPolygon*/\n      (points, invert);\n    }\n    /**\r\n     * Adds a rhombus to the underlying renderer.\r\n     * @param {number} x The x-coordinate of the upper left corner of the rectangle holding the rhombus.\r\n     * @param {number} y The y-coordinate of the upper left corner of the rectangle holding the rhombus.\r\n     * @param {number} w The width of the rhombus.\r\n     * @param {number} h The height of the rhombus.\r\n     * @param {boolean=} invert Specifies if the rhombus will be inverted.\r\n     */\n\n  }, {\n    key: \"K\",\n    value: function K(x, y, w, h, invert) {\n      this.g\n      /*addPolygon*/\n      ([x + w / 2, y, x + w, y + h / 2, x + w / 2, y + h, x, y + h / 2], invert);\n    }\n  }]);\n\n  return Graphics;\n}();\n/**\r\n * @param {number} index\r\n * @param {Graphics} g\r\n * @param {number} cell\r\n * @param {number} positionIndex\r\n */\n\n\nfunction centerShape(index, g, cell, positionIndex) {\n  index = index % 14;\n  var k, m, w, h, inner, outer;\n  !index ? (k = cell * 0.42, g.g\n  /*addPolygon*/\n  ([0, 0, cell, 0, cell, cell - k * 2, cell - k, cell, 0, cell])) : index == 1 ? (w = 0 | cell * 0.5, h = 0 | cell * 0.8, g.j\n  /*addTriangle*/\n  (cell - w, 0, w, h, 2)) : index == 2 ? (w = 0 | cell / 3, g.i\n  /*addRectangle*/\n  (w, w, cell - w, cell - w)) : index == 3 ? (inner = cell * 0.1, // Use fixed outer border widths in small icons to ensure the border is drawn\n  outer = cell < 6 ? 1 : cell < 8 ? 2 : 0 | cell * 0.25, inner = inner > 1 ? 0 | inner : // large icon => truncate decimals\n  inner > 0.5 ? 1 : // medium size icon => fixed width\n  inner, // small icon => anti-aliased border\n  g.i\n  /*addRectangle*/\n  (outer, outer, cell - inner - outer, cell - inner - outer)) : index == 4 ? (m = 0 | cell * 0.15, w = 0 | cell * 0.5, g.h\n  /*addCircle*/\n  (cell - w - m, cell - w - m, w)) : index == 5 ? (inner = cell * 0.1, outer = inner * 4, // Align edge to nearest pixel in large icons\n  outer > 3 && (outer = 0 | outer), g.i\n  /*addRectangle*/\n  (0, 0, cell, cell), g.g\n  /*addPolygon*/\n  ([outer, outer, cell - inner, outer, outer + (cell - outer - inner) / 2, cell - inner], true)) : index == 6 ? g.g\n  /*addPolygon*/\n  ([0, 0, cell, 0, cell, cell * 0.7, cell * 0.4, cell * 0.4, cell * 0.7, cell, 0, cell]) : index == 7 ? g.j\n  /*addTriangle*/\n  (cell / 2, cell / 2, cell / 2, cell / 2, 3) : index == 8 ? (g.i\n  /*addRectangle*/\n  (0, 0, cell, cell / 2), g.i\n  /*addRectangle*/\n  (0, cell / 2, cell / 2, cell / 2), g.j\n  /*addTriangle*/\n  (cell / 2, cell / 2, cell / 2, cell / 2, 1)) : index == 9 ? (inner = cell * 0.14, // Use fixed outer border widths in small icons to ensure the border is drawn\n  outer = cell < 4 ? 1 : cell < 6 ? 2 : 0 | cell * 0.35, inner = cell < 8 ? inner : // small icon => anti-aliased border\n  0 | inner, // large icon => truncate decimals\n  g.i\n  /*addRectangle*/\n  (0, 0, cell, cell), g.i\n  /*addRectangle*/\n  (outer, outer, cell - outer - inner, cell - outer - inner, true)) : index == 10 ? (inner = cell * 0.12, outer = inner * 3, g.i\n  /*addRectangle*/\n  (0, 0, cell, cell), g.h\n  /*addCircle*/\n  (outer, outer, cell - inner - outer, true)) : index == 11 ? g.j\n  /*addTriangle*/\n  (cell / 2, cell / 2, cell / 2, cell / 2, 3) : index == 12 ? (m = cell * 0.25, g.i\n  /*addRectangle*/\n  (0, 0, cell, cell), g.K\n  /*addRhombus*/\n  (m, m, cell - m, cell - m, true)) : // 13\n  !positionIndex && (m = cell * 0.4, w = cell * 1.2, g.h\n  /*addCircle*/\n  (m, m, w));\n}\n/**\r\n * @param {number} index\r\n * @param {Graphics} g\r\n * @param {number} cell\r\n */\n\n\nfunction outerShape(index, g, cell) {\n  index = index % 4;\n  var m;\n  !index ? g.j\n  /*addTriangle*/\n  (0, 0, cell, cell, 0) : index == 1 ? g.j\n  /*addTriangle*/\n  (0, cell / 2, cell, cell / 2, 0) : index == 2 ? g.K\n  /*addRhombus*/\n  (0, 0, cell, cell) : ( // 3\n  m = cell / 6, g.h\n  /*addCircle*/\n  (m, m, cell - 2 * m));\n}\n/**\r\n * Gets a set of identicon color candidates for a specified hue and config.\r\n * @param {number} hue\r\n * @param {ParsedConfiguration} config\r\n */\n\n\nfunction colorTheme(hue, config) {\n  hue = config.W\n  /*hue*/\n  (hue);\n  return [// Dark gray\n  correctedHsl(hue, config.D\n  /*grayscaleSaturation*/\n  , config.F\n  /*grayscaleLightness*/\n  (0)), // Mid color\n  correctedHsl(hue, config.o\n  /*colorSaturation*/\n  , config.p\n  /*colorLightness*/\n  (0.5)), // Light gray\n  correctedHsl(hue, config.D\n  /*grayscaleSaturation*/\n  , config.F\n  /*grayscaleLightness*/\n  (1)), // Light color\n  correctedHsl(hue, config.o\n  /*colorSaturation*/\n  , config.p\n  /*colorLightness*/\n  (1)), // Dark color\n  correctedHsl(hue, config.o\n  /*colorSaturation*/\n  , config.p\n  /*colorLightness*/\n  (0))];\n}\n/**\r\n * Draws an identicon to a specified renderer.\r\n * @param {Renderer} renderer\r\n * @param {string} hash\r\n * @param {Object|number=} config\r\n */\n\n\nfunction iconGenerator(renderer, hash, config) {\n  var parsedConfig = getConfiguration(config, 0.08); // Set background color\n\n  if (parsedConfig.G\n  /*backColor*/\n  ) {\n    renderer.m\n    /*setBackground*/\n    (parsedConfig.G\n    /*backColor*/\n    );\n  } // Calculate padding and round to nearest integer\n\n\n  var size = renderer.k\n  /*iconSize*/\n  ;\n  var padding = 0.5 + size * parsedConfig.X\n  /*iconPadding*/\n  | 0;\n  size -= padding * 2;\n  var graphics = new Graphics(renderer); // Calculate cell size and ensure it is an integer\n\n  var cell = 0 | size / 4; // Since the cell size is integer based, the actual icon will be slightly smaller than specified => center icon\n\n  var x = 0 | padding + size / 2 - cell * 2;\n  var y = 0 | padding + size / 2 - cell * 2;\n\n  function renderShape(colorIndex, shapes, index, rotationIndex, positions) {\n    var shapeIndex = parseHex(hash, index, 1);\n    var r = rotationIndex ? parseHex(hash, rotationIndex, 1) : 0;\n    renderer.L\n    /*beginShape*/\n    (availableColors[selectedColorIndexes[colorIndex]]);\n\n    for (var i = 0; i < positions.length; i++) {\n      graphics.u\n      /*currentTransform*/\n      = new Transform(x + positions[i][0] * cell, y + positions[i][1] * cell, cell, r++ % 4);\n      shapes(shapeIndex, graphics, cell, i);\n    }\n\n    renderer.M\n    /*endShape*/\n    ();\n  } // AVAILABLE COLORS\n\n\n  var hue = parseHex(hash, -7) / 0xfffffff,\n      // Available colors for this icon\n  availableColors = colorTheme(hue, parsedConfig),\n      // The index of the selected colors\n  selectedColorIndexes = [];\n  var index;\n\n  function isDuplicate(values) {\n    if (values.indexOf(index) >= 0) {\n      for (var i = 0; i < values.length; i++) {\n        if (selectedColorIndexes.indexOf(values[i]) >= 0) {\n          return true;\n        }\n      }\n    }\n  }\n\n  for (var i = 0; i < 3; i++) {\n    index = parseHex(hash, 8 + i, 1) % availableColors.length;\n\n    if (isDuplicate([0, 4]) || // Disallow dark gray and dark color combo\n    isDuplicate([2, 3])) {\n      // Disallow light gray and light color combo\n      index = 1;\n    }\n\n    selectedColorIndexes.push(index);\n  } // ACTUAL RENDERING\n  // Sides\n\n\n  renderShape(0, outerShape, 2, 3, [[1, 0], [2, 0], [2, 3], [1, 3], [0, 1], [3, 1], [3, 2], [0, 2]]); // Corners\n\n  renderShape(1, outerShape, 4, 5, [[0, 0], [3, 0], [3, 3], [0, 3]]); // Center\n\n  renderShape(2, centerShape, 1, null, [[1, 1], [2, 1], [2, 2], [1, 2]]);\n  renderer.finish();\n}\n/**\r\n * Computes a SHA1 hash for any value and returns it as a hexadecimal string.\r\n * \r\n * This function is optimized for minimal code size and rather short messages.\r\n * \r\n * @param {string} message \r\n */\n\n\nfunction sha1(message) {\n  var HASH_SIZE_HALF_BYTES = 40;\n  var BLOCK_SIZE_WORDS = 16; // Variables\n  // `var` is used to be able to minimize the number of `var` keywords.\n\n  var i = 0,\n      f = 0,\n      // Use `encodeURI` to UTF8 encode the message without any additional libraries\n  // We could use `unescape` + `encodeURI` to minimize the code, but that would be slightly risky\n  // since `unescape` is deprecated.\n  urlEncodedMessage = encodeURI(message) + \"%80\",\n      // trailing '1' bit padding\n  // This can be changed to a preallocated Uint32Array array for greater performance and larger code size\n  data = [],\n      dataSize,\n      hashBuffer = [],\n      a = 0x67452301,\n      b = 0xefcdab89,\n      c = ~a,\n      d = ~b,\n      e = 0xc3d2e1f0,\n      hash = [a, b, c, d, e],\n      blockStartIndex = 0,\n      hexHash = \"\";\n  /**\r\n   * Rotates the value a specified number of bits to the left.\r\n   * @param {number} value  Value to rotate\r\n   * @param {number} shift  Bit count to shift.\r\n   */\n\n  function rotl(value, shift) {\n    return value << shift | value >>> 32 - shift;\n  } // Message data\n\n\n  for (; i < urlEncodedMessage.length; f++) {\n    data[f >> 2] = data[f >> 2] | (urlEncodedMessage[i] == \"%\" // Percent encoded byte\n    ? parseInt(urlEncodedMessage.substring(i + 1, i += 3), 16) // Unencoded byte\n    : urlEncodedMessage.charCodeAt(i++) // Read bytes in reverse order (big endian words)\n    ) << (3 - (f & 3)) * 8;\n  } // f is now the length of the utf8 encoded message\n  // 7 = 8 bytes (64 bit) for message size, -1 to round down\n  // >> 6 = integer division with block size\n\n\n  dataSize = ((f + 7 >> 6) + 1) * BLOCK_SIZE_WORDS; // Message size in bits.\n  // SHA1 uses a 64 bit integer to represent the size, but since we only support short messages only the least\n  // significant 32 bits are set. -8 is for the '1' bit padding byte.\n\n  data[dataSize - 1] = f * 8 - 8; // Compute hash\n\n  for (; blockStartIndex < dataSize; blockStartIndex += BLOCK_SIZE_WORDS) {\n    for (i = 0; i < 80; i++) {\n      f = rotl(a, 5) + e + ( // Ch\n      i < 20 ? (b & c ^ ~b & d) + 0x5a827999 : // Parity\n      i < 40 ? (b ^ c ^ d) + 0x6ed9eba1 : // Maj\n      i < 60 ? (b & c ^ b & d ^ c & d) + 0x8f1bbcdc : // Parity\n      (b ^ c ^ d) + 0xca62c1d6) + (hashBuffer[i] = i < BLOCK_SIZE_WORDS // Bitwise OR is used to coerse `undefined` to 0\n      ? data[blockStartIndex + i] | 0 : rotl(hashBuffer[i - 3] ^ hashBuffer[i - 8] ^ hashBuffer[i - 14] ^ hashBuffer[i - 16], 1));\n      e = d;\n      d = c;\n      c = rotl(b, 30);\n      b = a;\n      a = f;\n    }\n\n    hash[0] = a = hash[0] + a | 0;\n    hash[1] = b = hash[1] + b | 0;\n    hash[2] = c = hash[2] + c | 0;\n    hash[3] = d = hash[3] + d | 0;\n    hash[4] = e = hash[4] + e | 0;\n  } // Format hex hash\n\n\n  for (i = 0; i < HASH_SIZE_HALF_BYTES; i++) {\n    hexHash += ( // Get word (2^3 half-bytes per word)\n    hash[i >> 3] >>> // Append half-bytes in reverse order\n    (7 - (i & 7)) * 4 // Clamp to half-byte\n    & 0xf).toString(16);\n  }\n\n  return hexHash;\n}\n/**\r\n * Inputs a value that might be a valid hash string for Jdenticon and returns it \r\n * if it is determined valid, otherwise a falsy value is returned.\r\n */\n\n\nfunction isValidHash(hashCandidate) {\n  return /^[0-9a-f]{11,}$/i.test(hashCandidate) && hashCandidate;\n}\n/**\r\n * Computes a hash for the specified value. Currently SHA1 is used. This function\r\n * always returns a valid hash.\r\n */\n\n\nfunction computeHash(value) {\n  return sha1(value == null ? \"\" : \"\" + value);\n}\n/**\r\n * Renderer redirecting drawing commands to a canvas context.\r\n * @implements {Renderer}\r\n */\n\n\nvar CanvasRenderer = /*#__PURE__*/function () {\n  /**\r\n   * @param {number=} iconSize\r\n   */\n  function CanvasRenderer(ctx, iconSize) {\n    _classCallCheck(this, CanvasRenderer);\n\n    var canvas = ctx.canvas;\n    var width = canvas.width;\n    var height = canvas.height;\n    ctx.save();\n\n    if (!iconSize) {\n      iconSize = Math.min(width, height);\n      ctx.translate((width - iconSize) / 2 | 0, (height - iconSize) / 2 | 0);\n    }\n    /**\r\n     * @private\r\n     */\n\n\n    this.l\n    /*_ctx*/\n    = ctx;\n    this.k\n    /*iconSize*/\n    = iconSize;\n    ctx.clearRect(0, 0, iconSize, iconSize);\n  }\n  /**\r\n   * Fills the background with the specified color.\r\n   * @param {string} fillColor  Fill color on the format #rrggbb[aa].\r\n   */\n\n\n  _createClass(CanvasRenderer, [{\n    key: \"m\",\n    value: function m(fillColor) {\n      var ctx = this.l\n      /*_ctx*/\n      ;\n      var iconSize = this.k\n      /*iconSize*/\n      ;\n      ctx.fillStyle = toCss3Color(fillColor);\n      ctx.fillRect(0, 0, iconSize, iconSize);\n    }\n    /**\r\n     * Marks the beginning of a new shape of the specified color. Should be ended with a call to endShape.\r\n     * @param {string} fillColor Fill color on format #rrggbb[aa].\r\n     */\n\n  }, {\n    key: \"L\",\n    value: function L(fillColor) {\n      var ctx = this.l\n      /*_ctx*/\n      ;\n      ctx.fillStyle = toCss3Color(fillColor);\n      ctx.beginPath();\n    }\n    /**\r\n     * Marks the end of the currently drawn shape. This causes the queued paths to be rendered on the canvas.\r\n     */\n\n  }, {\n    key: \"M\",\n    value: function M() {\n      this.l\n      /*_ctx*/\n      .fill();\n    }\n    /**\r\n     * Adds a polygon to the rendering queue.\r\n     * @param points An array of Point objects.\r\n     */\n\n  }, {\n    key: \"g\",\n    value: function g(points) {\n      var ctx = this.l\n      /*_ctx*/\n      ;\n      ctx.moveTo(points[0].x, points[0].y);\n\n      for (var i = 1; i < points.length; i++) {\n        ctx.lineTo(points[i].x, points[i].y);\n      }\n\n      ctx.closePath();\n    }\n    /**\r\n     * Adds a circle to the rendering queue.\r\n     * @param {Point} point The upper left corner of the circle bounding box.\r\n     * @param {number} diameter The diameter of the circle.\r\n     * @param {boolean} counterClockwise True if the circle is drawn counter-clockwise (will result in a hole if rendered on a clockwise path).\r\n     */\n\n  }, {\n    key: \"h\",\n    value: function h(point, diameter, counterClockwise) {\n      var ctx = this.l\n      /*_ctx*/\n      ,\n          radius = diameter / 2;\n      ctx.moveTo(point.x + radius, point.y + radius);\n      ctx.arc(point.x + radius, point.y + radius, radius, 0, Math.PI * 2, counterClockwise);\n      ctx.closePath();\n    }\n    /**\r\n     * Called when the icon has been completely drawn.\r\n     */\n\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.l\n      /*_ctx*/\n      .restore();\n    }\n  }]);\n\n  return CanvasRenderer;\n}();\n/**\r\n * Draws an identicon to a context.\r\n * @param {CanvasRenderingContext2D} ctx - Canvas context on which the icon will be drawn at location (0, 0).\r\n * @param {*} hashOrValue - A hexadecimal hash string or any value that will be hashed by Jdenticon.\r\n * @param {number} size - Icon size in pixels.\r\n * @param {Object|number=} config - Optional configuration. If specified, this configuration object overrides any\r\n *    global configuration in its entirety. For backward compatibility a padding value in the range [0.0, 0.5) can be\r\n *    specified in place of a configuration object.\r\n */\n\n\nfunction drawIcon(ctx, hashOrValue, size, config) {\n  if (!ctx) {\n    throw new Error(\"No canvas specified.\");\n  }\n\n  iconGenerator(new CanvasRenderer(ctx, size), isValidHash(hashOrValue) || computeHash(hashOrValue), config);\n}\n/**\r\n * Prepares a measure to be used as a measure in an SVG path, by\r\n * rounding the measure to a single decimal. This reduces the file\r\n * size of the generated SVG with more than 50% in some cases.\r\n */\n\n\nfunction svgValue(value) {\n  return (value * 10 + 0.5 | 0) / 10;\n}\n/**\r\n * Represents an SVG path element.\r\n */\n\n\nvar SvgPath = /*#__PURE__*/function () {\n  function SvgPath() {\n    _classCallCheck(this, SvgPath);\n\n    /**\r\n     * This property holds the data string (path.d) of the SVG path.\r\n     * @type {string}\r\n     */\n    this.v\n    /*dataString*/\n    = \"\";\n  }\n  /**\r\n   * Adds a polygon with the current fill color to the SVG path.\r\n   * @param points An array of Point objects.\r\n   */\n\n\n  _createClass(SvgPath, [{\n    key: \"g\",\n    value: function g(points) {\n      var dataString = \"\";\n\n      for (var i = 0; i < points.length; i++) {\n        dataString += (i ? \"L\" : \"M\") + svgValue(points[i].x) + \" \" + svgValue(points[i].y);\n      }\n\n      this.v\n      /*dataString*/\n      += dataString + \"Z\";\n    }\n    /**\r\n     * Adds a circle with the current fill color to the SVG path.\r\n     * @param {Point} point The upper left corner of the circle bounding box.\r\n     * @param {number} diameter The diameter of the circle.\r\n     * @param {boolean} counterClockwise True if the circle is drawn counter-clockwise (will result in a hole if rendered on a clockwise path).\r\n     */\n\n  }, {\n    key: \"h\",\n    value: function h(point, diameter, counterClockwise) {\n      var sweepFlag = counterClockwise ? 0 : 1,\n          svgRadius = svgValue(diameter / 2),\n          svgDiameter = svgValue(diameter),\n          svgArc = \"a\" + svgRadius + \",\" + svgRadius + \" 0 1,\" + sweepFlag + \" \";\n      this.v\n      /*dataString*/\n      += \"M\" + svgValue(point.x) + \" \" + svgValue(point.y + diameter / 2) + svgArc + svgDiameter + \",0\" + svgArc + -svgDiameter + \",0\";\n    }\n  }]);\n\n  return SvgPath;\n}();\n/**\r\n * Renderer producing SVG output.\r\n * @implements {Renderer}\r\n */\n\n\nvar SvgRenderer = /*#__PURE__*/function () {\n  /**\r\n   * @param {SvgElement|SvgWriter} target \r\n   */\n  function SvgRenderer(target) {\n    _classCallCheck(this, SvgRenderer);\n\n    /**\r\n     * @type {SvgPath}\r\n     * @private\r\n     */\n    this.A\n    /*_path*/\n    ;\n    /**\r\n     * @type {Object.<string,SvgPath>}\r\n     * @private\r\n     */\n\n    this.B\n    /*_pathsByColor*/\n    = {};\n    /**\r\n     * @type {SvgElement|SvgWriter}\r\n     * @private\r\n     */\n\n    this.N\n    /*_target*/\n    = target;\n    /**\r\n     * @type {number}\r\n     */\n\n    this.k\n    /*iconSize*/\n    = target.k\n    /*iconSize*/\n    ;\n  }\n  /**\r\n   * Fills the background with the specified color.\r\n   * @param {string} fillColor  Fill color on the format #rrggbb[aa].\r\n   */\n\n\n  _createClass(SvgRenderer, [{\n    key: \"m\",\n    value: function m(fillColor) {\n      var match = /^(#......)(..)?/.exec(fillColor),\n          opacity = match[2] ? parseHex(match[2], 0) / 255 : 1;\n      this.N\n      /*_target*/\n      .m\n      /*setBackground*/\n      (match[1], opacity);\n    }\n    /**\r\n     * Marks the beginning of a new shape of the specified color. Should be ended with a call to endShape.\r\n     * @param {string} color Fill color on format #xxxxxx.\r\n     */\n\n  }, {\n    key: \"L\",\n    value: function L(color) {\n      this.A\n      /*_path*/\n      = this.B\n      /*_pathsByColor*/\n      [color] || (this.B\n      /*_pathsByColor*/\n      [color] = new SvgPath());\n    }\n    /**\r\n     * Marks the end of the currently drawn shape.\r\n     */\n\n  }, {\n    key: \"M\",\n    value: function M() {}\n    /**\r\n     * Adds a polygon with the current fill color to the SVG.\r\n     * @param points An array of Point objects.\r\n     */\n\n  }, {\n    key: \"g\",\n    value: function g(points) {\n      this.A\n      /*_path*/\n      .g\n      /*addPolygon*/\n      (points);\n    }\n    /**\r\n     * Adds a circle with the current fill color to the SVG.\r\n     * @param {Point} point The upper left corner of the circle bounding box.\r\n     * @param {number} diameter The diameter of the circle.\r\n     * @param {boolean} counterClockwise True if the circle is drawn counter-clockwise (will result in a hole if rendered on a clockwise path).\r\n     */\n\n  }, {\n    key: \"h\",\n    value: function h(point, diameter, counterClockwise) {\n      this.A\n      /*_path*/\n      .h\n      /*addCircle*/\n      (point, diameter, counterClockwise);\n    }\n    /**\r\n     * Called when the icon has been completely drawn.\r\n     */\n\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      var pathsByColor = this.B\n      /*_pathsByColor*/\n      ;\n\n      for (var color in pathsByColor) {\n        // hasOwnProperty cannot be shadowed in pathsByColor\n        // eslint-disable-next-line no-prototype-builtins\n        if (pathsByColor.hasOwnProperty(color)) {\n          this.N\n          /*_target*/\n          .O\n          /*appendPath*/\n          (color, pathsByColor[color].v\n          /*dataString*/\n          );\n        }\n      }\n    }\n  }]);\n\n  return SvgRenderer;\n}();\n\nvar SVG_CONSTANTS = {\n  P\n  /*XMLNS*/\n  : \"http://www.w3.org/2000/svg\",\n  R\n  /*WIDTH*/\n  : \"width\",\n  S\n  /*HEIGHT*/\n  : \"height\"\n};\n/**\r\n * Renderer producing SVG output.\r\n */\n\nvar SvgWriter = /*#__PURE__*/function () {\n  /**\r\n   * @param {number} iconSize - Icon width and height in pixels.\r\n   */\n  function SvgWriter(iconSize) {\n    _classCallCheck(this, SvgWriter);\n\n    /**\r\n     * @type {number}\r\n     */\n    this.k\n    /*iconSize*/\n    = iconSize;\n    /**\r\n     * @type {string}\r\n     * @private\r\n     */\n\n    this.C\n    /*_s*/\n    = '<svg xmlns=\"' + SVG_CONSTANTS.P\n    /*XMLNS*/\n    + '\" width=\"' + iconSize + '\" height=\"' + iconSize + '\" viewBox=\"0 0 ' + iconSize + ' ' + iconSize + '\">';\n  }\n  /**\r\n   * Fills the background with the specified color.\r\n   * @param {string} fillColor  Fill color on the format #rrggbb.\r\n   * @param {number} opacity  Opacity in the range [0.0, 1.0].\r\n   */\n\n\n  _createClass(SvgWriter, [{\n    key: \"m\",\n    value: function m(fillColor, opacity) {\n      if (opacity) {\n        this.C\n        /*_s*/\n        += '<rect width=\"100%\" height=\"100%\" fill=\"' + fillColor + '\" opacity=\"' + opacity.toFixed(2) + '\"/>';\n      }\n    }\n    /**\r\n     * Writes a path to the SVG string.\r\n     * @param {string} color Fill color on format #rrggbb.\r\n     * @param {string} dataString The SVG path data string.\r\n     */\n\n  }, {\n    key: \"O\",\n    value: function O(color, dataString) {\n      this.C\n      /*_s*/\n      += '<path fill=\"' + color + '\" d=\"' + dataString + '\"/>';\n    }\n    /**\r\n     * Gets the rendered image as an SVG string.\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.C\n      /*_s*/\n      + \"</svg>\";\n    }\n  }]);\n\n  return SvgWriter;\n}();\n/**\r\n * Draws an identicon as an SVG string.\r\n * @param {*} hashOrValue - A hexadecimal hash string or any value that will be hashed by Jdenticon.\r\n * @param {number} size - Icon size in pixels.\r\n * @param {Object|number=} config - Optional configuration. If specified, this configuration object overrides any\r\n *    global configuration in its entirety. For backward compatibility a padding value in the range [0.0, 0.5) can be\r\n *    specified in place of a configuration object.\r\n * @returns {string} SVG string\r\n */\n\n\nfunction toSvg(hashOrValue, size, config) {\n  var writer = new SvgWriter(size);\n  iconGenerator(new SvgRenderer(writer), isValidHash(hashOrValue) || computeHash(hashOrValue), config);\n  return writer.toString();\n}\n\nvar ICON_TYPE_SVG = 1;\nvar ICON_TYPE_CANVAS = 2;\nvar ATTRIBUTES = {\n  Z\n  /*HASH*/\n  : \"data-jdenticon-hash\",\n  T\n  /*VALUE*/\n  : \"data-jdenticon-value\"\n};\nvar documentQuerySelectorAll =\n/** @type {!Function} */\ntypeof document !== \"undefined\" && document.querySelectorAll.bind(document);\n\nfunction getIdenticonType(el) {\n  if (el) {\n    var tagName = el[\"tagName\"];\n\n    if (/^svg$/i.test(tagName)) {\n      return ICON_TYPE_SVG;\n    }\n\n    if (/^canvas$/i.test(tagName) && \"getContext\" in el) {\n      return ICON_TYPE_CANVAS;\n    }\n  }\n}\n/**\r\n * Creates a new element and adds it to the specified parent.\r\n * @param {Element} parentNode\r\n * @param {string} name\r\n * @param {...(string|number)} keyValuePairs\r\n */\n\n\nfunction SvgElement_append(parentNode, name) {\n  var el = document.createElementNS(SVG_CONSTANTS.P\n  /*XMLNS*/\n  , name);\n\n  for (var i = 0; i + 1 < (arguments.length <= 2 ? 0 : arguments.length - 2); i += 2) {\n    el.setAttribute(\n    /** @type {string} */\n    i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2],\n    /** @type {string} */\n    i + 1 + 2 < 2 || arguments.length <= i + 1 + 2 ? undefined : arguments[i + 1 + 2]);\n  }\n\n  parentNode.appendChild(el);\n}\n/**\r\n * Renderer producing SVG output.\r\n */\n\n\nvar SvgElement = /*#__PURE__*/function () {\n  /**\r\n   * @param {Element} element - Target element\r\n   */\n  function SvgElement(element) {\n    _classCallCheck(this, SvgElement);\n\n    // Don't use the clientWidth and clientHeight properties on SVG elements\n    // since Firefox won't serve a proper value of these properties on SVG\n    // elements (https://bugzilla.mozilla.org/show_bug.cgi?id=874811)\n    // Instead use 100px as a hardcoded size (the svg viewBox will rescale \n    // the icon to the correct dimensions)\n    var iconSize = this.k\n    /*iconSize*/\n    = Math.min(Number(element.getAttribute(SVG_CONSTANTS.R\n    /*WIDTH*/\n    )) || 100, Number(element.getAttribute(SVG_CONSTANTS.S\n    /*HEIGHT*/\n    )) || 100);\n    /**\r\n     * @type {Element}\r\n     * @private\r\n     */\n\n    this.U\n    /*_el*/\n    = element; // Clear current SVG child elements\n\n    while (element.firstChild) {\n      element.removeChild(element.firstChild);\n    } // Set viewBox attribute to ensure the svg scales nicely.\n\n\n    element.setAttribute(\"viewBox\", \"0 0 \" + iconSize + \" \" + iconSize);\n    element.setAttribute(\"preserveAspectRatio\", \"xMidYMid meet\");\n  }\n  /**\r\n   * Fills the background with the specified color.\r\n   * @param {string} fillColor  Fill color on the format #rrggbb.\r\n   * @param {number} opacity  Opacity in the range [0.0, 1.0].\r\n   */\n\n\n  _createClass(SvgElement, [{\n    key: \"m\",\n    value: function m(fillColor, opacity) {\n      if (opacity) {\n        SvgElement_append(this.U\n        /*_el*/\n        , \"rect\", SVG_CONSTANTS.R\n        /*WIDTH*/\n        , \"100%\", SVG_CONSTANTS.S\n        /*HEIGHT*/\n        , \"100%\", \"fill\", fillColor, \"opacity\", opacity);\n      }\n    }\n    /**\r\n     * Appends a path to the SVG element.\r\n     * @param {string} color Fill color on format #xxxxxx.\r\n     * @param {string} dataString The SVG path data string.\r\n     */\n\n  }, {\n    key: \"O\",\n    value: function O(color, dataString) {\n      SvgElement_append(this.U\n      /*_el*/\n      , \"path\", \"fill\", color, \"d\", dataString);\n    }\n  }]);\n\n  return SvgElement;\n}();\n/**\r\n * Updates the identicon in the specified `<canvas>` or `<svg>` elements.\r\n * @param {(string|Element)} el - Specifies the container in which the icon is rendered as a DOM element of the type\r\n *    `<svg>` or `<canvas>`, or a CSS selector to such an element.\r\n * @param {*=} hashOrValue - Optional hash or value to be rendered. If not specified, the `data-jdenticon-hash` or\r\n *    `data-jdenticon-value` attribute will be evaluated.\r\n * @param {Object|number=} config - Optional configuration. If specified, this configuration object overrides any\r\n *    global configuration in its entirety. For backward compability a padding value in the range [0.0, 0.5) can be\r\n *    specified in place of a configuration object.\r\n */\n\n\nfunction update(el, hashOrValue, config) {\n  renderDomElement(el, hashOrValue, config, function (el, iconType) {\n    if (iconType) {\n      return iconType == ICON_TYPE_SVG ? new SvgRenderer(new SvgElement(el)) : new CanvasRenderer(\n      /** @type {HTMLCanvasElement} */\n      el.getContext(\"2d\"));\n    }\n  });\n}\n/**\r\n * Updates the identicon in the specified `<canvas>` elements.\r\n * @param {(string|Element)} el - Specifies the container in which the icon is rendered as a DOM element of the type\r\n *    `<canvas>`, or a CSS selector to such an element.\r\n * @param {*=} hashOrValue - Optional hash or value to be rendered. If not specified, the `data-jdenticon-hash` or\r\n *    `data-jdenticon-value` attribute will be evaluated.\r\n * @param {Object|number=} config - Optional configuration. If specified, this configuration object overrides any\r\n *    global configuration in its entirety. For backward compability a padding value in the range [0.0, 0.5) can be\r\n *    specified in place of a configuration object.\r\n */\n\n\nfunction updateCanvas(el, hashOrValue, config) {\n  renderDomElement(el, hashOrValue, config, function (el, iconType) {\n    if (iconType == ICON_TYPE_CANVAS) {\n      return new CanvasRenderer(\n      /** @type {HTMLCanvasElement} */\n      el.getContext(\"2d\"));\n    }\n  });\n}\n/**\r\n * Updates the identicon in the specified `<svg>` elements.\r\n * @param {(string|Element)} el - Specifies the container in which the icon is rendered as a DOM element of the type\r\n *    `<svg>`, or a CSS selector to such an element.\r\n * @param {*=} hashOrValue - Optional hash or value to be rendered. If not specified, the `data-jdenticon-hash` or\r\n *    `data-jdenticon-value` attribute will be evaluated.\r\n * @param {Object|number=} config - Optional configuration. If specified, this configuration object overrides any\r\n *    global configuration in its entirety. For backward compability a padding value in the range [0.0, 0.5) can be\r\n *    specified in place of a configuration object.\r\n */\n\n\nfunction updateSvg(el, hashOrValue, config) {\n  renderDomElement(el, hashOrValue, config, function (el, iconType) {\n    if (iconType == ICON_TYPE_SVG) {\n      return new SvgRenderer(new SvgElement(el));\n    }\n  });\n}\n/**\r\n * Updates the identicon in the specified canvas or svg elements.\r\n * @param {(string|Element)} el - Specifies the container in which the icon is rendered as a DOM element of the type\r\n *    `<svg>` or `<canvas>`, or a CSS selector to such an element.\r\n * @param {*} hashOrValue - Optional hash or value to be rendered. If not specified, the `data-jdenticon-hash` or\r\n *    `data-jdenticon-value` attribute will be evaluated.\r\n * @param {Object|number|undefined} config\r\n * @param {function(Element,number):Renderer} rendererFactory - Factory function for creating an icon renderer.\r\n */\n\n\nfunction renderDomElement(el, hashOrValue, config, rendererFactory) {\n  if (typeof el === \"string\") {\n    if (documentQuerySelectorAll) {\n      var elements = documentQuerySelectorAll(el);\n\n      for (var i = 0; i < elements.length; i++) {\n        renderDomElement(elements[i], hashOrValue, config, rendererFactory);\n      }\n    }\n\n    return;\n  } // Hash selection. The result from getValidHash or computeHash is \n  // accepted as a valid hash.\n\n\n  var hash = // 1. Explicit valid hash\n  isValidHash(hashOrValue) || // 2. Explicit value (`!= null` catches both null and undefined)\n  hashOrValue != null && computeHash(hashOrValue) || // 3. `data-jdenticon-hash` attribute\n  isValidHash(el.getAttribute(ATTRIBUTES.Z\n  /*HASH*/\n  )) || // 4. `data-jdenticon-value` attribute. \n  // We want to treat an empty attribute as an empty value. \n  // Some browsers return empty string even if the attribute \n  // is not specified, so use hasAttribute to determine if \n  // the attribute is specified.\n  el.hasAttribute(ATTRIBUTES.T\n  /*VALUE*/\n  ) && computeHash(el.getAttribute(ATTRIBUTES.T\n  /*VALUE*/\n  ));\n\n  if (!hash) {\n    // No hash specified. Don't render an icon.\n    return;\n  }\n\n  var renderer = rendererFactory(el, getIdenticonType(el));\n\n  if (renderer) {\n    // Draw icon\n    iconGenerator(renderer, hash, config);\n  }\n} // This file is compiled to dist/jdenticon-module.mjs\n\n/**\r\n * Specifies the version of the Jdenticon package in use.\r\n * @type {string}\r\n */\n\n\nvar version = \"3.1.1\";\n/**\r\n * Specifies which bundle of Jdenticon that is used.\r\n * @type {string}\r\n */\n\nvar bundle = \"browser-esm\";\nexport { bundle, configure, drawIcon, toSvg, update, updateCanvas, updateSvg, version }; //# sourceMappingURL=jdenticon-module.mjs.map","map":null,"metadata":{},"sourceType":"module"}