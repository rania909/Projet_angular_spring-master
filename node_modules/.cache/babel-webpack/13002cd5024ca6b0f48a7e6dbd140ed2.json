{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  /**\n   * Namespace to hold static tick generation functions\n   * @namespace Chart.Ticks\n   */\n\n  Chart.Ticks = {\n    /**\n     * Namespace to hold generators for different types of ticks\n     * @namespace Chart.Ticks.generators\n     */\n    generators: {\n      /**\n       * Interface for the options provided to the numeric tick generator\n       * @interface INumericTickGenerationOptions\n       */\n\n      /**\n       * The maximum number of ticks to display\n       * @name INumericTickGenerationOptions#maxTicks\n       * @type Number\n       */\n\n      /**\n       * The distance between each tick.\n       * @name INumericTickGenerationOptions#stepSize\n       * @type Number\n       * @optional\n       */\n\n      /**\n       * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum\n       * @name INumericTickGenerationOptions#min\n       * @type Number\n       * @optional\n       */\n\n      /**\n       * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum\n       * @name INumericTickGenerationOptions#max\n       * @type Number\n       * @optional\n       */\n\n      /**\n       * Generate a set of linear ticks\n       * @method Chart.Ticks.generators.linear\n       * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n       * @param dataRange {IRange} the range of the data\n       * @returns {Array<Number>} array of tick values\n       */\n      linear: function linear(generationOptions, dataRange) {\n        var ticks = []; // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n        // \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n        // for details.\n\n        var spacing;\n\n        if (generationOptions.stepSize && generationOptions.stepSize > 0) {\n          spacing = generationOptions.stepSize;\n        } else {\n          var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n          spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n        }\n\n        var niceMin = Math.floor(dataRange.min / spacing) * spacing;\n        var niceMax = Math.ceil(dataRange.max / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.\n\n        if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n          // If very close to our whole number, use it.\n          if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n            niceMin = generationOptions.min;\n            niceMax = generationOptions.max;\n          }\n        }\n\n        var numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.\n\n        if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n          numSpaces = Math.round(numSpaces);\n        } else {\n          numSpaces = Math.ceil(numSpaces);\n        } // Put the values into the ticks array\n\n\n        ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\n        for (var j = 1; j < numSpaces; ++j) {\n          ticks.push(niceMin + j * spacing);\n        }\n\n        ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n        return ticks;\n      },\n\n      /**\n       * Generate a set of logarithmic ticks\n       * @method Chart.Ticks.generators.logarithmic\n       * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n       * @param dataRange {IRange} the range of the data\n       * @returns {Array<Number>} array of tick values\n       */\n      logarithmic: function logarithmic(generationOptions, dataRange) {\n        var ticks = [];\n        var getValueOrDefault = helpers.getValueOrDefault; // Figure out what the max number of ticks we can support it is based on the size of\n        // the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n        // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n        // the graph\n\n        var tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n        var endExp = Math.floor(helpers.log10(dataRange.max));\n        var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n        var exp;\n        var significand;\n\n        if (tickVal === 0) {\n          exp = Math.floor(helpers.log10(dataRange.minNotZero));\n          significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n          ticks.push(tickVal);\n          tickVal = significand * Math.pow(10, exp);\n        } else {\n          exp = Math.floor(helpers.log10(tickVal));\n          significand = Math.floor(tickVal / Math.pow(10, exp));\n        }\n\n        do {\n          ticks.push(tickVal);\n          ++significand;\n\n          if (significand === 10) {\n            significand = 1;\n            ++exp;\n          }\n\n          tickVal = significand * Math.pow(10, exp);\n        } while (exp < endExp || exp === endExp && significand < endSignificand);\n\n        var lastTick = getValueOrDefault(generationOptions.max, tickVal);\n        ticks.push(lastTick);\n        return ticks;\n      }\n    },\n\n    /**\n     * Namespace to hold formatters for different types of ticks\n     * @namespace Chart.Ticks.formatters\n     */\n    formatters: {\n      /**\n       * Formatter for value labels\n       * @method Chart.Ticks.formatters.values\n       * @param value the value to display\n       * @return {String|Array} the label to display\n       */\n      values: function values(value) {\n        return helpers.isArray(value) ? value : '' + value;\n      },\n\n      /**\n       * Formatter for linear numeric ticks\n       * @method Chart.Ticks.formatters.linear\n       * @param tickValue {Number} the value to be formatted\n       * @param index {Number} the position of the tickValue parameter in the ticks array\n       * @param ticks {Array<Number>} the list of ticks being converted\n       * @return {String} string representation of the tickValue parameter\n       */\n      linear: function linear(tickValue, index, ticks) {\n        // If we have lots of ticks, don't use the ones\n        var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\n        if (Math.abs(delta) > 1) {\n          if (tickValue !== Math.floor(tickValue)) {\n            // not an integer\n            delta = tickValue - Math.floor(tickValue);\n          }\n        }\n\n        var logDelta = helpers.log10(Math.abs(delta));\n        var tickString = '';\n\n        if (tickValue !== 0) {\n          var numDecimal = -1 * Math.floor(logDelta);\n          numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\n          tickString = tickValue.toFixed(numDecimal);\n        } else {\n          tickString = '0'; // never show decimal places for 0\n        }\n\n        return tickString;\n      },\n      logarithmic: function logarithmic(tickValue, index, ticks) {\n        var remain = tickValue / Math.pow(10, Math.floor(helpers.log10(tickValue)));\n\n        if (tickValue === 0) {\n          return '0';\n        } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n          return tickValue.toExponential();\n        }\n\n        return '';\n      }\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}